/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuncom2.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* The most commonly used instructions, part 2. */
/* start DoPushInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariable */

dopushinstancevariable:
  if (_trace) printf("dopushinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableIM:
  if (_trace) printf("DoPushInstanceVariableIM:\n");

DoPushInstanceVariableSP:
  if (_trace) printf("DoPushInstanceVariableSP:\n");

DoPushInstanceVariableLP:
  if (_trace) printf("DoPushInstanceVariableLP:\n");

DoPushInstanceVariableFP:
  if (_trace) printf("DoPushInstanceVariableFP:\n");
  /* arg1 has operand preloaded. */
  arg1 = arg2;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg2 = *(s32 *)(iFP + 16);
  arg5 = *(s32 *)(iFP + 20);
  arg2 = (u32)arg2;
  t2 = arg5 - Type_Array;
  /* Strip CDR code */
  t2 = t2 & 63;
  if (t2 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g6653:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6655;

g6654:
  t7 = zero + 64;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6657;

g6662:
  arg6 = arg6 & Array_LengthMask;
  t3 = arg6 - arg1;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t3 <= 0)
    goto ivbadindex;
  arg2 = arg2 + arg1;
  arg2 = arg2 + 1;
  /* Memory Read Internal */

g6663:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6665;

g6664:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6667;

g6674:
  t1 = arg6;
  t4 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto pushivexception;
  /* Self */
  arg2 = *(s32 *)(iFP + 24);
  t4 = *(s32 *)(iFP + 28);
  arg2 = (u32)arg2;
  t3 = t4 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t3 = t4 & 192;
  /* Check for CDR code 1 */
  t3 = t3 - 64;
  /* J. if CDR code is not 1 */
  if (t3 != 0)
    goto g6652;

g6651:
  if (_trace) printf("g6651:\n");
  arg2 = arg2 + t1;

g6650:
  if (_trace) printf("g6650:\n");
  /* Memory Read Internal */

g6675:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6677;

g6676:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6679;

g6686:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* set CDR-NEXT */
  t7 = arg5 & 63;
  *(u32 *)(iSP + 8) = arg6;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

g6679:
  if (_trace) printf("g6679:\n");
  if ((t7 & 1) == 0)
    goto g6678;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6675;

g6678:
  if (_trace) printf("g6678:\n");

g6677:
  if (_trace) printf("g6677:\n");
  r0 = (u64)&&return0021;
  goto memoryreaddatadecode;
return0021:
  goto g6686;

g6667:
  if (_trace) printf("g6667:\n");
  if ((t7 & 1) == 0)
    goto g6666;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6663;

g6666:
  if (_trace) printf("g6666:\n");

g6665:
  if (_trace) printf("g6665:\n");
  r0 = (u64)&&return0022;
  goto memoryreaddatadecode;
return0022:
  goto g6674;

g6657:
  if (_trace) printf("g6657:\n");
  if ((t7 & 1) == 0)
    goto g6656;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6653;

g6656:
  if (_trace) printf("g6656:\n");

g6655:
  if (_trace) printf("g6655:\n");
  r0 = (u64)&&return0023;
  goto memoryreadheaderdecode;
return0023:
  goto g6662;

g6652:
  if (_trace) printf("g6652:\n");
  t3 = arg2;
  /* Memory Read Internal */

g6687:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6689;

g6688:
  t7 = zero + 64;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6691;

g6696:
  t3 = t3 - arg2;
  if (t3 != 0)
    goto g6651;
  /* TagType. */
  t4 = t4 & 63;
  /* Set CDR code to 1 */
  t4 = t4 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg2;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t4;
  goto g6651;

g6691:
  if (_trace) printf("g6691:\n");
  if ((t7 & 1) == 0)
    goto g6690;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6687;

g6690:
  if (_trace) printf("g6690:\n");

g6689:
  if (_trace) printf("g6689:\n");
  r0 = (u64)&&return0024;
  goto memoryreadheaderdecode;
return0024:
  goto g6696;

/* end DoPushInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariable */
/* start DoAdd */

  /* Halfword operand from stack instruction - DoAdd */
  /* arg2 has the preloaded 8 bit operand. */

doadd:
  if (_trace) printf("doadd:\n");
#ifdef TRACING
#endif

DoAddSP:
  if (_trace) printf("DoAddSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoadd;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoadd;
#endif

DoAddLP:
  if (_trace) printf("DoAddLP:\n");
#ifdef TRACING
  goto begindoadd;
#endif

DoAddFP:
  if (_trace) printf("DoAddFP:\n");

begindoadd:
  if (_trace) printf("begindoadd:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* NIL */
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g6736:
  if (_trace) printf("g6736:\n");
  if (t10 == 0)
    goto g6707;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6713:
  if (_trace) printf("g6713:\n");
  if (t12 == 0)
    goto g6709;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 64-bit result */
//  t5 = (u64)((s32)t2 + (s64)(s32)t4); /* addl/v */
  /* x86_64 replacement for addl/v */
    asm("movl %k2,%k0 \n\t"
	"addl %k3,%k0 \n\t"
	"seto %b1"
        : "=r"(t5),"=rm"(oflo)
        : "rm"(t2),"rm"(t4)
        : "cc");
//  if (t5 >> 32)
//    exception();
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  CHECK_OFLO(); /* check overflow */
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;

g6709:
  if (_trace) printf("g6709:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g6714:
  if (_trace) printf("g6714:\n");
  if (t12 == 0)
    goto g6710;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g6697;

g6710:
  if (_trace) printf("g6710:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g6715:
  if (_trace) printf("g6715:\n");
  if (t12 == 0)
    goto g6704;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g6700;

g6708:
  if (_trace) printf("g6708:\n");

g6707:
  if (_trace) printf("g6707:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g6737:
  if (_trace) printf("g6737:\n");
  if (t10 == 0)
    goto g6716;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g6722:
  if (_trace) printf("g6722:\n");
  if (t12 == 0)
    goto g6718;
  /* Here if argument TypeSingleFloat */

g6697:
  if (_trace) printf("g6697:\n");
  ADDS(0, f0, 1, f1, 2, f2); /* adds */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto cachevalid;

g6718:
  if (_trace) printf("g6718:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6723:
  if (_trace) printf("g6723:\n");
  if (t12 == 0)
    goto g6719;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g6697;

g6719:
  if (_trace) printf("g6719:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g6724:
  if (_trace) printf("g6724:\n");
  if (t12 == 0)
    goto g6704;
  /* Here if argument TypeDoubleFloat */

g6700:
  if (_trace) printf("g6700:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g6701;

g6717:
  if (_trace) printf("g6717:\n");

g6716:
  if (_trace) printf("g6716:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g6738:
  if (_trace) printf("g6738:\n");
  if (t10 == 0)
    goto g6725;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g6731:
  if (_trace) printf("g6731:\n");
  if (t12 == 0)
    goto g6727;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0025;
  goto fetchdoublefloat;
return0025:
  LDT(1, f1, processor->fp0);

g6701:
  if (_trace) printf("g6701:\n");
  arg2 = (u32)t4;
  r0 = (u64)&&return0026;
  goto fetchdoublefloat;
return0026:
  LDT(2, f2, processor->fp0);

g6698:
  if (_trace) printf("g6698:\n");
  ADDT(0, f0, 1, f1, 2, f2); /* addt */
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0027;
  goto consdoublefloat;
return0027:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;

g6727:
  if (_trace) printf("g6727:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g6732:
  if (_trace) printf("g6732:\n");
  if (t12 == 0)
    goto g6728;
  /* Here if argument TypeSingleFloat */

g6699:
  if (_trace) printf("g6699:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0028;
  goto fetchdoublefloat;
return0028:
  LDT(1, f1, processor->fp0);
  goto g6698;

g6728:
  if (_trace) printf("g6728:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6733:
  if (_trace) printf("g6733:\n");
  if (t12 == 0)
    goto g6704;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g6699;

g6726:
  if (_trace) printf("g6726:\n");

g6725:
  if (_trace) printf("g6725:\n");
  /* Here for all other cases */

g6703:
  if (_trace) printf("g6703:\n");

doaddovfl:
  if (_trace) printf("doaddovfl:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g6705;

g6704:
  if (_trace) printf("g6704:\n");
  t1 = t3;
  goto doaddovfl;

g6705:
  if (_trace) printf("g6705:\n");

g6706:
  if (_trace) printf("g6706:\n");
#ifdef TRACING
  goto DoAddIM;
#endif

DoAddIM:
  if (_trace) printf("DoAddIM:\n");
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* get ARG1 tag/data */
  t2 = (s32)arg6;
  /* Strip off any CDR code bits. */
  t11 = t1 & 63;
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6743:
  if (_trace) printf("g6743:\n");
  if (t12 == 0)
    goto g6740;
  /* Here if argument TypeFixnum */
  /* compute 64-bit result */
  t3 = t2 + arg2;
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 32-bit sign-extended result */
  t10 = (s32)t3;
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* is it the same as the 64-bit result? */
  t10 = (t3 == t10) ? 1 : 0;
  /* if not, we overflowed */
  if (t10 == 0)
    goto doaddovfl;
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;

g6740:
  if (_trace) printf("g6740:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  arg2 = zero;
  goto begindoadd;

g6739:
  if (_trace) printf("g6739:\n");

/* end DoAdd */
  /* End of Halfword operand from stack instruction - DoAdd */
/* start DoBlock3Write */

  /* Halfword operand from stack instruction - DoBlock3Write */

doblock3write:
  if (_trace) printf("doblock3write:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoBlock3WriteIM:
  if (_trace) printf("DoBlock3WriteIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g6744:
  if (_trace) printf("g6744:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoblock3write;
#ifdef TRACING
#endif

DoBlock3WriteSP:
  if (_trace) printf("DoBlock3WriteSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoblock3write;
#endif

DoBlock3WriteLP:
  if (_trace) printf("DoBlock3WriteLP:\n");
#ifdef TRACING
  goto headdoblock3write;
#endif

DoBlock3WriteFP:
  if (_trace) printf("DoBlock3WriteFP:\n");

headdoblock3write:
  if (_trace) printf("headdoblock3write:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoblock3write:
  if (_trace) printf("begindoblock3write:\n");
  /* arg1 has the operand, sign extended if immediate. */
  arg3 = *(s32 *)&processor->bar3;
  arg2 = (u64)&processor->bar3;
  goto blockwrite;

/* end DoBlock3Write */
  /* End of Halfword operand from stack instruction - DoBlock3Write */
/* start DoAset1 */

  /* Halfword operand from stack instruction - DoAset1 */
  /* arg2 has the preloaded 8 bit operand. */

doaset1:
  if (_trace) printf("doaset1:\n");
#ifdef TRACING
#endif

DoAset1SP:
  if (_trace) printf("DoAset1SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoaset1;
#endif

DoAset1LP:
  if (_trace) printf("DoAset1LP:\n");
#ifdef TRACING
  goto headdoaset1;
#endif

DoAset1FP:
  if (_trace) printf("DoAset1FP:\n");

headdoaset1:
  if (_trace) printf("headdoaset1:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoaset1:
  if (_trace) printf("begindoaset1:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  /* Get the array tag/data */
  arg4 = *(s32 *)iSP;
  /* Get the array tag/data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  /* Get the new value tag/data */
  t6 = *(s32 *)iSP;
  /* Get the new value tag/data */
  t5 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t6 = (u32)t6;
  /* (sign-extended, for fast bounds check) Index Data */
  arg2 = (s32)arg1 + (s32)0;
  t8 = zero + AutoArrayRegMask;
  t8 = arg4 & t8;
  /* Index Tag */
  arg1 = arg1 >> 32;
  t7 = (u64)&processor->ac0array;
  /* This is the address if the array register block. */
  t7 = t7 + t8;
  t1 = arg1 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto aset1illegal;

aset1merge:
  if (_trace) printf("aset1merge:\n");
  if (arg4 == 0)
    goto aset1regset;
  /* Cached array object. */
  t8 = *(u64 *)&(((ARRAYCACHEP)t7)->array);
  t1 = arg3 - Type_Array;
  /* Strip CDR code, low bits */
  t1 = t1 & 62;
  if (t1 != 0)
    goto reallyaset1exc;
  /* t8==1 iff cached array is ours. */
  t8 = (arg4 == t8) ? 1 : 0;
  /* Go and setup the array register. */
  if (t8 == 0)
    goto aset1regset;
#ifdef SLOWARRAYS
  goto aset1regset;
#endif
  arg6 = *(u64 *)&(((ARRAYCACHEP)t7)->arword);
  /* high order bits all zero */
  t9 = *(u64 *)&(((ARRAYCACHEP)t7)->locat);
  /* high order bits all zero */
  t3 = *(u64 *)&(((ARRAYCACHEP)t7)->length);
  t11 = arg6 << 42;
  t4 = *(u64 *)&(processor->areventcount);
  t11 = t11 >> 42;
  t2 = ((u64)arg2 < (u64)t3) ? 1 : 0;
  t12 = t4 - t11;
  /* J. if event count ticked. */
  if (t12 != 0)
    goto aset1regset;
  if (t2 == 0)
    goto aset1bounds;
  arg5 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);
  arg4 = arg6 >> (Array_RegisterByteOffsetPos & 63);
  arg5 = arg5 & Array_RegisterBytePackingMask;
  arg4 = arg4 & Array_RegisterByteOffsetMask;
  arg6 = t8 & Array_RegisterElementTypeMask;

aset1restart:
  if (_trace) printf("aset1restart:\n");
  /* Element checking and foreplay. */
  /* TagType. */
  t1 = t5 & 63;
  t8 = (arg6 == Array_ElementTypeCharacter) ? 1 : 0;

g6755:
  if (_trace) printf("g6755:\n");
  if (t8 == 0)
    goto g6751;
  /* Here if argument ArrayElementTypeCharacter */
  t2 = t1 - Type_Character;
  if (t2 == 0)
    goto g6746;
  arg5 = 0;
  arg2 = 29;
  goto illegaloperand;

g6746:
  if (_trace) printf("g6746:\n");
  /* Certainly will fit if not packed! */
  if (arg5 == 0)
    goto g6745;
  t2 = 32;
  /* Compute size of byte */
  t2 = t2 >> (arg5 & 63);
  t1 = ~zero;
  t1 = t1 << (t2 & 63);
  /* Compute mask for byte */
  t1 = ~t1;
  t1 = t6 & t1;
  t1 = t6 - t1;
  /* J. if character fits. */
  if (t1 == 0)
    goto g6745;
  arg5 = 0;
  arg2 = 62;
  goto illegaloperand;

g6751:
  if (_trace) printf("g6751:\n");
  t8 = (arg6 == Array_ElementTypeFixnum) ? 1 : 0;

g6756:
  if (_trace) printf("g6756:\n");
  if (t8 == 0)
    goto g6752;
  /* Here if argument ArrayElementTypeFixnum */
  t2 = t1 - Type_Fixnum;
  if (t2 == 0)
    goto g6745;
  arg5 = 0;
  arg2 = 33;
  goto illegaloperand;

g6752:
  if (_trace) printf("g6752:\n");
  t8 = (arg6 == Array_ElementTypeBoolean) ? 1 : 0;

g6757:
  if (_trace) printf("g6757:\n");
  if (t8 == 0)
    goto g6750;
  /* Here if argument ArrayElementTypeBoolean */
  t6 = 1;
  t1 = t1 - Type_NIL;
  /* J. if True */
  if (t1 != 0)
    goto g6745;
  t6 = zero;
  goto g6745;

g6750:
  if (_trace) printf("g6750:\n");
  /* Shove it in. */

g6745:
  if (_trace) printf("g6745:\n");
  /* J. if packed */
  if (arg5 != 0)
    goto g6747;
  t1 = arg6 - Array_ElementTypeObject;
  if (t1 != 0)
    goto g6747;
  /* Here for the simple non packed case */
  t1 = t9 + arg2;
  /* Memory Read Internal */

g6758:
  /* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t8 = t1 + ivory;
  t7 = *(s32 *)&processor->scovlimit;
  t3 = (t8 * 4);
  t2 = LDQ_U(t8);
  /* Stack cache offset */
  t4 = t1 - t4;
  arg1 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t4 < (u64)t7) ? 1 : 0;
  t3 = *(s32 *)t3;
  t2 = (u8)(t2 >> ((t8&7)*8));
  if (t7 != 0)
    goto g6760;

g6759:
  t8 = zero + 240;
  arg1 = arg1 >> (t2 & 63);
  t8 = t8 >> (t2 & 63);
  if (arg1 & 1)
    goto g6762;

g6768:
  /* Merge cdr-code */
  t3 = t5 & 63;
  t2 = t2 & 192;
  t2 = t2 | t3;
  t7 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  arg1 = *(s32 *)&processor->scovlimit;
  t3 = (t4 * 4);
  t8 = LDQ_U(t4);
  /* Stack cache offset */
  t7 = t1 - t7;
  /* In range? */
  arg1 = ((u64)t7 < (u64)arg1) ? 1 : 0;
  t7 = (t2 & 0xff) << ((t4&7)*8);
  t8 = t8 & ~(0xffL << (t4&7)*8);

g6770:
  if (_trace) printf("g6770:\n");
  t8 = t8 | t7;
  STQ_U(t4, t8);
  *(u32 *)t3 = t6;
  /* J. if in cache */
  if (arg1 != 0)
    goto g6769;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;
  /* Here for the slow packed version */

g6747:
  if (_trace) printf("g6747:\n");
  arg2 = arg4 + arg2;
  /* Convert byte index to word index */
  t1 = arg2 >> (arg5 & 63);
  /* Address of word containing byte */
  t1 = t1 + t9;
  /* Memory Read Internal */

g6771:
  /* Base of stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;
  t9 = (t4 * 4);
  arg3 = LDQ_U(t4);
  /* Stack cache offset */
  t2 = t1 - t2;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;
  t9 = *(s32 *)t9;
  arg3 = (u8)(arg3 >> ((t4&7)*8));
  if (t3 != 0)
    goto g6773;

g6772:
  t4 = zero + 240;
  t7 = t7 >> (arg3 & 63);
  t4 = t4 >> (arg3 & 63);
  t9 = (u32)t9;
  if (t7 & 1)
    goto g6775;

g6782:
  /* Check fixnum element type */
  /* TagType. */
  t2 = arg3 & 63;
  t2 = t2 - Type_Fixnum;
  /* J. if element type not fixnum. */
  if (t2 != 0)
    goto g6748;
  /* J. if unpacked fixnum element type. */
  if (arg5 == 0)
    goto g6749;
  t8 = ~zero;
  t8 = t8 << (arg5 & 63);
  t2 = zero - arg5;
  /* Compute subword index */
  t8 = arg2 & ~t8;
  t2 = t2 + 5;
  /* Compute shift to get byte */
  t2 = t8 << (t2 & 63);
  t8 = 32;
  /* Compute size of byte */
  t8 = t8 >> (arg5 & 63);
  t3 = ~zero;
  t3 = t3 << (t8 & 63);
  /* Compute mask for byte */
  t4 = ~t3;
  /* inserting into the low byte is easy */
  if (t2 == 0)
    goto g6783;
  /* Inserting the byte into any byte other than the low byte */
  t7 = 64;
  /* = the left shift rotate amount */
  t8 = t7 - t2;
  /* shift selected byte into low end of word. */
  t7 = t9 >> (t2 & 63);
  /* rotate low bits into high end of word. */
  t9 = t9 << (t8 & 63);
  /* Remove unwanted bits */
  t7 = t3 & t7;
  /* rotate low bits back into place. */
  t9 = t9 >> (t8 & 63);
  /* Strip any extra bits from element */
  t8 = t6 & t4;
  /* Insert new bits. */
  t7 = t8 | t7;
  /* reposition bits */
  t7 = t7 << (t2 & 63);
  /* Replace low order bits */
  t9 = t9 | t7;
  goto g6784;

g6783:
  if (_trace) printf("g6783:\n");
  /* Inserting the byte into the low byte */
  /* Remove the old low byte */
  t9 = t9 & t3;
  /* Remove unwanted bits from the new byte */
  t8 = t6 & t4;
  /* Insert the new byte in place of the old byte */
  t9 = t9 | t8;

g6784:
  if (_trace) printf("g6784:\n");
  t6 = t9;

g6749:
  if (_trace) printf("g6749:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);
  t2 = t1 + ivory;
  t8 = *(s32 *)&processor->scovlimit;
  t7 = (t2 * 4);
  t4 = LDQ_U(t2);
  /* Stack cache offset */
  t3 = t1 - t3;
  /* In range? */
  t8 = ((u64)t3 < (u64)t8) ? 1 : 0;
  t3 = (arg3 & 0xff) << ((t2&7)*8);
  t4 = t4 & ~(0xffL << (t2&7)*8);

g6786:
  if (_trace) printf("g6786:\n");
  t4 = t4 | t3;
  STQ_U(t2, t4);
  *(u32 *)t7 = t6;
  /* J. if in cache */
  if (t8 != 0)
    goto g6785;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g6748:
  if (_trace) printf("g6748:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;
#ifdef TRACING
  goto DoAset1IM;
#endif

DoAset1IM:
  if (_trace) printf("DoAset1IM:\n");
  t8 = zero + AutoArrayRegMask;
  /* Get the array tag/data */
  arg4 = *(s32 *)iSP;
  /* Get the array tag/data */
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  t7 = (u64)&processor->ac0array;
  t8 = arg4 & t8;
  /* This is the address of the array register block. */
  t7 = t7 + t8;
  /* Get the new value tag/data */
  t6 = *(s32 *)iSP;
  /* Get the new value tag/data */
  t5 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t6 = (u32)t6;
  goto aset1merge;

g6785:
  if (_trace) printf("g6785:\n");
  t3 = *(u64 *)&(processor->stackcachebasevma);

g6787:
  if (_trace) printf("g6787:\n");
  t2 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t3 = t1 - t3;
  /* reconstruct SCA */
  t2 = (t3 * 8) + t2;
  /* Store in stack */
  *(u32 *)t2 = t6;
  /* write the stack cache */
  *(u32 *)(t2 + 4) = arg3;
  goto NEXTINSTRUCTION;

g6773:
  if (_trace) printf("g6773:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t2 = (t2 * 8) + t3;
  t9 = *(s32 *)t2;
  /* Read from stack cache */
  arg3 = *(s32 *)(t2 + 4);
  goto g6772;

g6775:
  if (_trace) printf("g6775:\n");
  if ((t4 & 1) == 0)
    goto g6774;
  /* Do the indirect thing */
  t1 = (u32)t9;
  goto g6771;

g6774:
  if (_trace) printf("g6774:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t4 = arg3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t4 = (t4 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t4;

g6779:
  if (_trace) printf("g6779:\n");
  t4 = t7 & MemoryActionTransform;
  if (t4 == 0)
    goto g6778;
  arg3 = arg3 & ~63L;
  arg3 = arg3 | Type_ExternalValueCellPointer;
  goto g6782;
#ifndef MINIMA

g6778:
#endif
#ifdef MINIMA

g6778:
  if (_trace) printf("g6778:\n");
  t4 = t7 & MemoryActionBinding;
  t3 = *(u64 *)&(processor->dbcmask);
  if (t4 == 0)
    goto g6777;
  t2 = t1 << 1;
  t4 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t2 = t2 & t3;
  t3 = 1;
  t3 = t3 << (ivorymemorydata & 63);
  t2 = (s32)t2 + (s32)t4;
  /* Clear sign-extension */
  t2 = (u32)t2;
  t3 = (t2 * 4) + t3;
  /* Fetch the key */
  t2 = *(s32 *)t3;
  /* Fetch value */
  t9 = *(s32 *)(t3 + 4);
  /* Compare */
  t4 = (s32)t1 - (s32)t2;
  /* Trap on miss */
  if (t4 != 0)
    goto g6781;
  /* Extract the pointer, and indirect */
  t1 = (u32)t9;
  goto g6771;

g6781:
  if (_trace) printf("g6781:\n");
  goto dbcachemisstrap;
#endif

g6777:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

g6769:
  if (_trace) printf("g6769:\n");
  t7 = *(u64 *)&(processor->stackcachebasevma);

g6788:
  if (_trace) printf("g6788:\n");
  t4 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = t1 - t7;
  /* reconstruct SCA */
  t4 = (t7 * 8) + t4;
  /* Store in stack */
  *(u32 *)t4 = t6;
  /* write the stack cache */
  *(u32 *)(t4 + 4) = t2;
  goto NEXTINSTRUCTION;

g6760:
  if (_trace) printf("g6760:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t7;
  t3 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g6759;

g6762:
  if (_trace) printf("g6762:\n");
  if ((t8 & 1) == 0)
    goto g6761;
  /* Do the indirect thing */
  t1 = (u32)t3;
  goto g6758;

g6761:
  if (_trace) printf("g6761:\n");
  /* Load the memory action table for cycle */
  arg1 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + arg1;
  /* Get the memory action */
  arg1 = *(s32 *)t8;
#ifndef MINIMA

g6765:
#endif
#ifdef MINIMA

g6765:
  if (_trace) printf("g6765:\n");
  t8 = arg1 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g6764;
  t4 = t1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t8;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t7 = (t4 * 4) + t7;
  /* Fetch the key */
  t4 = *(s32 *)t7;
  /* Fetch value */
  t3 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)t1 - (s32)t4;
  /* Trap on miss */
  if (t8 != 0)
    goto g6767;
  /* Extract the pointer, and indirect */
  t1 = (u32)t3;
  goto g6758;

g6767:
  if (_trace) printf("g6767:\n");
  goto dbcachemisstrap;
#endif

g6764:
  /* Perform memory action */
  arg1 = arg1;
  arg2 = 1;
  goto performmemoryaction;

/* end DoAset1 */
  /* End of Halfword operand from stack instruction - DoAset1 */
/* start DoFastAref1 */

  /* Halfword operand from stack instruction - DoFastAref1 */
  /* arg2 has the preloaded 8 bit operand. */

dofastaref1:
  if (_trace) printf("dofastaref1:\n");
#ifdef TRACING
#endif

DoFastAref1SP:
  if (_trace) printf("DoFastAref1SP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindofastaref1;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindofastaref1;
#endif

DoFastAref1LP:
  if (_trace) printf("DoFastAref1LP:\n");
#ifdef TRACING
  goto begindofastaref1;
#endif

DoFastAref1FP:
  if (_trace) printf("DoFastAref1FP:\n");

begindofastaref1:
  if (_trace) printf("begindofastaref1:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  arg3 = (u32)(arg6 >> ((4&7)*8));
  arg4 = (s32)arg6;
  t1 = arg3 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto fastaref1iop;

fastaref1retry:
  if (_trace) printf("fastaref1retry:\n");
  arg6 = *(s32 *)arg1;
  t9 = *(s32 *)(arg1 + 8);
  t3 = *(s32 *)(arg1 + 16);
  arg6 = (u32)arg6;
  t9 = (u32)t9;
  t5 = arg6 << 42;
  t3 = (u32)t3;
  t4 = *(u64 *)&(processor->areventcount);
  t5 = t5 >> 42;
  t2 = ((u64)arg4 < (u64)t3) ? 1 : 0;
  if (t2 == 0)
    goto fastaref1bounds;
  t6 = t4 - t5;
  if (t6 != 0)
    goto aref1recomputearrayregister;
  t6 = arg6 >> (Array_RegisterBytePackingPos & 63);
  t7 = arg6 >> (Array_RegisterByteOffsetPos & 63);
  t8 = arg6 >> (Array_RegisterElementTypePos & 63);
  t6 = t6 & Array_RegisterBytePackingMask;
  t7 = t7 & Array_RegisterByteOffsetMask;
  t8 = t8 & Array_RegisterElementTypeMask;
  if (t6 != 0)
    goto g6789;
  t1 = t9 + arg4;

g6790:
  if (_trace) printf("g6790:\n");
  /* Memory Read Internal */

g6797:
  /* Base of stack cache */
  t2 = *(u64 *)&(processor->stackcachebasevma);
  t4 = t1 + ivory;
  t3 = *(s32 *)&processor->scovlimit;
  t9 = (t4 * 4);
  arg5 = LDQ_U(t4);
  /* Stack cache offset */
  t2 = t1 - t2;
  t5 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t3 = ((u64)t2 < (u64)t3) ? 1 : 0;
  t9 = *(s32 *)t9;
  arg5 = (u8)(arg5 >> ((t4&7)*8));
  if (t3 != 0)
    goto g6799;

g6798:
  t4 = zero + 240;
  t5 = t5 >> (arg5 & 63);
  t4 = t4 >> (arg5 & 63);
  t9 = (u32)t9;
  if (t5 & 1)
    goto g6801;

g6808:
  if (t6 != 0)
    goto g6791;

g6792:
  if (_trace) printf("g6792:\n");
  r31 = r31 | r31;
  t1 = t8 - 2;
  if ((s64)t1 <= 0)
    goto g6793;
  /* TagType. */
  arg5 = arg5 & 63;

g6794:
  if (_trace) printf("g6794:\n");
  *(u32 *)(iSP + 4) = arg5;
  t4 = (t6 == 0) ? 1 : 0;
  if (t4 == 0)
    goto case_others_14;

case_0_8:
  if (_trace) printf("case_0_8:\n");
  r31 = r31 | r31;
  if (t1 == 0)
    goto g6795;
  *(u32 *)iSP = t9;
  goto NEXTINSTRUCTION;

case_2_9:
  if (_trace) printf("case_2_9:\n");
  /* AREF1-8B */
  r31 = r31 | r31;
  t4 = arg4 & 3;
  t5 = (u8)(t9 >> ((t4&7)*8));
  if (t1 == 0)
    goto g6795;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;

case_3_10:
  if (_trace) printf("case_3_10:\n");
  /* AREF1-4B */
  r31 = r31 | r31;
  /* byte-index */
  t4 = arg4 & 7;
  /* byte-position */
  t4 = t4 << 2;
  /* byte in position */
  t5 = t9 >> (t4 & 63);
  /* byte masked */
  t5 = t5 & 15;
  if (t1 == 0)
    goto g6795;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;

case_5_11:
  if (_trace) printf("case_5_11:\n");
  /* AREF1-1B */
  r31 = r31 | r31;
  /* byte-index */
  t4 = arg4 & 31;
  r31 = r31 | r31;
  /* byte in position */
  t5 = t9 >> (t4 & 63);
  /* byte masked */
  t5 = t5 & 1;
  if (t1 == 0)
    goto g6795;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;

case_1_12:
  if (_trace) printf("case_1_12:\n");
  /* AREF1-16B */
  t4 = arg4 & 1;
  /* Bletch, it's a byte ref */
  t4 = t4 + t4;
  t5 = (u16)(t9 >> ((t4&7)*8));
  if (t1 == 0)
    goto g6795;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;

case_others_14:
  if (_trace) printf("case_others_14:\n");
  r31 = r31 | r31;
  t4 = (t6 == 2) ? 1 : 0;
  t5 = (t6 == 3) ? 1 : 0;
  if (t4 != 0)
    goto case_2_9;
  t4 = (t6 == 5) ? 1 : 0;
  if (t5 != 0)
    goto case_3_10;
  t5 = (t6 == 1) ? 1 : 0;
  if (t4 != 0)
    goto case_5_11;
  if (t5 != 0)
    goto case_1_12;

case_4_13:
  if (_trace) printf("case_4_13:\n");
  /* AREF1-2B */
  r31 = r31 | r31;
  /* byte-index */
  t4 = arg4 & 15;
  /* byte-position */
  t4 = t4 << 1;
  /* byte in position */
  t5 = t9 >> (t4 & 63);
  /* byte masked */
  t5 = t5 & 3;
  if (t1 == 0)
    goto g6795;
  *(u32 *)iSP = t5;
  goto NEXTINSTRUCTION;

g6789:
  if (_trace) printf("g6789:\n");
  arg4 = t7 + arg4;
  /* Convert byte index to word index */
  t1 = arg4 >> (t6 & 63);
  /* Address of word containing byte */
  t1 = t1 + t9;
  goto g6790;

g6791:
  if (_trace) printf("g6791:\n");
  t1 = arg5 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto g6796;
  goto g6792;

g6793:
  if (_trace) printf("g6793:\n");
  arg5 = Type_Character;
  if (t8 & 1)
    goto g6794;
  arg5 = Type_Fixnum;
  if (t8 == 0)
    goto g6794;
  t2 = *(u64 *)&(processor->niladdress);
  t3 = *(u64 *)&(processor->taddress);
  goto g6794;

g6795:
  if (_trace) printf("g6795:\n");
  if (t5)
    t2 = t3;
  *(u64 *)iSP = t2;
  goto NEXTINSTRUCTION;

g6796:
  if (_trace) printf("g6796:\n");
  arg5 = t1;
  arg2 = 25;
  goto illegaloperand;

fastaref1iop:
  if (_trace) printf("fastaref1iop:\n");
  arg5 = 0;
  arg2 = 32;
  goto illegaloperand;

fastaref1bounds:
  if (_trace) printf("fastaref1bounds:\n");
  arg5 = 0;
  arg2 = 13;
  goto illegaloperand;

g6799:
  if (_trace) printf("g6799:\n");
  t3 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t2 = (t2 * 8) + t3;
  t9 = *(s32 *)t2;
  /* Read from stack cache */
  arg5 = *(s32 *)(t2 + 4);
  goto g6798;

g6801:
  if (_trace) printf("g6801:\n");
  if ((t4 & 1) == 0)
    goto g6800;
  /* Do the indirect thing */
  t1 = (u32)t9;
  goto g6797;

g6800:
  if (_trace) printf("g6800:\n");
  /* Load the memory action table for cycle */
  t5 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t4 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t4 = (t4 * 4) + t5;
  /* Get the memory action */
  t5 = *(s32 *)t4;

g6805:
  if (_trace) printf("g6805:\n");
  t4 = t5 & MemoryActionTransform;
  if (t4 == 0)
    goto g6804;
  arg5 = arg5 & ~63L;
  arg5 = arg5 | Type_ExternalValueCellPointer;
  goto g6808;
#ifndef MINIMA

g6804:
#endif
#ifdef MINIMA

g6804:
  if (_trace) printf("g6804:\n");
  t4 = t5 & MemoryActionBinding;
  t3 = *(u64 *)&(processor->dbcmask);
  if (t4 == 0)
    goto g6803;
  t2 = t1 << 1;
  t4 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t2 = t2 & t3;
  t3 = 1;
  t3 = t3 << (ivorymemorydata & 63);
  t2 = (s32)t2 + (s32)t4;
  /* Clear sign-extension */
  t2 = (u32)t2;
  t3 = (t2 * 4) + t3;
  /* Fetch the key */
  t2 = *(s32 *)t3;
  /* Fetch value */
  t9 = *(s32 *)(t3 + 4);
  /* Compare */
  t4 = (s32)t1 - (s32)t2;
  /* Trap on miss */
  if (t4 != 0)
    goto g6807;
  /* Extract the pointer, and indirect */
  t1 = (u32)t9;
  goto g6797;

g6807:
  if (_trace) printf("g6807:\n");
  goto dbcachemisstrap;
#endif

g6803:
  /* Perform memory action */
  arg1 = t5;
  arg2 = 0;
  goto performmemoryaction;
#ifdef TRACING
#endif

DoFastAref1IM:
  goto doistageerror;

/* end DoFastAref1 */
  /* End of Halfword operand from stack instruction - DoFastAref1 */
/* start DoRplaca */

  /* Halfword operand from stack instruction - DoRplaca */

dorplaca:
  if (_trace) printf("dorplaca:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRplacaIM:
  if (_trace) printf("DoRplacaIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g6822:
  if (_trace) printf("g6822:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindorplaca;
#ifdef TRACING
#endif

DoRplacaSP:
  if (_trace) printf("DoRplacaSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto headdorplaca;
  /* SP-pop mode, TOS->arg1 */
  arg1 = arg6;
  /* Reload TOS */
  arg6 = *(u64 *)arg4;
  /* Adjust SP */
  iSP = arg4;
  goto begindorplaca;
#ifdef TRACING
  goto headdorplaca;
#endif

DoRplacaLP:
  if (_trace) printf("DoRplacaLP:\n");
#ifdef TRACING
  goto headdorplaca;
#endif

DoRplacaFP:
  if (_trace) printf("DoRplacaFP:\n");

headdorplaca:
  if (_trace) printf("headdorplaca:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindorplaca:
  if (_trace) printf("begindorplaca:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* Read ARG1, the list */
  arg2 = (u32)arg6;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* TagType. */
  t3 = t1 & 63;
  t4 = t3 - Type_List;
  t4 = t4 & ~4L;
  if (t4 != 0)
    goto rplacaexception;

rplacstore:
  if (_trace) printf("rplacstore:\n");
  /* Tag for t2 */
  t2 = arg1 >> 32;
  /* data for t2 */
  arg1 = (u32)arg1;
  /* Memory Read Internal */

g6809:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6811;

g6810:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6813;

g6819:
  /* Merge cdr-code */
  arg6 = t2 & 63;
  arg5 = arg5 & 192;
  arg5 = arg5 | arg6;
  t5 = arg2 + ivory;
  arg6 = (t5 * 4);
  t7 = LDQ_U(t5);
  /* Stack cache offset */
  t6 = arg2 - t11;
  /* In range? */
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;
  t6 = (arg5 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g6821:
  if (_trace) printf("g6821:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)arg6 = arg1;
  /* J. if in cache */
  if (t8 != 0)
    goto g6820;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g6820:
  if (_trace) printf("g6820:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t6 = arg2 - t11;
  /* reconstruct SCA */
  t5 = (t6 * 8) + t5;
  /* Store in stack */
  *(u32 *)t5 = arg1;
  /* write the stack cache */
  *(u32 *)(t5 + 4) = arg5;
  goto NEXTINSTRUCTION;

g6811:
  if (_trace) printf("g6811:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  arg6 = *(s32 *)t5;
  /* Read from stack cache */
  arg5 = *(s32 *)(t5 + 4);
  goto g6810;

g6813:
  if (_trace) printf("g6813:\n");
  if ((t7 & 1) == 0)
    goto g6812;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6809;

g6812:
  if (_trace) printf("g6812:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t7 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g6816:
#endif
#ifdef MINIMA

g6816:
  if (_trace) printf("g6816:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g6815;
  t5 = arg2 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  arg6 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg2 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g6818;
  /* Extract the pointer, and indirect */
  arg2 = (u32)arg6;
  goto g6809;

g6818:
  if (_trace) printf("g6818:\n");
  goto dbcachemisstrap;
#endif

g6815:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

/* end DoRplaca */
  /* End of Halfword operand from stack instruction - DoRplaca */
/* start MemoryReadWrite */


memoryreadwrite:
  if (_trace) printf("memoryreadwrite:\n");
  /* Memory Read Internal */

g6823:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6825;

g6824:
  t7 = zero + 240;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  arg6 = (u32)arg6;
  if (t8 & 1)
    goto g6827;

g6832:
  goto *r0; /* ret */

memoryreadwritedecode:
  if (_trace) printf("memoryreadwritedecode:\n");
  if (t6 == 0)
    goto g6826;

g6825:
  if (_trace) printf("g6825:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  arg6 = *(s32 *)t5;
  /* Read from stack cache */
  arg5 = *(s32 *)(t5 + 4);
  goto g6824;

g6827:
  if (_trace) printf("g6827:\n");
  if ((t7 & 1) == 0)
    goto g6826;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6823;

g6826:
  if (_trace) printf("g6826:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t7 = arg5 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg2;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g6829:
#endif
#ifdef MINIMA

g6829:
  if (_trace) printf("g6829:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g6828;
  t5 = arg2 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  arg6 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg2 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g6831;
  /* Extract the pointer, and indirect */
  arg2 = (u32)arg6;
  goto g6823;

g6831:
  if (_trace) printf("g6831:\n");
  goto dbcachemisstrap;
#endif

g6828:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

/* end MemoryReadWrite */
/* start DoRplacd */

  /* Halfword operand from stack instruction - DoRplacd */

dorplacd:
  if (_trace) printf("dorplacd:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRplacdIM:
  if (_trace) printf("DoRplacdIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g6843:
  if (_trace) printf("g6843:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindorplacd;
#ifdef TRACING
#endif

DoRplacdSP:
  if (_trace) printf("DoRplacdSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto headdorplacd;
  /* SP-pop mode, TOS->arg1 */
  arg1 = arg6;
  /* Reload TOS */
  arg6 = *(u64 *)arg4;
  /* Adjust SP */
  iSP = arg4;
  goto begindorplacd;
#ifdef TRACING
  goto headdorplacd;
#endif

DoRplacdLP:
  if (_trace) printf("DoRplacdLP:\n");
#ifdef TRACING
  goto headdorplacd;
#endif

DoRplacdFP:
  if (_trace) printf("DoRplacdFP:\n");

headdorplacd:
  if (_trace) printf("headdorplacd:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindorplacd:
  if (_trace) printf("begindorplacd:\n");
  /* arg1 has the operand, sign extended if immediate. */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* Read ARG1, the list */
  arg2 = (u32)arg6;
  /* Pop Stack. */
  iSP = iSP - 8;
  /* TagType. */
  t3 = t1 & 63;
  t4 = t3 - Type_Locative;
  if (t4 == 0)
    goto rplacstore;
  t4 = t3 - Type_List;
  if (t4 != 0)
    goto rplacdexception;
  /* Memory Read Internal */

g6833:
  t7 = arg2 + ivory;
  arg6 = (t7 * 4);
  arg5 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg2 - t11;
  t8 = *(u64 *)&(processor->cdr_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  arg6 = *(s32 *)arg6;
  arg5 = (u8)(arg5 >> ((t7&7)*8));
  if (t6 != 0)
    goto g6835;

g6834:
  t7 = zero + 192;
  t8 = t8 >> (arg5 & 63);
  t7 = t7 >> (arg5 & 63);
  if (t8 & 1)
    goto g6837;

g6842:
  /* TagCdr. */
  arg5 = arg5 >> 6;
  arg5 = arg5 - Cdr_Normal;
  /* J. if CDR coded */
  if (arg5 != 0)
    goto rplacdexception;
  /* address of CDR */
  arg2 = arg2 + 1;
  goto rplacstore;

g6837:
  if (_trace) printf("g6837:\n");
  if ((t7 & 1) == 0)
    goto g6836;
  /* Do the indirect thing */
  arg2 = (u32)arg6;
  goto g6833;

g6836:
  if (_trace) printf("g6836:\n");

g6835:
  if (_trace) printf("g6835:\n");
  r0 = (u64)&&return0029;
  goto memoryreadcdrdecode;
return0029:
  goto g6842;

/* end DoRplacd */
  /* End of Halfword operand from stack instruction - DoRplacd */
/* start DoBranchTrueAndExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndExtraPop */

dobranchtrueandextrapop:
  if (_trace) printf("dobranchtrueandextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueAndExtraPopIM:
  if (_trace) printf("DoBranchTrueAndExtraPopIM:\n");

DoBranchTrueAndExtraPopSP:
  if (_trace) printf("DoBranchTrueAndExtraPopSP:\n");

DoBranchTrueAndExtraPopLP:
  if (_trace) printf("DoBranchTrueAndExtraPopLP:\n");

DoBranchTrueAndExtraPopFP:
  if (_trace) printf("DoBranchTrueAndExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto dobrpopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrpopextrapop:
  if (_trace) printf("dobrpopextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 16;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueAndExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndExtraPop */
/* start DoBranchFalseAndExtraPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndExtraPop */

dobranchfalseandextrapop:
  if (_trace) printf("dobranchfalseandextrapop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseAndExtraPopIM:
  if (_trace) printf("DoBranchFalseAndExtraPopIM:\n");

DoBranchFalseAndExtraPopSP:
  if (_trace) printf("DoBranchFalseAndExtraPopSP:\n");

DoBranchFalseAndExtraPopLP:
  if (_trace) printf("DoBranchFalseAndExtraPopLP:\n");

DoBranchFalseAndExtraPopFP:
  if (_trace) printf("DoBranchFalseAndExtraPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto dobrnpopextrapop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrnpopextrapop:
  if (_trace) printf("dobrnpopextrapop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 16;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseAndExtraPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndExtraPop */
/* start DoBranchTrueAndNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPop */

dobranchtrueandnopop:
  if (_trace) printf("dobranchtrueandnopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchTrueAndNoPopIM:
  if (_trace) printf("DoBranchTrueAndNoPopIM:\n");

DoBranchTrueAndNoPopSP:
  if (_trace) printf("DoBranchTrueAndNoPopSP:\n");

DoBranchTrueAndNoPopLP:
  if (_trace) printf("DoBranchTrueAndNoPopLP:\n");

DoBranchTrueAndNoPopFP:
  if (_trace) printf("DoBranchTrueAndNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto dobrelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrelsepop:
  if (_trace) printf("dobrelsepop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchTrueAndNoPop */
  /* End of Halfword operand from stack instruction - DoBranchTrueAndNoPop */
/* start DoBranchFalseAndNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPop */

dobranchfalseandnopop:
  if (_trace) printf("dobranchfalseandnopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseAndNoPopIM:
  if (_trace) printf("DoBranchFalseAndNoPopIM:\n");

DoBranchFalseAndNoPopSP:
  if (_trace) printf("DoBranchFalseAndNoPopSP:\n");

DoBranchFalseAndNoPopLP:
  if (_trace) printf("DoBranchFalseAndNoPopLP:\n");

DoBranchFalseAndNoPopFP:
  if (_trace) printf("DoBranchFalseAndNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 == 0)
    goto dobrnelsepop;
  /* Here if branch not taken.  Pop the argument. */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  iSP = iSP - 8;
  goto cachevalid;

dobrnelsepop:
  if (_trace) printf("dobrnelsepop:\n");
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseAndNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseAndNoPop */
/* start DoBranchFalseElseNoPop */

  /* Halfword 10 bit immediate instruction - DoBranchFalseElseNoPop */

dobranchfalseelsenopop:
  if (_trace) printf("dobranchfalseelsenopop:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoBranchFalseElseNoPopIM:
  if (_trace) printf("DoBranchFalseElseNoPopIM:\n");

DoBranchFalseElseNoPopSP:
  if (_trace) printf("DoBranchFalseElseNoPopSP:\n");

DoBranchFalseElseNoPopLP:
  if (_trace) printf("DoBranchFalseElseNoPopLP:\n");

DoBranchFalseElseNoPopFP:
  if (_trace) printf("DoBranchFalseElseNoPopFP:\n");
  /* arg1 has signed operand preloaded. */
  /* Check tag of word in TOS. */
  t1 = (u32)(arg6 >> ((4&7)*8));
#ifndef CACHEMETERING
  arg2 = *(u64 *)&(((CACHELINEP)iCP)->annotation);
#endif
  /* Get signed 10-bit immediate arg */
  arg1 = (s64)arg3 >> 48;
  /* TagType. */
  /* strip the cdr code off. */
  t1 = t1 & 63;
  /* Compare to NIL */
  t1 = t1 - Type_NIL;
  if (t1 != 0)
    goto NEXTINSTRUCTION;
  /* Can't branch to ourself */
  if (arg1 == 0)
    goto branchexception;
  iSP = iSP - 8;
  /* Update the PC in halfwords */
  iPC = iPC + arg1;
#ifndef CACHEMETERING
  if (arg2 != 0)
    goto interpretinstructionpredicted;
#endif
  goto interpretinstructionforbranch;

/* end DoBranchFalseElseNoPop */
  /* End of Halfword operand from stack instruction - DoBranchFalseElseNoPop */
/* start DoEqualNumber */

  /* Halfword operand from stack instruction - DoEqualNumber */
  /* arg2 has the preloaded 8 bit operand. */

doequalnumber:
  if (_trace) printf("doequalnumber:\n");
#ifdef TRACING
#endif

DoEqualNumberSP:
  if (_trace) printf("DoEqualNumberSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoequalnumber;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoequalnumber;
#endif

DoEqualNumberLP:
  if (_trace) printf("DoEqualNumberLP:\n");
#ifdef TRACING
  goto begindoequalnumber;
#endif

DoEqualNumberFP:
  if (_trace) printf("DoEqualNumberFP:\n");

begindoequalnumber:
  if (_trace) printf("begindoequalnumber:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->niladdress);
  t7 = arg3 >> 12;
  t12 = *(u64 *)&(processor->taddress);
  /* Get ARG1 tag */
  arg3 = (u32)(arg6 >> ((4&7)*8));
  /* t1 is tag of arg2 */
  t1 = *(s32 *)(arg1 + 4);
  LDS(1, f1, *(u32 *)iSP );
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t5 = arg3 & 63;
  /* Strip off any CDR code bits. */
  t4 = t1 & 63;
  t6 = (t5 == Type_Fixnum) ? 1 : 0;

g6861:
  if (_trace) printf("g6861:\n");
  if (t6 == 0)
    goto g6849;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;

g6853:
  if (_trace) printf("g6853:\n");
  if (t3 == 0)
    goto g6844;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg4 - (s32)arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Pop/No-pop */
  iSP = (t7 * 8) + iSP;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if the test succeeds */
  if (t2 == 0)
    t11 = t12;
  *(u64 *)iSP = t11;
  goto cachevalid;

g6850:
  if (_trace) printf("g6850:\n");

g6849:
  if (_trace) printf("g6849:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;

g6862:
  if (_trace) printf("g6862:\n");
  if (t6 == 0)
    goto g6854;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;

g6858:
  if (_trace) printf("g6858:\n");
  if (t3 == 0)
    goto g6844;
  /* Here if argument TypeSingleFloat */

equalnumbermmexcfltflt:
  if (_trace) printf("equalnumbermmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) == FLTU64(2,f2) ? 2.0:0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iSP = (t7 * 8) + iSP;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)iSP = t12;
  if (FLTU64(3, f3) != 0.0)
    goto cachevalid;
  /* Didn't branch, answer is NIL */
  *(u64 *)iSP = t11;
  goto cachevalid;

g6855:
  if (_trace) printf("g6855:\n");

g6854:
  if (_trace) printf("g6854:\n");
  /* Here for all other cases */

g6844:
  if (_trace) printf("g6844:\n");
  goto equalnumbermmexc;

g6848:
  if (_trace) printf("g6848:\n");
#ifdef TRACING
  goto DoEqualNumberIM;
#endif

DoEqualNumberIM:
  if (_trace) printf("DoEqualNumberIM:\n");
  t11 = *(u64 *)&(processor->niladdress);
  /* First half of sign extension */
  arg2 = arg2 << 56;
  t12 = *(u64 *)&(processor->taddress);
  t7 = arg3 >> 12;
  arg3 = (u32)(arg6 >> ((4&7)*8));
  arg4 = (s32)arg6;
  /* Second half of sign extension */
  arg2 = (s64)arg2 >> 56;
  t7 = t7 & 1;
  /* Strip off any CDR code bits. */
  t3 = arg3 & 63;
  t4 = (t3 == Type_Fixnum) ? 1 : 0;

g6867:
  if (_trace) printf("g6867:\n");
  if (t4 == 0)
    goto g6864;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg4 - (s32)arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iSP = (t7 * 8) + iSP;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if the test succeeds */
  if (t2 == 0)
    t11 = t12;
  *(u64 *)iSP = t11;
  goto cachevalid;

g6864:
  if (_trace) printf("g6864:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

g6863:
  if (_trace) printf("g6863:\n");

/* end DoEqualNumber */
  /* End of Halfword operand from stack instruction - DoEqualNumber */
/* start DoSetToCdrPushCar */

  /* Halfword operand from stack instruction - DoSetToCdrPushCar */
  /* arg2 has the preloaded 8 bit operand. */

dosettocdrpushcar:
  if (_trace) printf("dosettocdrpushcar:\n");
#ifdef TRACING
#endif

DoSetToCdrPushCarSP:
  if (_trace) printf("DoSetToCdrPushCarSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindosettocdrpushcar;
#endif

DoSetToCdrPushCarLP:
  if (_trace) printf("DoSetToCdrPushCarLP:\n");
#ifdef TRACING
  goto begindosettocdrpushcar;
#endif

DoSetToCdrPushCarFP:
  if (_trace) printf("DoSetToCdrPushCarFP:\n");

begindosettocdrpushcar:
  if (_trace) printf("begindosettocdrpushcar:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Get the operand from the stack. */
  t2 = *(s32 *)arg1;
  t1 = *(s32 *)(arg1 + 4);
  t2 = (u32)t2;
  /* Save the old CDR code */
  t3 = t1 & 192;
  t5 = t1 - Type_Locative;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 == 0)
    goto settocdrpushcarlocative;
  r0 = (u64)&&return0030;
  goto carcdrinternal;
return0030:
  /* TagType. */
  arg5 = arg5 & 63;
  /* Put back the original CDR codes */
  arg5 = arg5 | t3;
  *(u32 *)arg1 = arg6;
  /* write the stack cache */
  *(u32 *)(arg1 + 4) = arg5;
  /* set CDR-NEXT */
  t5 = t1 & 63;
  *(u32 *)(iSP + 8) = t2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t5;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;
#ifdef TRACING
#endif

DoSetToCdrPushCarIM:
  goto doistageerror;

/* end DoSetToCdrPushCar */
  /* End of Halfword operand from stack instruction - DoSetToCdrPushCar */
/* start DoSub */

  /* Halfword operand from stack instruction - DoSub */
  /* arg2 has the preloaded 8 bit operand. */

dosub:
  if (_trace) printf("dosub:\n");
#ifdef TRACING
#endif

DoSubSP:
  if (_trace) printf("DoSubSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindosub;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindosub;
#endif

DoSubLP:
  if (_trace) printf("DoSubLP:\n");
#ifdef TRACING
  goto begindosub;
#endif

DoSubFP:
  if (_trace) printf("DoSubFP:\n");

begindosub:
  if (_trace) printf("begindosub:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* NIL */
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g6907:
  if (_trace) printf("g6907:\n");
  if (t10 == 0)
    goto g6878;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6884:
  if (_trace) printf("g6884:\n");
  if (t12 == 0)
    goto g6880;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 64-bit result */
//  t5 = (s64)((s32)t2 - (s64)(s32)t4); /* subl/v */
  /* x86_64 replacement for subl/v */
    asm("movl %k2,%k0 \n\t"
	"subl %k3,%k0 \n\t"
	"seto %b1"
        : "=r"(t5),"=rm"(oflo)
        : "rm"(t2),"rm"(t4)
        : "cc");
//  if (t5 >> 32)
//    exception();
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  CHECK_OFLO(); /* check overflow */
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;

g6880:
  if (_trace) printf("g6880:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g6885:
  if (_trace) printf("g6885:\n");
  if (t12 == 0)
    goto g6881;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g6868;

g6881:
  if (_trace) printf("g6881:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g6886:
  if (_trace) printf("g6886:\n");
  if (t12 == 0)
    goto g6875;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g6871;

g6879:
  if (_trace) printf("g6879:\n");

g6878:
  if (_trace) printf("g6878:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g6908:
  if (_trace) printf("g6908:\n");
  if (t10 == 0)
    goto g6887;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g6893:
  if (_trace) printf("g6893:\n");
  if (t12 == 0)
    goto g6889;
  /* Here if argument TypeSingleFloat */

g6868:
  if (_trace) printf("g6868:\n");
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto cachevalid;

g6889:
  if (_trace) printf("g6889:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6894:
  if (_trace) printf("g6894:\n");
  if (t12 == 0)
    goto g6890;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g6868;

g6890:
  if (_trace) printf("g6890:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g6895:
  if (_trace) printf("g6895:\n");
  if (t12 == 0)
    goto g6875;
  /* Here if argument TypeDoubleFloat */

g6871:
  if (_trace) printf("g6871:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g6872;

g6888:
  if (_trace) printf("g6888:\n");

g6887:
  if (_trace) printf("g6887:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g6909:
  if (_trace) printf("g6909:\n");
  if (t10 == 0)
    goto g6896;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g6902:
  if (_trace) printf("g6902:\n");
  if (t12 == 0)
    goto g6898;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0031;
  goto fetchdoublefloat;
return0031:
  LDT(1, f1, processor->fp0);

g6872:
  if (_trace) printf("g6872:\n");
  arg2 = (u32)t4;
  r0 = (u64)&&return0032;
  goto fetchdoublefloat;
return0032:
  LDT(2, f2, processor->fp0);

g6869:
  if (_trace) printf("g6869:\n");
  SUBT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0033;
  goto consdoublefloat;
return0033:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;

g6898:
  if (_trace) printf("g6898:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g6903:
  if (_trace) printf("g6903:\n");
  if (t12 == 0)
    goto g6899;
  /* Here if argument TypeSingleFloat */

g6870:
  if (_trace) printf("g6870:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0034;
  goto fetchdoublefloat;
return0034:
  LDT(1, f1, processor->fp0);
  goto g6869;

g6899:
  if (_trace) printf("g6899:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6904:
  if (_trace) printf("g6904:\n");
  if (t12 == 0)
    goto g6875;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g6870;

g6897:
  if (_trace) printf("g6897:\n");

g6896:
  if (_trace) printf("g6896:\n");
  /* Here for all other cases */

g6874:
  if (_trace) printf("g6874:\n");

dosubovfl:
  if (_trace) printf("dosubovfl:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g6876;

g6875:
  if (_trace) printf("g6875:\n");
  t1 = t3;
  goto dosubovfl;

g6876:
  if (_trace) printf("g6876:\n");

g6877:
  if (_trace) printf("g6877:\n");
#ifdef TRACING
  goto DoSubIM;
#endif

DoSubIM:
  if (_trace) printf("DoSubIM:\n");
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* get ARG1 tag/data */
  t2 = (s32)arg6;
  /* Strip off any CDR code bits. */
  t11 = t1 & 63;
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g6914:
  if (_trace) printf("g6914:\n");
  if (t12 == 0)
    goto g6911;
  /* Here if argument TypeFixnum */
  /* compute 64-bit result */
  t3 = t2 - arg2;
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 32-bit sign-extended result */
  t10 = (s32)t3;
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* is it the same as the 64-bit result? */
  t10 = (t3 == t10) ? 1 : 0;
  /* if not, we overflowed */
  if (t10 == 0)
    goto dosubovfl;
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;

g6911:
  if (_trace) printf("g6911:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  arg2 = zero;
  goto begindosub;

g6910:
  if (_trace) printf("g6910:\n");

/* end DoSub */
  /* End of Halfword operand from stack instruction - DoSub */
/* start DoTag */

  /* Halfword operand from stack instruction - DoTag */
  /* arg2 has the preloaded 8 bit operand. */

dotag:
  if (_trace) printf("dotag:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTagIM:
  if (_trace) printf("DoTagIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  arg2 = zero;
  goto begindotag;
#ifdef TRACING
#endif

DoTagSP:
  if (_trace) printf("DoTagSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindotag;
#endif

DoTagLP:
  if (_trace) printf("DoTagLP:\n");
#ifdef TRACING
  goto begindotag;
#endif

DoTagFP:
  if (_trace) printf("DoTagFP:\n");

begindotag:
  if (_trace) printf("begindotag:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Get the tag of the operand */
  arg1 = *(s32 *)(arg1 + 4);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t3 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t3;
  *(u32 *)(iSP + 8) = arg1;
  iSP = iSP + 8;
  goto cachevalid;

/* end DoTag */
  /* End of Halfword operand from stack instruction - DoTag */
/* start DoEndp */

  /* Halfword operand from stack instruction - DoEndp */
  /* arg2 has the preloaded 8 bit operand. */

doendp:
  if (_trace) printf("doendp:\n");
#ifdef TRACING
#endif

DoEndpSP:
  if (_trace) printf("DoEndpSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoendp;
#endif

DoEndpLP:
  if (_trace) printf("DoEndpLP:\n");
#ifdef TRACING
  goto begindoendp;
#endif

DoEndpFP:
  if (_trace) printf("DoEndpFP:\n");

begindoendp:
  if (_trace) printf("begindoendp:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t1 = *(u64 *)&(processor->niladdress);
  /* Get tag. */
  arg2 = *(s32 *)(arg1 + 4);
  t2 = *(u64 *)&(processor->taddress);
  /* TagType. */
  arg2 = arg2 & 63;
  /* Compare */
  t6 = arg2 - Type_NIL;
  if (t6 != 0)
    goto endpnotnil;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)(iSP + 8) = t2;
  iSP = iSP + 8;
  goto cachevalid;

endpnil:
  if (_trace) printf("endpnil:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)(iSP + 8) = t1;
  iSP = iSP + 8;
  goto cachevalid;

endpnotnil:
  if (_trace) printf("endpnotnil:\n");
  /* Now check for list */
  t6 = t6 - 1;
  if (t6 == 0)
    goto endpnil;
  t6 = arg2 - Type_ListInstance;
  if (t6 == 0)
    goto endpnil;
#ifdef TRACING
  goto DoEndpIM;
#endif

DoEndpIM:
  if (_trace) printf("DoEndpIM:\n");
  arg5 = 0;
  arg2 = 64;
  goto illegaloperand;

/* end DoEndp */
  /* End of Halfword operand from stack instruction - DoEndp */
/* start DoMinusp */

  /* Halfword operand from stack instruction - DoMinusp */
  /* arg2 has the preloaded 8 bit operand. */

dominusp:
  if (_trace) printf("dominusp:\n");
#ifdef TRACING
#endif

DoMinuspSP:
  if (_trace) printf("DoMinuspSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindominusp;
#endif

DoMinuspLP:
  if (_trace) printf("DoMinuspLP:\n");
#ifdef TRACING
  goto begindominusp;
#endif

DoMinuspFP:
  if (_trace) printf("DoMinuspFP:\n");

begindominusp:
  if (_trace) printf("begindominusp:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->niladdress);
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t1 = *(s32 *)(arg1 + 4);
  t12 = *(u64 *)&(processor->taddress);
  t2 = *(s32 *)arg1;
  LDS(1, f1, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t4 = t1 & 63;
  t5 = (t4 == Type_Fixnum) ? 1 : 0;

g6920:
  if (_trace) printf("g6920:\n");
  if (t5 == 0)
    goto g6916;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if predicate succeeds */
  if ((s64)t2 < 0)
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;
  iSP = iSP + 8;
  goto cachevalid;

g6916:
  if (_trace) printf("g6916:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;

g6921:
  if (_trace) printf("g6921:\n");
  if (t5 == 0)
    goto g6917;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  if (FLTU64(1, f1) < 0.0)
    goto cachevalid;
  /* Didn't branch, answer is NIL */
  *(u64 *)iSP = t11;
  goto cachevalid;

g6917:
  if (_trace) printf("g6917:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto unarynumericexception;

g6915:
  if (_trace) printf("g6915:\n");
#ifdef TRACING
  goto DoMinuspIM;
#endif

DoMinuspIM:
  if (_trace) printf("DoMinuspIM:\n");
  t1 = *(u64 *)&(processor->niladdress);
  /* Turned into a signed number */
  arg2 = arg2 << 56;
  t2 = *(u64 *)&(processor->taddress);
  iSP = iSP + 8;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* stall 2 then di */
  if ((s64)arg2 < 0)
    t1 = t2;
  /* yes Virginia, we dual issue with above yahoo */
  *(u64 *)iSP = t1;
  goto cachevalid;

/* end DoMinusp */
  /* End of Halfword operand from stack instruction - DoMinusp */
/* start DoPlusp */

  /* Halfword operand from stack instruction - DoPlusp */
  /* arg2 has the preloaded 8 bit operand. */

doplusp:
  if (_trace) printf("doplusp:\n");
#ifdef TRACING
#endif

DoPluspSP:
  if (_trace) printf("DoPluspSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoplusp;
#endif

DoPluspLP:
  if (_trace) printf("DoPluspLP:\n");
#ifdef TRACING
  goto begindoplusp;
#endif

DoPluspFP:
  if (_trace) printf("DoPluspFP:\n");

begindoplusp:
  if (_trace) printf("begindoplusp:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->niladdress);
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t1 = *(s32 *)(arg1 + 4);
  t12 = *(u64 *)&(processor->taddress);
  t2 = *(s32 *)arg1;
  LDS(1, f1, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t4 = t1 & 63;
  t5 = (t4 == Type_Fixnum) ? 1 : 0;

g6927:
  if (_trace) printf("g6927:\n");
  if (t5 == 0)
    goto g6923;
  /* Here if argument TypeFixnum */
  iPC = t6;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if predicate succeeds */
  if ((s64)t2 > 0)
    t11 = t12;
  *(u64 *)(iSP + 8) = t11;
  iSP = iSP + 8;
  goto cachevalid;

g6923:
  if (_trace) printf("g6923:\n");
  t5 = (t4 == Type_SingleFloat) ? 1 : 0;

g6928:
  if (_trace) printf("g6928:\n");
  if (t5 == 0)
    goto g6924;
  /* Here if argument TypeSingleFloat */
  iPC = t6;
  *(u64 *)(iSP + 8) = t12;
  iSP = iSP + 8;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  if (FLTU64(1, f1) > 0.0)
    goto cachevalid;
  /* Didn't branch, answer is NIL */
  *(u64 *)iSP = t11;
  goto cachevalid;

g6924:
  if (_trace) printf("g6924:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto unarynumericexception;

g6922:
  if (_trace) printf("g6922:\n");
#ifdef TRACING
  goto DoPluspIM;
#endif

DoPluspIM:
  if (_trace) printf("DoPluspIM:\n");
  t1 = *(u64 *)&(processor->niladdress);
  /* Turned into a signed number */
  arg2 = arg2 << 56;
  t2 = *(u64 *)&(processor->taddress);
  iSP = iSP + 8;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* stall 2 then di */
  if ((s64)arg2 > 0)
    t1 = t2;
  /* yes Virginia, we dual issue with above yahoo */
  *(u64 *)iSP = t1;
  goto cachevalid;

/* end DoPlusp */
  /* End of Halfword operand from stack instruction - DoPlusp */
/* start DoLessp */

  /* Halfword operand from stack instruction - DoLessp */
  /* arg2 has the preloaded 8 bit operand. */

dolessp:
  if (_trace) printf("dolessp:\n");
#ifdef TRACING
#endif

DoLesspSP:
  if (_trace) printf("DoLesspSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindolessp;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindolessp;
#endif

DoLesspLP:
  if (_trace) printf("DoLesspLP:\n");
#ifdef TRACING
  goto begindolessp;
#endif

DoLesspFP:
  if (_trace) printf("DoLesspFP:\n");

begindolessp:
  if (_trace) printf("begindolessp:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t11 = *(u64 *)&(processor->niladdress);
  t7 = arg3 >> 12;
  t12 = *(u64 *)&(processor->taddress);
  /* Get ARG1 tag */
  arg3 = (u32)(arg6 >> ((4&7)*8));
  /* t1 is tag of arg2 */
  t1 = *(s32 *)(arg1 + 4);
  LDS(1, f1, *(u32 *)iSP );
  t7 = t7 & 1;
  arg2 = *(s32 *)arg1;
  arg4 = (s32)arg6;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t5 = arg3 & 63;
  /* Strip off any CDR code bits. */
  t4 = t1 & 63;
  t6 = (t5 == Type_Fixnum) ? 1 : 0;

g6946:
  if (_trace) printf("g6946:\n");
  if (t6 == 0)
    goto g6934;
  /* Here if argument TypeFixnum */
  t3 = (t4 == Type_Fixnum) ? 1 : 0;

g6938:
  if (_trace) printf("g6938:\n");
  if (t3 == 0)
    goto g6929;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* Pop/No-pop */
  iSP = (t7 * 8) + iSP;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if the test succeeds */
  if ((s64)t2 < 0)
    t11 = t12;
  *(u64 *)iSP = t11;
  goto cachevalid;

g6935:
  if (_trace) printf("g6935:\n");

g6934:
  if (_trace) printf("g6934:\n");
  t6 = (t5 == Type_SingleFloat) ? 1 : 0;

g6947:
  if (_trace) printf("g6947:\n");
  if (t6 == 0)
    goto g6939;
  /* Here if argument TypeSingleFloat */
  t3 = (t4 == Type_SingleFloat) ? 1 : 0;

g6943:
  if (_trace) printf("g6943:\n");
  if (t3 == 0)
    goto g6929;
  /* Here if argument TypeSingleFloat */

lesspmmexcfltflt:
  if (_trace) printf("lesspmmexcfltflt:\n");
  SETFLTT(3,f3, FLTU64(1,f1) < FLTU64(2,f2) ? 2.0:0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iSP = (t7 * 8) + iSP;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u64 *)iSP = t12;
  if (FLTU64(3, f3) != 0.0)
    goto cachevalid;
  /* Didn't branch, answer is NIL */
  *(u64 *)iSP = t11;
  goto cachevalid;

g6940:
  if (_trace) printf("g6940:\n");

g6939:
  if (_trace) printf("g6939:\n");
  /* Here for all other cases */

g6929:
  if (_trace) printf("g6929:\n");
  goto lesspmmexc;

g6933:
  if (_trace) printf("g6933:\n");
#ifdef TRACING
  goto DoLesspIM;
#endif

DoLesspIM:
  if (_trace) printf("DoLesspIM:\n");
  t11 = *(u64 *)&(processor->niladdress);
  /* First half of sign extension */
  arg2 = arg2 << 56;
  t12 = *(u64 *)&(processor->taddress);
  t7 = arg3 >> 12;
  arg3 = (u32)(arg6 >> ((4&7)*8));
  arg4 = (s32)arg6;
  /* Second half of sign extension */
  arg2 = (s64)arg2 >> 56;
  t7 = t7 & 1;
  /* Strip off any CDR code bits. */
  t3 = arg3 & 63;
  t4 = (t3 == Type_Fixnum) ? 1 : 0;

g6952:
  if (_trace) printf("g6952:\n");
  if (t4 == 0)
    goto g6949;
  /* Here if argument TypeFixnum */
  t2 = arg4 - arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iSP = (t7 * 8) + iSP;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* T if the test succeeds */
  if ((s64)t2 < 0)
    t11 = t12;
  *(u64 *)iSP = t11;
  goto cachevalid;

g6949:
  if (_trace) printf("g6949:\n");
  /* Here for all other cases */
  /* arg6 = tag to dispatch on */
  arg6 = arg3;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;

g6948:
  if (_trace) printf("g6948:\n");

/* end DoLessp */
  /* End of Halfword operand from stack instruction - DoLessp */
/* start DoDecrement */

  /* Halfword operand from stack instruction - DoDecrement */
  /* arg2 has the preloaded 8 bit operand. */

dodecrement:
  if (_trace) printf("dodecrement:\n");
#ifdef TRACING
#endif

DoDecrementSP:
  if (_trace) printf("DoDecrementSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindodecrement;
#endif

DoDecrementLP:
  if (_trace) printf("DoDecrementLP:\n");
#ifdef TRACING
  goto begindodecrement;
#endif

DoDecrementFP:
  if (_trace) printf("DoDecrementFP:\n");

begindodecrement:
  if (_trace) printf("begindodecrement:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* read tag/data of arg1 */
  arg3 = *(s32 *)arg1;
  arg2 = *(s32 *)(arg1 + 4);
  arg3 = (u32)arg3;
  /* Strip off any CDR code bits. */
  t1 = arg2 & 63;
  t2 = (t1 == Type_Fixnum) ? 1 : 0;

g6958:
  if (_trace) printf("g6958:\n");
  if (t2 == 0)
    goto g6954;
  /* Here if argument TypeFixnum */
  t2 = *(u64 *)&(processor->mostnegativefixnum);
  t3 = arg3 - 1;
  t2 = (arg3 == t2) ? 1 : 0;
  if (t2 != 0)
    goto decrementexception;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)arg1 = t3;
  /* write the stack cache */
  *(u32 *)(arg1 + 4) = arg2;
  goto cachevalid;

g6954:
  if (_trace) printf("g6954:\n");
  t2 = (t1 == Type_SingleFloat) ? 1 : 0;

g6959:
  if (_trace) printf("g6959:\n");
  if (t2 == 0)
    goto g6955;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  /* Get the floating data */
  LDS(1, f1, *(u32 *)arg1 );
  /* constant 1.0 */
  LDS(2, f2, processor->sfp1);
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Put the floating result */
  STS( (u32 *)arg1, 0, f0 );
  goto cachevalid;

g6955:
  if (_trace) printf("g6955:\n");
  /* Here for all other cases */
  goto decrementexception;

g6953:
  if (_trace) printf("g6953:\n");
#ifdef TRACING
#endif

DoDecrementIM:
  goto doistageerror;

/* end DoDecrement */
  /* End of Halfword operand from stack instruction - DoDecrement */
/* start DoMergeCdrNoPop */

  /* Halfword operand from stack instruction - DoMergeCdrNoPop */
  /* arg2 has the preloaded 8 bit operand. */

domergecdrnopop:
  if (_trace) printf("domergecdrnopop:\n");
#ifdef TRACING
#endif

DoMergeCdrNoPopSP:
  if (_trace) printf("DoMergeCdrNoPopSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomergecdrnopop;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomergecdrnopop;
#endif

DoMergeCdrNoPopLP:
  if (_trace) printf("DoMergeCdrNoPopLP:\n");
#ifdef TRACING
  goto begindomergecdrnopop;
#endif

DoMergeCdrNoPopFP:
  if (_trace) printf("DoMergeCdrNoPopFP:\n");

begindomergecdrnopop:
  if (_trace) printf("begindomergecdrnopop:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Get the CDR CODE/TAG of arg2 */
  t1 = *(s32 *)(arg1 + 4);
  /* Get the CDR CODE/TAG of arg1 */
  t2 = (u32)(arg6 >> ((4&7)*8));

g6960:
  if (_trace) printf("g6960:\n");
  /* Get Just the CDR code in position */
  t2 = t2 & 192;
  /* Get the TAG of arg1 */
  t1 = t1 & 63;
  /* Merge the tag of arg2 with the cdr code of arg1 */
  t3 = t1 | t2;
  /* Replace tag/cdr code no pop */
  *(u32 *)(arg1 + 4) = t3;
  goto cachevalid;
#ifdef TRACING
#endif

DoMergeCdrNoPopIM:
  goto doistageerror;

/* end DoMergeCdrNoPop */
  /* End of Halfword operand from stack instruction - DoMergeCdrNoPop */
/* start DoEqImmediateHandler */


doeqimmediatehandler:
  if (_trace) printf("doeqimmediatehandler:\n");
#ifdef TRACING
  goto DoEqIM;
#endif

DoEqIM:
  if (_trace) printf("DoEqIM:\n");
  arg2 = arg2 << 56;
  /* t4=tag t3=data */
  t4 = *(s32 *)(iSP + 4);
  t3 = *(s32 *)iSP;
  arg3 = arg3 >> 12;
  t11 = *(u64 *)&(processor->niladdress);
  /* Sign extension of arg2 is complete */
  arg2 = (s64)arg2 >> 56;
  /* TagType. */
  t4 = t4 & 63;
  t12 = *(u64 *)&(processor->taddress);
  /* 1 if no-pop, 0 if pop */
  arg3 = arg3 & 1;
  arg2 = (s32)t3 - (s32)arg2;
  t4 = t4 ^ Type_Fixnum;
  /* Either a stack-push or a stack-write */
  iSP = (arg3 * 8) + iSP;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t4 = arg2 | t4;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  if (t4 == 0)
    t11 = t12;
  /* Yes Virginia, this does dual issue with above */
  *(u64 *)iSP = t11;
  goto cachevalid;

/* end DoEqImmediateHandler */
/* start DoIncrement */

  /* Halfword operand from stack instruction - DoIncrement */
  /* arg2 has the preloaded 8 bit operand. */

doincrement:
  if (_trace) printf("doincrement:\n");
#ifdef TRACING
#endif

DoIncrementSP:
  if (_trace) printf("DoIncrementSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindoincrement;
#endif

DoIncrementLP:
  if (_trace) printf("DoIncrementLP:\n");
#ifdef TRACING
  goto begindoincrement;
#endif

DoIncrementFP:
  if (_trace) printf("DoIncrementFP:\n");

begindoincrement:
  if (_trace) printf("begindoincrement:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* read tag/data of arg1 */
  arg3 = *(s32 *)arg1;
  arg2 = *(s32 *)(arg1 + 4);
  arg3 = (u32)arg3;
  /* Strip off any CDR code bits. */
  t1 = arg2 & 63;
  t2 = (t1 == Type_Fixnum) ? 1 : 0;

g6966:
  if (_trace) printf("g6966:\n");
  if (t2 == 0)
    goto g6962;
  /* Here if argument TypeFixnum */
  t2 = *(u64 *)&(processor->mostpositivefixnum);
  t3 = arg3 + 1;
  t2 = (arg3 == t2) ? 1 : 0;
  if (t2 != 0)
    goto incrementexception;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)arg1 = t3;
  /* write the stack cache */
  *(u32 *)(arg1 + 4) = arg2;
  goto cachevalid;

g6962:
  if (_trace) printf("g6962:\n");
  t2 = (t1 == Type_SingleFloat) ? 1 : 0;

g6967:
  if (_trace) printf("g6967:\n");
  if (t2 == 0)
    goto g6963;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  /* Get the floating data */
  LDS(1, f1, *(u32 *)arg1 );
  /* constant 1.0 */
  LDS(2, f2, processor->sfp1);
  ADDS(0, f0, 1, f1, 2, f2); /* adds */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Put the floating result */
  STS( (u32 *)arg1, 0, f0 );
  goto cachevalid;

g6963:
  if (_trace) printf("g6963:\n");
  /* Here for all other cases */
  goto incrementexception;

g6961:
  if (_trace) printf("g6961:\n");
#ifdef TRACING
#endif

DoIncrementIM:
  goto doistageerror;

/* end DoIncrement */
  /* End of Halfword operand from stack instruction - DoIncrement */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuncom2.as */
