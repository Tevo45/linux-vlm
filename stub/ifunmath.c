/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunmath.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Arithmetic. */
/* start DoUnaryMinus */

  /* Halfword operand from stack instruction - DoUnaryMinus */
  /* arg2 has the preloaded 8 bit operand. */

dounaryminus:
  if (_trace) printf("dounaryminus:\n");
#ifdef TRACING
#endif

DoUnaryMinusSP:
  if (_trace) printf("DoUnaryMinusSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto begindounaryminus;
#endif

DoUnaryMinusLP:
  if (_trace) printf("DoUnaryMinusLP:\n");
#ifdef TRACING
  goto begindounaryminus;
#endif

DoUnaryMinusFP:
  if (_trace) printf("DoUnaryMinusFP:\n");

begindounaryminus:
  if (_trace) printf("begindounaryminus:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* tag of ARG2 */
  arg5 = *(s32 *)(arg1 + 4);
  arg6 = *(s32 *)arg1;
  t2 = *(u64 *)&(processor->mostnegativefixnum);
  LDS(1, f1, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t5 = arg5 & 63;
  t4 = (t5 == Type_Fixnum) ? 1 : 0;

g7492:
  if (_trace) printf("g7492:\n");
  if (t4 == 0)
    goto g7488;
  /* Here if argument TypeFixnum */
  t2 = (s32)arg6 - (s32)t2;
  arg2 = (s32)zero - (s32)arg6;
  if (t2 == 0)
    goto unaryminusexc;
  iPC = t6;
  /* Semi-cheat, we know t5 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  /* Push the data */
  *(u32 *)(iSP + 8) = arg2;
  iSP = iSP + 8;
  goto cachevalid;

g7488:
  if (_trace) printf("g7488:\n");
  t4 = (t5 == Type_SingleFloat) ? 1 : 0;

g7493:
  if (_trace) printf("g7493:\n");
  if (t4 == 0)
    goto g7489;
  /* Here if argument TypeSingleFloat */
  /* NIL */
  SUBS(0, f0, 3, f31, 1, f1); /* subs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = t6;
  /* Semi-cheat, we know t5 has CDRNext/TypeSingleFloat */
  *(u32 *)(iSP + 12) = t5;
  iCP = t7;
  /* Push the data */
  STS( (u32 *)(iSP + 8), 0, f0 );
  iSP = iSP + 8;
  goto cachevalid;

g7489:
  if (_trace) printf("g7489:\n");
  /* Here for all other cases */

unaryminusexc:
  if (_trace) printf("unaryminusexc:\n");
  /* arg6 = tag to dispatch on */
  arg6 = arg5;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto unarynumericexception;

g7487:
  if (_trace) printf("g7487:\n");
#ifdef TRACING
  goto DoUnaryMinusIM;
#endif

DoUnaryMinusIM:
  if (_trace) printf("DoUnaryMinusIM:\n");
  /* Negate the 8 bit immediate operand */
  arg2 = (s32)zero - (s32)arg2;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t7 = Type_Fixnum;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

/* end DoUnaryMinus */
  /* End of Halfword operand from stack instruction - DoUnaryMinus */
/* start DoMultiply */

  /* Halfword operand from stack instruction - DoMultiply */
  /* arg2 has the preloaded 8 bit operand. */

domultiply:
  if (_trace) printf("domultiply:\n");
#ifdef TRACING
#endif

DoMultiplySP:
  if (_trace) printf("DoMultiplySP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomultiply;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomultiply;
#endif

DoMultiplyLP:
  if (_trace) printf("DoMultiplyLP:\n");
#ifdef TRACING
  goto begindomultiply;
#endif

DoMultiplyFP:
  if (_trace) printf("DoMultiplyFP:\n");

begindomultiply:
  if (_trace) printf("begindomultiply:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* NIL */
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7533:
  if (_trace) printf("g7533:\n");
  if (t10 == 0)
    goto g7504;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7510:
  if (_trace) printf("g7510:\n");
  if (t12 == 0)
    goto g7506;
  /* Here if argument TypeFixnum */
  t6 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 64-bit result */
//  t5 = (s64)((s32)t2 * (s64)(s32)t4); /* mull/v */
  /* x86_64 replacement for mull/v */
    asm("movl %k2,%k0 \n\t"
	"imull %k3,%k0 \n\t"
	"seto %b1"
        : "=r"(t5),"=rm"(oflo)
        : "rm"(t2),"rm"(t4)
        : "cc");
//  if (t5 >> 32)
//    exception();
  t7 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  CHECK_OFLO(); /* check overflow */
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t9;
  iPC = t6;
  *(u32 *)iSP = t5;
  iCP = t7;
  goto cachevalid;

g7506:
  if (_trace) printf("g7506:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7511:
  if (_trace) printf("g7511:\n");
  if (t12 == 0)
    goto g7507;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7494;

g7507:
  if (_trace) printf("g7507:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7512:
  if (_trace) printf("g7512:\n");
  if (t12 == 0)
    goto g7501;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7497;

g7505:
  if (_trace) printf("g7505:\n");

g7504:
  if (_trace) printf("g7504:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7534:
  if (_trace) printf("g7534:\n");
  if (t10 == 0)
    goto g7513;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7519:
  if (_trace) printf("g7519:\n");
  if (t12 == 0)
    goto g7515;
  /* Here if argument TypeSingleFloat */

g7494:
  if (_trace) printf("g7494:\n");
  MULS(0, f0, 1, f1, 2, f2); /* muls */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto cachevalid;

g7515:
  if (_trace) printf("g7515:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7520:
  if (_trace) printf("g7520:\n");
  if (t12 == 0)
    goto g7516;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7494;

g7516:
  if (_trace) printf("g7516:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7521:
  if (_trace) printf("g7521:\n");
  if (t12 == 0)
    goto g7501;
  /* Here if argument TypeDoubleFloat */

g7497:
  if (_trace) printf("g7497:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g7498;

g7514:
  if (_trace) printf("g7514:\n");

g7513:
  if (_trace) printf("g7513:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g7535:
  if (_trace) printf("g7535:\n");
  if (t10 == 0)
    goto g7522;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7528:
  if (_trace) printf("g7528:\n");
  if (t12 == 0)
    goto g7524;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0049;
  goto fetchdoublefloat;
return0049:
  LDT(1, f1, processor->fp0);

g7498:
  if (_trace) printf("g7498:\n");
  arg2 = (u32)t4;
  r0 = (u64)&&return0050;
  goto fetchdoublefloat;
return0050:
  LDT(2, f2, processor->fp0);

g7495:
  if (_trace) printf("g7495:\n");
  MULT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0051;
  goto consdoublefloat;
return0051:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto cachevalid;

g7524:
  if (_trace) printf("g7524:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7529:
  if (_trace) printf("g7529:\n");
  if (t12 == 0)
    goto g7525;
  /* Here if argument TypeSingleFloat */

g7496:
  if (_trace) printf("g7496:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  r0 = (u64)&&return0052;
  goto fetchdoublefloat;
return0052:
  LDT(1, f1, processor->fp0);
  goto g7495;

g7525:
  if (_trace) printf("g7525:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7530:
  if (_trace) printf("g7530:\n");
  if (t12 == 0)
    goto g7501;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7496;

g7523:
  if (_trace) printf("g7523:\n");

g7522:
  if (_trace) printf("g7522:\n");
  /* Here for all other cases */

g7500:
  if (_trace) printf("g7500:\n");

domulovfl:
  if (_trace) printf("domulovfl:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7502;

g7501:
  if (_trace) printf("g7501:\n");
  t1 = t3;
  goto domulovfl;

g7502:
  if (_trace) printf("g7502:\n");

g7503:
  if (_trace) printf("g7503:\n");
#ifdef TRACING
  goto DoMultiplyIM;
#endif

DoMultiplyIM:
  if (_trace) printf("DoMultiplyIM:\n");
  arg2 = arg2 << 56;
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* get ARG1 tag/data */
  t2 = (s32)arg6;
  arg2 = (s64)arg2 >> 56;
  /* Strip off any CDR code bits. */
  t11 = t1 & 63;
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7540:
  if (_trace) printf("g7540:\n");
  if (t12 == 0)
    goto g7537;
  /* Here if argument TypeFixnum */
  /* compute 64-bit result */
  t3 = t2 * arg2;
  t4 = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  /* compute 32-bit sign-extended result */
  t10 = (s32)t3;
  t5 = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* is it the same as the 64-bit result? */
  t10 = (t3 == t10) ? 1 : 0;
  /* if not, we overflowed */
  if (t10 == 0)
    goto domulovfl;
  /* Semi-cheat, we know temp2 has CDRNext/TypeFixnum */
  *(u32 *)(iSP + 4) = t11;
  iPC = t4;
  *(u32 *)iSP = t3;
  iCP = t5;
  goto cachevalid;

g7537:
  if (_trace) printf("g7537:\n");
  /* Here for all other cases */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = (u64)&processor->immediate_arg;
  arg2 = zero;
  goto begindomultiply;

g7536:
  if (_trace) printf("g7536:\n");

/* end DoMultiply */
  /* End of Halfword operand from stack instruction - DoMultiply */
/* start BinaryArithmeticDivisionPrelude */


binaryarithmeticdivisionprelude:
  if (_trace) printf("binaryarithmeticdivisionprelude:\n");
  sp = sp + -8;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7578:
  if (_trace) printf("g7578:\n");
  if (t10 == 0)
    goto g7551;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7557:
  if (_trace) printf("g7557:\n");
  if (t12 == 0)
    goto g7553;
  /* Here if argument TypeFixnum */
  CVTLQ(1, f1, f31, 1, f1);
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(1, f1, f31, 1, f1);
  CVTQT(2, f2, f31, 2, f2);

g7552:
  if (_trace) printf("g7552:\n");

g7550:
  if (_trace) printf("g7550:\n");

g7541:
  if (_trace) printf("g7541:\n");
  sp = sp + 8;
  goto *r0; /* ret */

g7551:
  if (_trace) printf("g7551:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7579:
  if (_trace) printf("g7579:\n");
  if (t10 == 0)
    goto g7558;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7564:
  if (_trace) printf("g7564:\n");
  if (t12 != 0)
    goto g7541;

g7560:
  if (_trace) printf("g7560:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7565:
  if (_trace) printf("g7565:\n");
  if (t12 == 0)
    goto g7561;
  /* Here if argument TypeFixnum */
  /* contagion */
  t3 = t1;
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7541;

g7561:
  if (_trace) printf("g7561:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7566:
  if (_trace) printf("g7566:\n");
  if (t12 == 0)
    goto g7548;
  /* Here if argument TypeDoubleFloat */

g7543:
  if (_trace) printf("g7543:\n");
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  goto g7544;

g7559:
  if (_trace) printf("g7559:\n");

g7558:
  if (_trace) printf("g7558:\n");
  t10 = (t9 == Type_DoubleFloat) ? 1 : 0;

g7580:
  if (_trace) printf("g7580:\n");
  if (t10 == 0)
    goto g7567;
  /* Here if argument TypeDoubleFloat */
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7573:
  if (_trace) printf("g7573:\n");
  if (t12 == 0)
    goto g7569;
  /* Here if argument TypeDoubleFloat */
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0053;
  goto fetchdoublefloat;
return0053:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);

g7544:
  if (_trace) printf("g7544:\n");
  arg2 = (u32)t4;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0054;
  goto fetchdoublefloat;
return0054:
  r0 = *(u64 *)sp;
  LDT(2, f2, processor->fp0);
  goto g7541;

g7569:
  if (_trace) printf("g7569:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7574:
  if (_trace) printf("g7574:\n");
  if (t12 == 0)
    goto g7570;
  /* Here if argument TypeSingleFloat */

g7542:
  if (_trace) printf("g7542:\n");
  /* contagion */
  t3 = t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  arg2 = (u32)t2;
  *(u64 *)sp = r0;
  r0 = (u64)&&return0055;
  goto fetchdoublefloat;
return0055:
  r0 = *(u64 *)sp;
  LDT(1, f1, processor->fp0);
  goto g7541;

g7570:
  if (_trace) printf("g7570:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7575:
  if (_trace) printf("g7575:\n");
  if (t12 == 0)
    goto g7548;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQT(2, f2, f31, 2, f2);
  goto g7542;

g7568:
  if (_trace) printf("g7568:\n");

g7567:
  if (_trace) printf("g7567:\n");
  /* Here for all other cases */

g7547:
  if (_trace) printf("g7547:\n");

g7545:
  if (_trace) printf("g7545:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7549;

g7548:
  if (_trace) printf("g7548:\n");
  t1 = t3;
  goto g7545;

g7549:
  if (_trace) printf("g7549:\n");

g7553:
  if (_trace) printf("g7553:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7581:
  if (_trace) printf("g7581:\n");
  if (t12 == 0)
    goto g7554;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7541;

g7554:
  if (_trace) printf("g7554:\n");
  t12 = (t11 == Type_DoubleFloat) ? 1 : 0;

g7582:
  if (_trace) printf("g7582:\n");
  if (t12 == 0)
    goto g7548;
  /* Here if argument TypeDoubleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQT(1, f1, f31, 1, f1);
  goto g7543;

/* end BinaryArithmeticDivisionPrelude */
/* start DoQuotient */

  /* Halfword operand from stack instruction - DoQuotient */
  /* arg2 has the preloaded 8 bit operand. */

doquotient:
  if (_trace) printf("doquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoQuotientIM:
  if (_trace) printf("DoQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoquotient;
#ifdef TRACING
#endif

DoQuotientSP:
  if (_trace) printf("DoQuotientSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoquotient;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoquotient;
#endif

DoQuotientLP:
  if (_trace) printf("DoQuotientLP:\n");
#ifdef TRACING
  goto begindoquotient;
#endif

DoQuotientFP:
  if (_trace) printf("DoQuotientFP:\n");

begindoquotient:
  if (_trace) printf("begindoquotient:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0056;
  goto binaryarithmeticdivisionprelude;
return0056:
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7588:
  if (_trace) printf("g7588:\n");
  if (t9 == 0)
    goto g7584;
  /* Here if argument TypeFixnum */
  DIVT(0, f0, 1, f1, 2, f2);
  CVTTQVC(0, f0, f31, 0, f0);
  CVTQLV(0, f0, f31, 0, f0);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );

g7583:
  if (_trace) printf("g7583:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7584:
  if (_trace) printf("g7584:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7589:
  if (_trace) printf("g7589:\n");
  if (t9 == 0)
    goto g7585;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto g7583;

g7585:
  if (_trace) printf("g7585:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7590:
  if (_trace) printf("g7590:\n");
  if (t9 == 0)
    goto g7583;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0057;
  goto consdoublefloat;
return0057:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g7583;

/* end DoQuotient */
  /* End of Halfword operand from stack instruction - DoQuotient */
/* start DoRationalQuotient */

  /* Halfword operand from stack instruction - DoRationalQuotient */
  /* arg2 has the preloaded 8 bit operand. */

dorationalquotient:
  if (_trace) printf("dorationalquotient:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRationalQuotientIM:
  if (_trace) printf("DoRationalQuotientIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindorationalquotient;
#ifdef TRACING
#endif

DoRationalQuotientSP:
  if (_trace) printf("DoRationalQuotientSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindorationalquotient;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindorationalquotient;
#endif

DoRationalQuotientLP:
  if (_trace) printf("DoRationalQuotientLP:\n");
#ifdef TRACING
  goto begindorationalquotient;
#endif

DoRationalQuotientFP:
  if (_trace) printf("DoRationalQuotientFP:\n");

begindorationalquotient:
  if (_trace) printf("begindorationalquotient:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0058;
  goto binaryarithmeticdivisionprelude;
return0058:
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7596:
  if (_trace) printf("g7596:\n");
  if (t9 == 0)
    goto g7592;
  /* Here if argument TypeFixnum */
  /* x86_64 replacement for fixnum rational quotient */
    asm("movl %k2,%%eax \n\t"       // get arg1 into res
        "cdq \n\t"                  // sign extend into edx:eax
        "idivl %k3 \n\t"            // divide by arg2
        "movl %%eax,%k0 \n\t"       // result into f0
        "movl %%edx,%k1"            // remainder into im1
        : "=mr"(f0),"=rm"(im1)      // %0;res, %1:im1
        : "rm"(t2),"rm"(t4)         // %2:t2, %3:t4
        : "rax", "rdx", "cc");      // clobbers eax, edx and cc;
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  if (im1)
    goto arithmeticexception;
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );

g7591:
  if (_trace) printf("g7591:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7592:
  if (_trace) printf("g7592:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7597:
  if (_trace) printf("g7597:\n");
  if (t9 == 0)
    goto g7593;
  /* Here if argument TypeSingleFloat */
  DIVS(0, f0, 1, f1, 2, f2); /* divs */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  goto g7591;

g7593:
  if (_trace) printf("g7593:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7598:
  if (_trace) printf("g7598:\n");
  if (t9 == 0)
    goto g7591;
  /* Here if argument TypeDoubleFloat */
  DIVT(0, f0, 1, f1, 2, f2);
  STT( (u64 *)&processor->fp0, 0, f0 );
  r0 = (u64)&&return0059;
  goto consdoublefloat;
return0059:
  t8 = Type_DoubleFloat;
  *(u32 *)iSP = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  goto g7591;

/* end DoRationalQuotient */
  /* End of Halfword operand from stack instruction - DoRationalQuotient */
/* start DoFloor */

  /* Halfword operand from stack instruction - DoFloor */
  /* arg2 has the preloaded 8 bit operand. */

dofloor:
  if (_trace) printf("dofloor:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoFloorIM:
  if (_trace) printf("DoFloorIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindofloor;
#ifdef TRACING
#endif

DoFloorSP:
  if (_trace) printf("DoFloorSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindofloor;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindofloor;
#endif

DoFloorLP:
  if (_trace) printf("DoFloorLP:\n");
#ifdef TRACING
  goto begindofloor;
#endif

DoFloorFP:
  if (_trace) printf("DoFloorFP:\n");

begindofloor:
  if (_trace) printf("begindofloor:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0060;
  goto binaryarithmeticdivisionprelude;
return0060:
  /* use libc function floor for rounding-mode :down */
  {
    extern double floor(double);
    double c = floor( FLTU64(1, f1) / FLTU64(2, f2) );
    double d = FLTU64(1, f1) - (c * FLTU64(2, f2)) ;
    LDS(0, f0, (int)c);
    LDT(3, f3, U64FLTT(d));
  }
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7604:
  if (_trace) printf("g7604:\n");
  if (t9 == 0)
    goto g7600;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7599:
  if (_trace) printf("g7599:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7600:
  if (_trace) printf("g7600:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7605:
  if (_trace) printf("g7605:\n");
  if (t9 == 0)
    goto g7601;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7599;

g7601:
  if (_trace) printf("g7601:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7606:
  if (_trace) printf("g7606:\n");
  if (t9 == 0)
    goto g7599;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0061;
  goto consdoublefloat;
return0061:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7599;

/* end DoFloor */
  /* End of Halfword operand from stack instruction - DoFloor */
/* start DoCeiling */

  /* Halfword operand from stack instruction - DoCeiling */
  /* arg2 has the preloaded 8 bit operand. */

doceiling:
  if (_trace) printf("doceiling:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoCeilingIM:
  if (_trace) printf("DoCeilingIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoceiling;
#ifdef TRACING
#endif

DoCeilingSP:
  if (_trace) printf("DoCeilingSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoceiling;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoceiling;
#endif

DoCeilingLP:
  if (_trace) printf("DoCeilingLP:\n");
#ifdef TRACING
  goto begindoceiling;
#endif

DoCeilingFP:
  if (_trace) printf("DoCeilingFP:\n");

begindoceiling:
  if (_trace) printf("begindoceiling:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0062;
  goto binaryarithmeticdivisionprelude;
return0062:
  /* use libc function ceil for rounding-mode :up */
  {
    extern double ceil(double);
    double c = ceil( FLTU64(1, f1) / FLTU64(2, f2) );
    double d = FLTU64(1, f1) - (c * FLTU64(2, f2)) ;
    LDS(0, f0, (int)c);
    LDT(3, f3, U64FLTT(d));
  }
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7612:
  if (_trace) printf("g7612:\n");
  if (t9 == 0)
    goto g7608;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7607:
  if (_trace) printf("g7607:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7608:
  if (_trace) printf("g7608:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7613:
  if (_trace) printf("g7613:\n");
  if (t9 == 0)
    goto g7609;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7607;

g7609:
  if (_trace) printf("g7609:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7614:
  if (_trace) printf("g7614:\n");
  if (t9 == 0)
    goto g7607;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0063;
  goto consdoublefloat;
return0063:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7607;

/* end DoCeiling */
  /* End of Halfword operand from stack instruction - DoCeiling */
/* start DoTruncate */

  /* Halfword operand from stack instruction - DoTruncate */
  /* arg2 has the preloaded 8 bit operand. */

dotruncate:
  if (_trace) printf("dotruncate:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoTruncateIM:
  if (_trace) printf("DoTruncateIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindotruncate;
#ifdef TRACING
#endif

DoTruncateSP:
  if (_trace) printf("DoTruncateSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindotruncate;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindotruncate;
#endif

DoTruncateLP:
  if (_trace) printf("DoTruncateLP:\n");
#ifdef TRACING
  goto begindotruncate;
#endif

DoTruncateFP:
  if (_trace) printf("DoTruncateFP:\n");

begindotruncate:
  if (_trace) printf("begindotruncate:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0064;
  goto binaryarithmeticdivisionprelude;
return0064:
  /* use libc function trunc for rounding-mode :truncate */
  {
    extern double trunc(double);
    double c = trunc( FLTU64(1, f1) / FLTU64(2, f2) );
    double d = FLTU64(1, f1) - (c * FLTU64(2, f2)) ;
    LDS(0, f0, (int)c);
    LDT(3, f3, U64FLTT(d));
  }
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7620:
  if (_trace) printf("g7620:\n");
  if (t9 == 0)
    goto g7616;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7615:
  if (_trace) printf("g7615:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7616:
  if (_trace) printf("g7616:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7621:
  if (_trace) printf("g7621:\n");
  if (t9 == 0)
    goto g7617;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7615;

g7617:
  if (_trace) printf("g7617:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7622:
  if (_trace) printf("g7622:\n");
  if (t9 == 0)
    goto g7615;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0065;
  goto consdoublefloat;
return0065:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7615;

/* end DoTruncate */
  /* End of Halfword operand from stack instruction - DoTruncate */
/* start DoRound */

  /* Halfword operand from stack instruction - DoRound */
  /* arg2 has the preloaded 8 bit operand. */

doround:
  if (_trace) printf("doround:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoRoundIM:
  if (_trace) printf("DoRoundIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindoround;
#ifdef TRACING
#endif

DoRoundSP:
  if (_trace) printf("DoRoundSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindoround;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindoround;
#endif

DoRoundLP:
  if (_trace) printf("DoRoundLP:\n");
#ifdef TRACING
  goto begindoround;
#endif

DoRoundFP:
  if (_trace) printf("DoRoundFP:\n");

begindoround:
  if (_trace) printf("begindoround:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  r0 = (u64)&&return0066;
  goto binaryarithmeticdivisionprelude;
return0066:
  /* use libc function rint for rounding-mode :round */
  {
    extern double rint(double);
    double c = rint( FLTU64(1, f1) / FLTU64(2, f2) );
    double d = FLTU64(1, f1) - (c * FLTU64(2, f2)) ;
    LDS(0, f0, (int)c);
    LDT(3, f3, U64FLTT(d));
  }
  /* Strip off any CDR code bits. */
  t8 = t3 & 63;
  t9 = (t8 == Type_Fixnum) ? 1 : 0;

g7628:
  if (_trace) printf("g7628:\n");
  if (t9 == 0)
    goto g7624;
  /* Here if argument TypeFixnum */
  CVTTQ(3, f3, f31, 3, f3);
  CVTQL(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;

g7623:
  if (_trace) printf("g7623:\n");
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  goto cachevalid;

g7624:
  if (_trace) printf("g7624:\n");
  t9 = (t8 == Type_SingleFloat) ? 1 : 0;

g7629:
  if (_trace) printf("g7629:\n");
  if (t9 == 0)
    goto g7625;
  /* Here if argument TypeSingleFloat */
  CVTTS(3, f3, f31, 3, f3);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  STS( (u32 *)(iSP + 8), 3, f3 );
  iSP = iSP + 8;
  goto g7623;

g7625:
  if (_trace) printf("g7625:\n");
  t9 = (t8 == Type_DoubleFloat) ? 1 : 0;

g7630:
  if (_trace) printf("g7630:\n");
  if (t9 == 0)
    goto g7623;
  /* Here if argument TypeDoubleFloat */
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  STT( (u64 *)&processor->fp0, 3, f3 );
  r0 = (u64)&&return0067;
  goto consdoublefloat;
return0067:
  t8 = Type_Fixnum;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 0, f0 );
  t8 = Type_DoubleFloat;
  *(u32 *)(iSP + 8) = arg2;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t8;
  iSP = iSP + 8;
  goto g7623;

/* end DoRound */
  /* End of Halfword operand from stack instruction - DoRound */
  /* Other arithmetic. */
/* start DoMax */

  /* Halfword operand from stack instruction - DoMax */
  /* arg2 has the preloaded 8 bit operand. */

domax:
  if (_trace) printf("domax:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMaxIM:
  if (_trace) printf("DoMaxIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindomax;
#ifdef TRACING
#endif

DoMaxSP:
  if (_trace) printf("DoMaxSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomax;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomax;
#endif

DoMaxLP:
  if (_trace) printf("DoMaxLP:\n");
#ifdef TRACING
  goto begindomax;
#endif

DoMaxFP:
  if (_trace) printf("DoMaxFP:\n");

begindomax:
  if (_trace) printf("begindomax:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7654:
  if (_trace) printf("g7654:\n");
  if (t10 == 0)
    goto g7638;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7643:
  if (_trace) printf("g7643:\n");
  if (t12 == 0)
    goto g7640;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 > 0)
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;

g7640:
  if (_trace) printf("g7640:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7644:
  if (_trace) printf("g7644:\n");
  if (t12 == 0)
    goto g7635;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g7632;

g7639:
  if (_trace) printf("g7639:\n");

g7638:
  if (_trace) printf("g7638:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7655:
  if (_trace) printf("g7655:\n");
  if (t10 == 0)
    goto g7645;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7650:
  if (_trace) printf("g7650:\n");
  if (t12 == 0)
    goto g7647;
  /* Here if argument TypeSingleFloat */

g7632:
  if (_trace) printf("g7632:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) > 0.0)
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );
  goto cachevalid;

g7647:
  if (_trace) printf("g7647:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7651:
  if (_trace) printf("g7651:\n");
  if (t12 == 0)
    goto g7635;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g7632;

g7646:
  if (_trace) printf("g7646:\n");

g7645:
  if (_trace) printf("g7645:\n");
  /* Here for all other cases */

g7634:
  if (_trace) printf("g7634:\n");

g7631:
  if (_trace) printf("g7631:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7636;

g7635:
  if (_trace) printf("g7635:\n");
  t1 = t3;
  goto g7631;

g7636:
  if (_trace) printf("g7636:\n");

g7637:
  if (_trace) printf("g7637:\n");

/* end DoMax */
  /* End of Halfword operand from stack instruction - DoMax */
/* start DoMin */

  /* Halfword operand from stack instruction - DoMin */
  /* arg2 has the preloaded 8 bit operand. */

domin:
  if (_trace) printf("domin:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMinIM:
  if (_trace) printf("DoMinIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg1 = arg2 << 56;
  arg2 = zero;
  /* Rest of sign extension */
  arg1 = (s64)arg1 >> 56;
  *(u32 *)&processor->immediate_arg = arg1;
  arg1 = (u64)&processor->immediate_arg;
  goto begindomin;
#ifdef TRACING
#endif

DoMinSP:
  if (_trace) printf("DoMinSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  if (arg2 != 0)
    goto begindomin;
  /* SP-pop, Reload TOS */
  arg6 = *(u64 *)arg4;
  /* SP-pop mode */
  arg1 = iSP;
  /* Adjust SP */
  iSP = arg4;
#ifdef TRACING
  goto begindomin;
#endif

DoMinLP:
  if (_trace) printf("DoMinLP:\n");
#ifdef TRACING
  goto begindomin;
#endif

DoMinFP:
  if (_trace) printf("DoMinFP:\n");

begindomin:
  if (_trace) printf("begindomin:\n");
  /* arg1 has the operand address. */
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  LDS(1, f1, *(u32 *)iSP );
  /* ARG1 tag */
  t1 = (u32)(arg6 >> ((4&7)*8));
  /* ARG2 tag */
  t3 = *(s32 *)(arg1 + 4);
  /* ARG1 data */
  t2 = (s32)arg6;
  /* ARG2 data */
  t4 = *(s32 *)arg1;
  LDS(2, f2, *(u32 *)arg1 );
  /* Strip off any CDR code bits. */
  t9 = t1 & 63;
  /* Strip off any CDR code bits. */
  t11 = t3 & 63;
  t10 = (t9 == Type_Fixnum) ? 1 : 0;

g7679:
  if (_trace) printf("g7679:\n");
  if (t10 == 0)
    goto g7663;
  /* Here if argument TypeFixnum */
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7668:
  if (_trace) printf("g7668:\n");
  if (t12 == 0)
    goto g7665;
  /* Here if argument TypeFixnum */
  t5 = t2 - t4;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if ((s64)t5 < 0)
    t4 = t2;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* We know temp2 has CDRNext/TypeFixnum */
  *(u32 *)iSP = t4;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t9;
  goto cachevalid;

g7665:
  if (_trace) printf("g7665:\n");
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7669:
  if (_trace) printf("g7669:\n");
  if (t12 == 0)
    goto g7660;
  /* Here if argument TypeSingleFloat */
  CVTLQ(1, f1, f31, 1, f1);
  CVTQS(1, f1, f31, 1, f1);
  goto g7657;

g7664:
  if (_trace) printf("g7664:\n");

g7663:
  if (_trace) printf("g7663:\n");
  t10 = (t9 == Type_SingleFloat) ? 1 : 0;

g7680:
  if (_trace) printf("g7680:\n");
  if (t10 == 0)
    goto g7670;
  /* Here if argument TypeSingleFloat */
  t12 = (t11 == Type_SingleFloat) ? 1 : 0;

g7675:
  if (_trace) printf("g7675:\n");
  if (t12 == 0)
    goto g7672;
  /* Here if argument TypeSingleFloat */

g7657:
  if (_trace) printf("g7657:\n");
  /* NIL */
  SUBS(0, f0, 1, f1, 2, f2); /* subs */
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  if (FLTU64(0, f0) < 0.0)
    f2 = f1;
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* Force the trap to occur here */
  /* trapb force the trap to occur here */
  t8 = Type_SingleFloat;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t8;
  STS( (u32 *)iSP, 2, f2 );
  goto cachevalid;

g7672:
  if (_trace) printf("g7672:\n");
  t12 = (t11 == Type_Fixnum) ? 1 : 0;

g7676:
  if (_trace) printf("g7676:\n");
  if (t12 == 0)
    goto g7660;
  /* Here if argument TypeFixnum */
  CVTLQ(2, f2, f31, 2, f2);
  CVTQS(2, f2, f31, 2, f2);
  goto g7657;

g7671:
  if (_trace) printf("g7671:\n");

g7670:
  if (_trace) printf("g7670:\n");
  /* Here for all other cases */

g7659:
  if (_trace) printf("g7659:\n");

g7656:
  if (_trace) printf("g7656:\n");
  /* arg6 = tag to dispatch on */
  arg6 = t1;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 1;
  goto numericexception;
  goto g7661;

g7660:
  if (_trace) printf("g7660:\n");
  t1 = t3;
  goto g7656;

g7661:
  if (_trace) printf("g7661:\n");

g7662:
  if (_trace) printf("g7662:\n");

/* end DoMin */
  /* End of Halfword operand from stack instruction - DoMin */
/* start DoMultiplyDouble */

  /* Halfword operand from stack instruction - DoMultiplyDouble */

domultiplydouble:
  if (_trace) printf("domultiplydouble:\n");
  /* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
#endif

DoMultiplyDoubleIM:
  if (_trace) printf("DoMultiplyDoubleIM:\n");
  /* This sequence only sucks a moderate amount */
  /* sign extend the byte argument. */
  arg2 = arg2 << 56;

g7681:
  if (_trace) printf("g7681:\n");
  /* Rest of sign extension */
  arg2 = (s64)arg2 >> 56;
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindomultiplydouble;
#ifdef TRACING
#endif

DoMultiplyDoubleSP:
  if (_trace) printf("DoMultiplyDoubleSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdomultiplydouble;
#endif

DoMultiplyDoubleLP:
  if (_trace) printf("DoMultiplyDoubleLP:\n");
#ifdef TRACING
  goto headdomultiplydouble;
#endif

DoMultiplyDoubleFP:
  if (_trace) printf("DoMultiplyDoubleFP:\n");

headdomultiplydouble:
  if (_trace) printf("headdomultiplydouble:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindomultiplydouble:
  if (_trace) printf("begindomultiplydouble:\n");
  /* arg1 has the operand, sign extended if immediate. */
  /* ARG2 tag */
  t2 = arg1 >> 32;
  /* ARG1 data, sign extended */
  t3 = *(s32 *)iSP;
  /* ARG2 data, sign extended */
  t4 = (s32)arg1 + (s32)0;
  /* ARG1 tag */
  t1 = *(s32 *)(iSP + 4);
  /* TagType. */
  /* Strip CDR code if any. */
  t1 = t1 & 63;
  t1 = t1 - Type_Fixnum;
  /* TagType. */
  /* Strip CDR code if any. */
  t2 = t2 & 63;
  /* Perform the 63 bit multiply. */
  t5 = t3 * t4;
  t2 = t2 - Type_Fixnum;
  if (t1 != 0)
    goto muldexc;
  if (t2 != 0)
    goto muldexc;
  /* Get the low 32 bit half. */
  t6 = (u32)t5;
  /* Get the high 32 bit half. */
  t5 = (u32)(t5 >> ((4&7)*8));
  /* Put the result back on the stack */
  *(u32 *)iSP = t6;
  t1 = Type_Fixnum;
  /* Push high order half */
  *(u32 *)(iSP + 8) = t5;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t1;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

muldexc:
  if (_trace) printf("muldexc:\n");
  arg5 = 0;
  arg2 = 80;
  goto illegaloperand;

/* end DoMultiplyDouble */
  /* End of Halfword operand from stack instruction - DoMultiplyDouble */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
