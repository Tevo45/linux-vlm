/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuninst.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

  /* Instance variable accessors.. */
/* start DoPopInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariable */

dopopinstancevariable:
  if (_trace) printf("dopopinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableIM:
  if (_trace) printf("DoPopInstanceVariableIM:\n");

DoPopInstanceVariableSP:
  if (_trace) printf("DoPopInstanceVariableSP:\n");

DoPopInstanceVariableLP:
  if (_trace) printf("DoPopInstanceVariableLP:\n");

DoPopInstanceVariableFP:
  if (_trace) printf("DoPopInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7230:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7232;

g7231:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7234;

g7239:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7240:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7242;

g7241:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7244;

g7251:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto popiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7229;

g7228:
  if (_trace) printf("g7228:\n");
  arg1 = arg1 + t3;

g7227:
  if (_trace) printf("g7227:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7252:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7254;

g7253:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7256;

g7262:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7264:
  if (_trace) printf("g7264:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7263;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

popiviex:
  if (_trace) printf("popiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7263:
  if (_trace) printf("g7263:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7254:
  if (_trace) printf("g7254:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7253;

g7256:
  if (_trace) printf("g7256:\n");
  if ((t8 & 1) == 0)
    goto g7255;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7252;

g7255:
  if (_trace) printf("g7255:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7259:
#endif
#ifdef MINIMA

g7259:
  if (_trace) printf("g7259:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7258;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7261;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7252;

g7261:
  if (_trace) printf("g7261:\n");
  goto dbcachemisstrap;
#endif

g7258:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g7242:
  if (_trace) printf("g7242:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7241;

g7244:
  if (_trace) printf("g7244:\n");
  if ((t9 & 1) == 0)
    goto g7243;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7240;

g7243:
  if (_trace) printf("g7243:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7248:
  if (_trace) printf("g7248:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7247;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7251;
#ifndef MINIMA

g7247:
#endif
#ifdef MINIMA

g7247:
  if (_trace) printf("g7247:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7246;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7250;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7240;

g7250:
  if (_trace) printf("g7250:\n");
  goto dbcachemisstrap;
#endif

g7246:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7232:
  if (_trace) printf("g7232:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7231;

g7234:
  if (_trace) printf("g7234:\n");
  if ((t9 & 1) == 0)
    goto g7233;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7230;

g7233:
  if (_trace) printf("g7233:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7236:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7229:
  if (_trace) printf("g7229:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7265:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7267;

g7266:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7269;

g7274:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7228;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7228;

g7267:
  if (_trace) printf("g7267:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7266;

g7269:
  if (_trace) printf("g7269:\n");
  if ((t9 & 1) == 0)
    goto g7268;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7265;

g7268:
  if (_trace) printf("g7268:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7271:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPopInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariable */
/* start DoMovemInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */

domoveminstancevariable:
  if (_trace) printf("domoveminstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableIM:
  if (_trace) printf("DoMovemInstanceVariableIM:\n");

DoMovemInstanceVariableSP:
  if (_trace) printf("DoMovemInstanceVariableSP:\n");

DoMovemInstanceVariableLP:
  if (_trace) printf("DoMovemInstanceVariableLP:\n");

DoMovemInstanceVariableFP:
  if (_trace) printf("DoMovemInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7278:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7280;

g7279:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7282;

g7287:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7288:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7290;

g7289:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7292;

g7299:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto movemiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7277;

g7276:
  if (_trace) printf("g7276:\n");
  arg1 = arg1 + t3;

g7275:
  if (_trace) printf("g7275:\n");
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7300:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7302;

g7301:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7304;

g7310:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7312:
  if (_trace) printf("g7312:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7311;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

movemiviex:
  if (_trace) printf("movemiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 2;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7311:
  if (_trace) printf("g7311:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7302:
  if (_trace) printf("g7302:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7301;

g7304:
  if (_trace) printf("g7304:\n");
  if ((t8 & 1) == 0)
    goto g7303;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7300;

g7303:
  if (_trace) printf("g7303:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7307:
#endif
#ifdef MINIMA

g7307:
  if (_trace) printf("g7307:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7306;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7309;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7300;

g7309:
  if (_trace) printf("g7309:\n");
  goto dbcachemisstrap;
#endif

g7306:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

g7290:
  if (_trace) printf("g7290:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7289;

g7292:
  if (_trace) printf("g7292:\n");
  if ((t9 & 1) == 0)
    goto g7291;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7288;

g7291:
  if (_trace) printf("g7291:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7296:
  if (_trace) printf("g7296:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7295;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7299;
#ifndef MINIMA

g7295:
#endif
#ifdef MINIMA

g7295:
  if (_trace) printf("g7295:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7294;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7298;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7288;

g7298:
  if (_trace) printf("g7298:\n");
  goto dbcachemisstrap;
#endif

g7294:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7280:
  if (_trace) printf("g7280:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7279;

g7282:
  if (_trace) printf("g7282:\n");
  if ((t9 & 1) == 0)
    goto g7281;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7278;

g7281:
  if (_trace) printf("g7281:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7284:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7277:
  if (_trace) printf("g7277:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7313:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7315;

g7314:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7317;

g7322:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7276;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7276;

g7315:
  if (_trace) printf("g7315:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7314;

g7317:
  if (_trace) printf("g7317:\n");
  if ((t9 & 1) == 0)
    goto g7316;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7313;

g7316:
  if (_trace) printf("g7316:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7319:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoMovemInstanceVariable */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
/* start DoPushAddressInstanceVariable */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */

dopushaddressinstancevariable:
  if (_trace) printf("dopushaddressinstancevariable:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableIM:
  if (_trace) printf("DoPushAddressInstanceVariableIM:\n");

DoPushAddressInstanceVariableSP:
  if (_trace) printf("DoPushAddressInstanceVariableSP:\n");

DoPushAddressInstanceVariableLP:
  if (_trace) printf("DoPushAddressInstanceVariableLP:\n");

DoPushAddressInstanceVariableFP:
  if (_trace) printf("DoPushAddressInstanceVariableFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Mapped */
  /* Map */
  arg1 = *(s32 *)(iFP + 16);
  t1 = *(s32 *)(iFP + 20);
  arg1 = (u32)arg1;
  t4 = t1 - Type_Array;
  /* Strip CDR code */
  t4 = t4 & 63;
  if (t4 != 0)
    goto ivbadmap;
  /* Memory Read Internal */

g7326:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7328;

g7327:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  if (t10 & 1)
    goto g7330;

g7335:
  t2 = t2 & Array_LengthMask;
  t5 = t2 - arg2;
  /* J. if mapping-table-index-out-of-bounds */
  if ((s64)t5 <= 0)
    goto ivbadindex;
  arg1 = arg1 + arg2;
  arg1 = arg1 + 1;
  /* Memory Read Internal */

g7336:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7338;

g7337:
  t9 = zero + 240;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7340;

g7347:
  t3 = t2;
  t6 = t1 - Type_Fixnum;
  /* Strip CDR code */
  t6 = t6 & 63;
  if (t6 != 0)
    goto pushadiviex;
  /* Self */
  arg1 = *(s32 *)(iFP + 24);
  t6 = *(s32 *)(iFP + 28);
  arg1 = (u32)arg1;
  t5 = t6 - Type_Instance;
  /* Strip CDR code, low bits */
  t5 = t5 & 60;
  if (t5 != 0)
    goto ivbadinst;
  /* Unshifted cdr code */
  t5 = t6 & 192;
  /* Check for CDR code 1 */
  t5 = t5 - 64;
  /* J. if CDR code is not 1 */
  if (t5 != 0)
    goto g7325;

g7324:
  if (_trace) printf("g7324:\n");
  arg1 = arg1 + t3;

g7323:
  if (_trace) printf("g7323:\n");
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

pushadiviex:
  if (_trace) printf("pushadiviex:\n");
  t1 = zero + 8;
  /* SetTag. */
  t1 = t1 << 32;
  t1 = arg2 | t1;
  /* arg6 = tag to dispatch on */
  arg6 = t2;
  /* arg3 = stackp */
  arg3 = 0;
  /* arg1 = instruction arity */
  arg1 = 1;
  /* arg4 = arithmeticp */
  arg4 = 0;
  goto exception;

g7338:
  if (_trace) printf("g7338:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7337;

g7340:
  if (_trace) printf("g7340:\n");
  if ((t9 & 1) == 0)
    goto g7339;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7336;

g7339:
  if (_trace) printf("g7339:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7344:
  if (_trace) printf("g7344:\n");
  t9 = t10 & MemoryActionTransform;
  if (t9 == 0)
    goto g7343;
  t1 = t1 & ~63L;
  t1 = t1 | Type_ExternalValueCellPointer;
  goto g7347;
#ifndef MINIMA

g7343:
#endif
#ifdef MINIMA

g7343:
  if (_trace) printf("g7343:\n");
  t9 = t10 & MemoryActionBinding;
  t8 = *(u64 *)&(processor->dbcmask);
  if (t9 == 0)
    goto g7342;
  t7 = arg1 << 1;
  t9 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t7 = t7 & t8;
  t8 = 1;
  t8 = t8 << (ivorymemorydata & 63);
  t7 = (s32)t7 + (s32)t9;
  /* Clear sign-extension */
  t7 = (u32)t7;
  t8 = (t7 * 4) + t8;
  /* Fetch the key */
  t7 = *(s32 *)t8;
  /* Fetch value */
  t2 = *(s32 *)(t8 + 4);
  /* Compare */
  t9 = (s32)arg1 - (s32)t7;
  /* Trap on miss */
  if (t9 != 0)
    goto g7346;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t2;
  goto g7336;

g7346:
  if (_trace) printf("g7346:\n");
  goto dbcachemisstrap;
#endif

g7342:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 0;
  goto performmemoryaction;

g7328:
  if (_trace) printf("g7328:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7327;

g7330:
  if (_trace) printf("g7330:\n");
  if ((t9 & 1) == 0)
    goto g7329;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7326;

g7329:
  if (_trace) printf("g7329:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7332:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

g7325:
  if (_trace) printf("g7325:\n");
  t5 = arg1;
  /* Memory Read Internal */

g7348:
  t9 = arg1 + ivory;
  t2 = (t9 * 4);
  t1 = LDQ_U(t9);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  t10 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t8 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t2 = *(s32 *)t2;
  t1 = (u8)(t1 >> ((t9&7)*8));
  if (t8 != 0)
    goto g7350;

g7349:
  t9 = zero + 64;
  t10 = t10 >> (t1 & 63);
  t9 = t9 >> (t1 & 63);
  t2 = (u32)t2;
  if (t10 & 1)
    goto g7352;

g7357:
  t5 = t5 - arg1;
  if (t5 != 0)
    goto g7324;
  /* TagType. */
  t6 = t6 & 63;
  /* Set CDR code to 1 */
  t6 = t6 | 64;
  /* Update self */
  *(u32 *)(iFP + 24) = arg1;
  /* write the stack cache */
  *(u32 *)(iFP + 28) = t6;
  goto g7324;

g7350:
  if (_trace) printf("g7350:\n");
  t8 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t7 = (t7 * 8) + t8;
  t2 = *(s32 *)t7;
  /* Read from stack cache */
  t1 = *(s32 *)(t7 + 4);
  goto g7349;

g7352:
  if (_trace) printf("g7352:\n");
  if ((t9 & 1) == 0)
    goto g7351;
  /* Do the indirect thing */
  arg1 = (u32)t2;
  goto g7348;

g7351:
  if (_trace) printf("g7351:\n");
  /* Load the memory action table for cycle */
  t10 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t9 = t1 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t9 = (t9 * 4) + t10;
  /* Get the memory action */
  t10 = *(s32 *)t9;

g7354:
  /* Perform memory action */
  arg1 = t10;
  arg2 = 6;
  goto performmemoryaction;

/* end DoPushAddressInstanceVariable */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
/* start DoPushInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */

dopushinstancevariableordered:
  if (_trace) printf("dopushinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushInstanceVariableOrderedIM:
  if (_trace) printf("DoPushInstanceVariableOrderedIM:\n");

DoPushInstanceVariableOrderedSP:
  if (_trace) printf("DoPushInstanceVariableOrderedSP:\n");

DoPushInstanceVariableOrderedLP:
  if (_trace) printf("DoPushInstanceVariableOrderedLP:\n");

DoPushInstanceVariableOrderedFP:
  if (_trace) printf("DoPushInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  /* Memory Read Internal */

g7358:
  t6 = arg1 + ivory;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg1 - arg5;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)arg6) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g7360;

g7359:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g7362;

g7369:
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  /* set CDR-NEXT */
  t7 = t2 & 63;
  *(u32 *)(iSP + 8) = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto cachevalid;

g7360:
  if (_trace) printf("g7360:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g7359;

g7362:
  if (_trace) printf("g7362:\n");
  if ((t6 & 1) == 0)
    goto g7361;
  /* Do the indirect thing */
  arg1 = (u32)t1;
  goto g7358;

g7361:
  if (_trace) printf("g7361:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g7366:
  if (_trace) printf("g7366:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g7365;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g7369;
#ifndef MINIMA

g7365:
#endif
#ifdef MINIMA

g7365:
  if (_trace) printf("g7365:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g7364;
  t4 = arg1 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg1 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g7368;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t1;
  goto g7358;

g7368:
  if (_trace) printf("g7368:\n");
  goto dbcachemisstrap;
#endif

g7364:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

/* end DoPushInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
/* start DoPopInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */

dopopinstancevariableordered:
  if (_trace) printf("dopopinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPopInstanceVariableOrderedIM:
  if (_trace) printf("DoPopInstanceVariableOrderedIM:\n");

DoPopInstanceVariableOrderedSP:
  if (_trace) printf("DoPopInstanceVariableOrderedSP:\n");

DoPopInstanceVariableOrderedLP:
  if (_trace) printf("DoPopInstanceVariableOrderedLP:\n");

DoPopInstanceVariableOrderedFP:
  if (_trace) printf("DoPopInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  /* Memory Read Internal */

g7370:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7372;

g7371:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7374;

g7380:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7382:
  if (_trace) printf("g7382:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7381;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g7381:
  if (_trace) printf("g7381:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7372:
  if (_trace) printf("g7372:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7371;

g7374:
  if (_trace) printf("g7374:\n");
  if ((t8 & 1) == 0)
    goto g7373;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7370;

g7373:
  if (_trace) printf("g7373:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7377:
#endif
#ifdef MINIMA

g7377:
  if (_trace) printf("g7377:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7376;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7379;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7370;

g7379:
  if (_trace) printf("g7379:\n");
  goto dbcachemisstrap;
#endif

g7376:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoPopInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
/* start DoMovemInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */

domoveminstancevariableordered:
  if (_trace) printf("domoveminstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoMovemInstanceVariableOrderedIM:
  if (_trace) printf("DoMovemInstanceVariableOrderedIM:\n");

DoMovemInstanceVariableOrderedSP:
  if (_trace) printf("DoMovemInstanceVariableOrderedSP:\n");

DoMovemInstanceVariableOrderedLP:
  if (_trace) printf("DoMovemInstanceVariableOrderedLP:\n");

DoMovemInstanceVariableOrderedFP:
  if (_trace) printf("DoMovemInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  arg5 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  arg6 = *(s32 *)&processor->scovlimit;
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  t1 = (u32)t1;
  /* Memory Read Internal */

g7383:
  t8 = arg1 + ivory;
  t5 = (t8 * 4);
  t4 = LDQ_U(t8);
  /* Stack cache offset */
  t6 = arg1 - arg5;
  t9 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t7 = ((u64)t6 < (u64)arg6) ? 1 : 0;
  t5 = *(s32 *)t5;
  t4 = (u8)(t4 >> ((t8&7)*8));
  if (t7 != 0)
    goto g7385;

g7384:
  t8 = zero + 240;
  t9 = t9 >> (t4 & 63);
  t8 = t8 >> (t4 & 63);
  if (t9 & 1)
    goto g7387;

g7393:
  /* Merge cdr-code */
  t5 = t2 & 63;
  t4 = t4 & 192;
  t4 = t4 | t5;
  t6 = arg1 + ivory;
  t5 = (t6 * 4);
  t8 = LDQ_U(t6);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* In range? */
  t9 = ((u64)t7 < (u64)arg6) ? 1 : 0;
  t7 = (t4 & 0xff) << ((t6&7)*8);
  t8 = t8 & ~(0xffL << (t6&7)*8);

g7395:
  if (_trace) printf("g7395:\n");
  t8 = t8 | t7;
  STQ_U(t6, t8);
  *(u32 *)t5 = t1;
  /* J. if in cache */
  if (t9 != 0)
    goto g7394;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

g7394:
  if (_trace) printf("g7394:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t7 = arg1 - arg5;
  /* reconstruct SCA */
  t6 = (t7 * 8) + t6;
  /* Store in stack */
  *(u32 *)t6 = t1;
  /* write the stack cache */
  *(u32 *)(t6 + 4) = t4;
  goto NEXTINSTRUCTION;

g7385:
  if (_trace) printf("g7385:\n");
  t7 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t6 = (t6 * 8) + t7;
  t5 = *(s32 *)t6;
  /* Read from stack cache */
  t4 = *(s32 *)(t6 + 4);
  goto g7384;

g7387:
  if (_trace) printf("g7387:\n");
  if ((t8 & 1) == 0)
    goto g7386;
  /* Do the indirect thing */
  arg1 = (u32)t5;
  goto g7383;

g7386:
  if (_trace) printf("g7386:\n");
  /* Load the memory action table for cycle */
  t9 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t8 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg1;
  /* Adjust for a longword load */
  t8 = (t8 * 4) + t9;
  /* Get the memory action */
  t9 = *(s32 *)t8;
#ifndef MINIMA

g7390:
#endif
#ifdef MINIMA

g7390:
  if (_trace) printf("g7390:\n");
  t8 = t9 & MemoryActionBinding;
  t7 = *(u64 *)&(processor->dbcmask);
  if (t8 == 0)
    goto g7389;
  t6 = arg1 << 1;
  t8 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t6 = t6 & t7;
  t7 = 1;
  t7 = t7 << (ivorymemorydata & 63);
  t6 = (s32)t6 + (s32)t8;
  /* Clear sign-extension */
  t6 = (u32)t6;
  t7 = (t6 * 4) + t7;
  /* Fetch the key */
  t6 = *(s32 *)t7;
  /* Fetch value */
  t5 = *(s32 *)(t7 + 4);
  /* Compare */
  t8 = (s32)arg1 - (s32)t6;
  /* Trap on miss */
  if (t8 != 0)
    goto g7392;
  /* Extract the pointer, and indirect */
  arg1 = (u32)t5;
  goto g7383;

g7392:
  if (_trace) printf("g7392:\n");
  goto dbcachemisstrap;
#endif

g7389:
  /* Perform memory action */
  arg1 = t9;
  arg2 = 1;
  goto performmemoryaction;

/* end DoMovemInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
/* start DoPushAddressInstanceVariableOrdered */

  /* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */

dopushaddressinstancevariableordered:
  if (_trace) printf("dopushaddressinstancevariableordered:\n");
  /* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
#endif

DoPushAddressInstanceVariableOrderedIM:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedIM:\n");

DoPushAddressInstanceVariableOrderedSP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedSP:\n");

DoPushAddressInstanceVariableOrderedLP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedLP:\n");

DoPushAddressInstanceVariableOrderedFP:
  if (_trace) printf("DoPushAddressInstanceVariableOrderedFP:\n");
  arg1 = (u16)(arg3 >> ((4&7)*8));
  /* arg1 has operand preloaded. */
  /* Locate Instance Variable Unmapped */
  /* self */
  t2 = *(s32 *)(iFP + 24);
  t1 = *(s32 *)(iFP + 28);
  t2 = (u32)t2;
  t3 = t1 - Type_Instance;
  /* Strip CDR code, low bits */
  t3 = t3 & 60;
  if (t3 != 0)
    goto ivbadinst;
  arg1 = t2 + arg2;
  t7 = Type_Locative;
  *(u32 *)(iSP + 8) = arg1;
  /* write the stack cache */
  *(u32 *)(iSP + 12) = t7;
  iSP = iSP + 8;
  goto NEXTINSTRUCTION;

ivbadmap:
  if (_trace) printf("ivbadmap:\n");
  arg5 = 0;
  arg2 = 68;
  goto illegaloperand;

ivbadindex:
  if (_trace) printf("ivbadindex:\n");
  arg5 = 0;
  arg2 = 53;
  goto illegaloperand;

ivbadinst:
  if (_trace) printf("ivbadinst:\n");
  arg5 = 0;
  arg2 = 69;
  goto illegaloperand;

/* end DoPushAddressInstanceVariableOrdered */
  /* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
/* start DoInstanceRef */

  /* Halfword operand from stack instruction - DoInstanceRef */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceref:
  if (_trace) printf("doinstanceref:\n");
#ifdef TRACING
#endif

DoInstanceRefIM:
  if (_trace) printf("DoInstanceRefIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceref;
#ifdef TRACING
#endif

DoInstanceRefSP:
  if (_trace) printf("DoInstanceRefSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefLP:
  if (_trace) printf("DoInstanceRefLP:\n");
#ifdef TRACING
  goto headdoinstanceref;
#endif

DoInstanceRefFP:
  if (_trace) printf("DoInstanceRefFP:\n");

headdoinstanceref:
  if (_trace) printf("headdoinstanceref:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceref:
  if (_trace) printf("begindoinstanceref:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7396:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7398;

g7397:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7400;

g7405:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7406:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7408;

g7407:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7410;

g7417:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  /* Memory Read Internal */

g7418:
  /* Base of stack cache */
  t4 = *(u64 *)&(processor->stackcachebasevma);
  t6 = arg5 + ivory;
  t5 = *(s32 *)&processor->scovlimit;
  t1 = (t6 * 4);
  t2 = LDQ_U(t6);
  /* Stack cache offset */
  t4 = arg5 - t4;
  t7 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t5 = ((u64)t4 < (u64)t5) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t6&7)*8));
  if (t5 != 0)
    goto g7420;

g7419:
  t6 = zero + 240;
  t7 = t7 >> (t2 & 63);
  t6 = t6 >> (t2 & 63);
  if (t7 & 1)
    goto g7422;

g7429:
  /* set CDR-NEXT */
  t2 = t2 & 63;
  iPC = *(u64 *)&(((CACHELINEP)iCP)->nextpcdata);
  iCP = *(u64 *)&(((CACHELINEP)iCP)->nextcp);
  *(u32 *)iSP = t1;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t2;
  goto cachevalid;

g7420:
  if (_trace) printf("g7420:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t4 = (t4 * 8) + t5;
  t1 = *(s32 *)t4;
  /* Read from stack cache */
  t2 = *(s32 *)(t4 + 4);
  goto g7419;

g7422:
  if (_trace) printf("g7422:\n");
  if ((t6 & 1) == 0)
    goto g7421;
  /* Do the indirect thing */
  arg5 = (u32)t1;
  goto g7418;

g7421:
  if (_trace) printf("g7421:\n");
  /* Load the memory action table for cycle */
  t7 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t6 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t6 = (t6 * 4) + t7;
  /* Get the memory action */
  t7 = *(s32 *)t6;

g7426:
  if (_trace) printf("g7426:\n");
  t6 = t7 & MemoryActionTransform;
  if (t6 == 0)
    goto g7425;
  t2 = t2 & ~63L;
  t2 = t2 | Type_ExternalValueCellPointer;
  goto g7429;
#ifndef MINIMA

g7425:
#endif
#ifdef MINIMA

g7425:
  if (_trace) printf("g7425:\n");
  t6 = t7 & MemoryActionBinding;
  t5 = *(u64 *)&(processor->dbcmask);
  if (t6 == 0)
    goto g7424;
  t4 = arg5 << 1;
  t6 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t4 = t4 & t5;
  t5 = 1;
  t5 = t5 << (ivorymemorydata & 63);
  t4 = (s32)t4 + (s32)t6;
  /* Clear sign-extension */
  t4 = (u32)t4;
  t5 = (t4 * 4) + t5;
  /* Fetch the key */
  t4 = *(s32 *)t5;
  /* Fetch value */
  t1 = *(s32 *)(t5 + 4);
  /* Compare */
  t6 = (s32)arg5 - (s32)t4;
  /* Trap on miss */
  if (t6 != 0)
    goto g7428;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t1;
  goto g7418;

g7428:
  if (_trace) printf("g7428:\n");
  goto dbcachemisstrap;
#endif

g7424:
  /* Perform memory action */
  arg1 = t7;
  arg2 = 0;
  goto performmemoryaction;

g7408:
  if (_trace) printf("g7408:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7407;

g7410:
  if (_trace) printf("g7410:\n");
  if ((t7 & 1) == 0)
    goto g7409;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7406;

g7409:
  if (_trace) printf("g7409:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7414:
  if (_trace) printf("g7414:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7413;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7417;
#ifndef MINIMA

g7413:
#endif
#ifdef MINIMA

g7413:
  if (_trace) printf("g7413:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7412;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7416;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7406;

g7416:
  if (_trace) printf("g7416:\n");
  goto dbcachemisstrap;
#endif

g7412:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7398:
  if (_trace) printf("g7398:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7397;

g7400:
  if (_trace) printf("g7400:\n");
  if ((t7 & 1) == 0)
    goto g7399;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7396;

g7399:
  if (_trace) printf("g7399:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7402:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceRef */
  /* End of Halfword operand from stack instruction - DoInstanceRef */
/* start DoInstanceSet */

  /* Halfword operand from stack instruction - DoInstanceSet */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceset:
  if (_trace) printf("doinstanceset:\n");
#ifdef TRACING
#endif

DoInstanceSetIM:
  if (_trace) printf("DoInstanceSetIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceset;
#ifdef TRACING
#endif

DoInstanceSetSP:
  if (_trace) printf("DoInstanceSetSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetLP:
  if (_trace) printf("DoInstanceSetLP:\n");
#ifdef TRACING
  goto headdoinstanceset;
#endif

DoInstanceSetFP:
  if (_trace) printf("DoInstanceSetFP:\n");

headdoinstanceset:
  if (_trace) printf("headdoinstanceset:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceset:
  if (_trace) printf("begindoinstanceset:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst3;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7430:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7432;

g7431:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7434;

g7439:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7440:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7442;

g7441:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7444;

g7451:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t1 = *(s32 *)iSP;
  t2 = *(s32 *)(iSP + 4);
  /* Pop Stack. */
  iSP = iSP - 8;
  t1 = (u32)t1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Memory Read Internal */

g7452:
  t7 = arg5 + ivory;
  t4 = (t7 * 4);
  t3 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg5 - t11;
  t8 = *(u64 *)&(processor->datawrite_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t4 = *(s32 *)t4;
  t3 = (u8)(t3 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7454;

g7453:
  t7 = zero + 240;
  t8 = t8 >> (t3 & 63);
  t7 = t7 >> (t3 & 63);
  if (t8 & 1)
    goto g7456;

g7462:
  /* Merge cdr-code */
  t4 = t2 & 63;
  t3 = t3 & 192;
  t3 = t3 | t4;
  t5 = arg5 + ivory;
  t4 = (t5 * 4);
  t7 = LDQ_U(t5);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* In range? */
  t8 = ((u64)t6 < (u64)t12) ? 1 : 0;
  t6 = (t3 & 0xff) << ((t5&7)*8);
  t7 = t7 & ~(0xffL << (t5&7)*8);

g7464:
  if (_trace) printf("g7464:\n");
  t7 = t7 | t6;
  STQ_U(t5, t7);
  *(u32 *)t4 = t1;
  /* J. if in cache */
  if (t8 != 0)
    goto g7463;
  goto NEXTINSTRUCTION;
  goto NEXTINSTRUCTION;

ivrefbadinst3:
  if (_trace) printf("ivrefbadinst3:\n");
  arg5 = 0;
  arg2 = 4;
  goto illegaloperand;

g7463:
  if (_trace) printf("g7463:\n");
  t5 = *(u64 *)&(processor->stackcachedata);
  /* Stack cache offset */
  t6 = arg5 - t11;
  /* reconstruct SCA */
  t5 = (t6 * 8) + t5;
  /* Store in stack */
  *(u32 *)t5 = t1;
  /* write the stack cache */
  *(u32 *)(t5 + 4) = t3;
  goto NEXTINSTRUCTION;

g7454:
  if (_trace) printf("g7454:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t4 = *(s32 *)t5;
  /* Read from stack cache */
  t3 = *(s32 *)(t5 + 4);
  goto g7453;

g7456:
  if (_trace) printf("g7456:\n");
  if ((t7 & 1) == 0)
    goto g7455;
  /* Do the indirect thing */
  arg5 = (u32)t4;
  goto g7452;

g7455:
  if (_trace) printf("g7455:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->datawrite);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t3 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg5;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;
#ifndef MINIMA

g7459:
#endif
#ifdef MINIMA

g7459:
  if (_trace) printf("g7459:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7458;
  t5 = arg5 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t4 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)arg5 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7461;
  /* Extract the pointer, and indirect */
  arg5 = (u32)t4;
  goto g7452;

g7461:
  if (_trace) printf("g7461:\n");
  goto dbcachemisstrap;
#endif

g7458:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 1;
  goto performmemoryaction;

g7442:
  if (_trace) printf("g7442:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7441;

g7444:
  if (_trace) printf("g7444:\n");
  if ((t7 & 1) == 0)
    goto g7443;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7440;

g7443:
  if (_trace) printf("g7443:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7448:
  if (_trace) printf("g7448:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7447;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7451;
#ifndef MINIMA

g7447:
#endif
#ifdef MINIMA

g7447:
  if (_trace) printf("g7447:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7446;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7450;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7440;

g7450:
  if (_trace) printf("g7450:\n");
  goto dbcachemisstrap;
#endif

g7446:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7432:
  if (_trace) printf("g7432:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7431;

g7434:
  if (_trace) printf("g7434:\n");
  if ((t7 & 1) == 0)
    goto g7433;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7430;

g7433:
  if (_trace) printf("g7433:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7436:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceSet */
  /* End of Halfword operand from stack instruction - DoInstanceSet */
/* start DoInstanceLoc */

  /* Halfword operand from stack instruction - DoInstanceLoc */
  /* arg2 has the preloaded 8 bit operand. */

doinstanceloc:
  if (_trace) printf("doinstanceloc:\n");
#ifdef TRACING
#endif

DoInstanceLocIM:
  if (_trace) printf("DoInstanceLocIM:\n");
  /* This sequence is lukewarm */
  *(u32 *)&processor->immediate_arg = arg2;
  arg1 = *(u64 *)&(processor->immediate_arg);
  goto begindoinstanceloc;
#ifdef TRACING
#endif

DoInstanceLocSP:
  if (_trace) printf("DoInstanceLocSP:\n");
  /* Assume SP mode */
  arg1 = arg5;
  /* SP-pop mode */
  if (arg2 == 0)
    arg1 = iSP;
  /* Adjust SP if SP-pop mode */
  if (arg2 == 0)
    iSP = arg4;
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocLP:
  if (_trace) printf("DoInstanceLocLP:\n");
#ifdef TRACING
  goto headdoinstanceloc;
#endif

DoInstanceLocFP:
  if (_trace) printf("DoInstanceLocFP:\n");

headdoinstanceloc:
  if (_trace) printf("headdoinstanceloc:\n");
  /* Compute operand address */
  arg1 = (arg2 * 8) + arg1;
  /* Get the operand */
  arg1 = *(u64 *)arg1;

begindoinstanceloc:
  if (_trace) printf("begindoinstanceloc:\n");
  /* arg1 has the operand, not sign extended if immediate. */
  arg4 = *(s32 *)iSP;
  arg3 = *(s32 *)(iSP + 4);
  arg4 = (u32)arg4;
  arg2 = arg1 >> 32;
  arg1 = (u32)arg1;
  t11 = *(u64 *)&(processor->stackcachebasevma);
  /* Size of the stack cache (words) */
  t12 = *(s32 *)&processor->scovlimit;
  /* Locate Arbitrary Instance Variable */
  t1 = arg3 - Type_Instance;
  /* Strip CDR code, low bits */
  t1 = t1 & 60;
  if (t1 != 0)
    goto ivrefbadinst;
  t1 = arg2 - Type_Fixnum;
  /* Strip CDR code */
  t1 = t1 & 63;
  if (t1 != 0)
    goto ivrefbadoffset;
  /* Memory Read Internal */

g7465:
  t7 = arg4 + ivory;
  t1 = (t7 * 4);
  t2 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = arg4 - t11;
  t8 = *(u64 *)&(processor->header_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t1 = *(s32 *)t1;
  t2 = (u8)(t2 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7467;

g7466:
  t7 = zero + 64;
  t8 = t8 >> (t2 & 63);
  t7 = t7 >> (t2 & 63);
  t1 = (u32)t1;
  if (t8 & 1)
    goto g7469;

g7474:
  t1 = t1 - 1;
  /* Memory Read Internal */

g7475:
  t7 = t1 + ivory;
  t2 = (t7 * 4);
  t4 = LDQ_U(t7);
  /* Stack cache offset */
  t5 = t1 - t11;
  t8 = *(u64 *)&(processor->dataread_mask);
  /* In range? */
  t6 = ((u64)t5 < (u64)t12) ? 1 : 0;
  t2 = *(s32 *)t2;
  t4 = (u8)(t4 >> ((t7&7)*8));
  if (t6 != 0)
    goto g7477;

g7476:
  t7 = zero + 240;
  t8 = t8 >> (t4 & 63);
  t7 = t7 >> (t4 & 63);
  if (t8 & 1)
    goto g7479;

g7486:
  t5 = t4 - Type_Fixnum;
  /* Strip CDR code */
  t5 = t5 & 63;
  if (t5 != 0)
    goto ivrefbadoffset;
  /* J. if offset <0 */
  if ((s64)arg1 < 0)
    goto ivrefbadoffset;
  t4 = arg1 - t2;
  /* J. if offset out of bounds */
  if ((s64)t4 >= 0)
    goto ivrefbadoffset;
  arg5 = arg1 + arg4;
  t7 = Type_Locative;
  *(u32 *)iSP = arg5;
  /* write the stack cache */
  *(u32 *)(iSP + 4) = t7;
  goto NEXTINSTRUCTION;

ivrefbadinst:
  if (_trace) printf("ivrefbadinst:\n");
  arg5 = 0;
  arg2 = 3;
  goto illegaloperand;

ivrefbadoffset:
  if (_trace) printf("ivrefbadoffset:\n");
  arg5 = 0;
  arg2 = 49;
  goto illegaloperand;

g7477:
  if (_trace) printf("g7477:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t2 = *(s32 *)t5;
  /* Read from stack cache */
  t4 = *(s32 *)(t5 + 4);
  goto g7476;

g7479:
  if (_trace) printf("g7479:\n");
  if ((t7 & 1) == 0)
    goto g7478;
  /* Do the indirect thing */
  t1 = (u32)t2;
  goto g7475;

g7478:
  if (_trace) printf("g7478:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->dataread);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t4 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = t1;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7483:
  if (_trace) printf("g7483:\n");
  t7 = t8 & MemoryActionTransform;
  if (t7 == 0)
    goto g7482;
  t4 = t4 & ~63L;
  t4 = t4 | Type_ExternalValueCellPointer;
  goto g7486;
#ifndef MINIMA

g7482:
#endif
#ifdef MINIMA

g7482:
  if (_trace) printf("g7482:\n");
  t7 = t8 & MemoryActionBinding;
  t6 = *(u64 *)&(processor->dbcmask);
  if (t7 == 0)
    goto g7481;
  t5 = t1 << 1;
  t7 = *(u64 *)&(processor->dbcbase);
  /* Hash index */
  t5 = t5 & t6;
  t6 = 1;
  t6 = t6 << (ivorymemorydata & 63);
  t5 = (s32)t5 + (s32)t7;
  /* Clear sign-extension */
  t5 = (u32)t5;
  t6 = (t5 * 4) + t6;
  /* Fetch the key */
  t5 = *(s32 *)t6;
  /* Fetch value */
  t2 = *(s32 *)(t6 + 4);
  /* Compare */
  t7 = (s32)t1 - (s32)t5;
  /* Trap on miss */
  if (t7 != 0)
    goto g7485;
  /* Extract the pointer, and indirect */
  t1 = (u32)t2;
  goto g7475;

g7485:
  if (_trace) printf("g7485:\n");
  goto dbcachemisstrap;
#endif

g7481:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 0;
  goto performmemoryaction;

g7467:
  if (_trace) printf("g7467:\n");
  t6 = *(u64 *)&(processor->stackcachedata);
  /* reconstruct SCA */
  t5 = (t5 * 8) + t6;
  t1 = *(s32 *)t5;
  /* Read from stack cache */
  t2 = *(s32 *)(t5 + 4);
  goto g7466;

g7469:
  if (_trace) printf("g7469:\n");
  if ((t7 & 1) == 0)
    goto g7468;
  /* Do the indirect thing */
  arg4 = (u32)t1;
  goto g7465;

g7468:
  if (_trace) printf("g7468:\n");
  /* Load the memory action table for cycle */
  t8 = *(u64 *)&(processor->header);
  /* TagType. */
  /* Discard the CDR code */
  t7 = t2 & 63;
  /* stash the VMA for the (likely) trap */
  *(u64 *)&processor->vma = arg4;
  /* Adjust for a longword load */
  t7 = (t7 * 4) + t8;
  /* Get the memory action */
  t8 = *(s32 *)t7;

g7471:
  /* Perform memory action */
  arg1 = t8;
  arg2 = 6;
  goto performmemoryaction;

/* end DoInstanceLoc */
  /* End of Halfword operand from stack instruction - DoInstanceLoc */
  /* Fin. */



/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
