/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/idispat.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* This file implements the main instruction dispatch loop. */
#include "kludges.s"
.align 5
.globl DummyDoNothingSubroutine
.ent DummyDoNothingSubroutine 0
.align 3
DummyDoNothingSubroutine:
        br	$31, CONTINUECURRENTINSTRUCTION	# [1]
.end DummyDoNothingSubroutine
.globl NEXTINSTRUCTION
.globl INTERPRETINSTRUCTION
.globl ICACHEMISS
.align 5
.globl MemoryReadData
.ent MemoryReadData 0
.align 3
MemoryReadData:
	.frame $30, 0, $0
/* Memory Read Internal */
G13074:
        addq	$17, $14, $7 	# [1-]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13076	# [1-]
G13075:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13078	# [0di]
G13084:
        ret	$31, ($0), 1	# [1]
.align 3
MemoryReadDataDECODE:
        beq	$6, G13077	# [1]
.align 3
G13076:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$21, 0($5)	#  [2]
        ldl	$20, 4($5)	# Read from stack cache [1]
        br	$31, G13075	# [1]
.align 3
G13078:
        blbc	$7, G13077	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13074	# [1-]
.align 3
G13077:
        ldq	$8, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $7 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
.align 3
G13081:
        and	$8, MemoryActionTransform, $7 	# [3]
        beq	$7, G13080	# [1]
        bic	$20, 63, $20 	# [1-]
        bis	$20, TypeExternalValueCellPointer, $20 	# [1]
        br	$31, G13084	# [1-]
#ifndef MINIMA
G13080:
#endif
#ifdef MINIMA
.align 3
G13080:
        and	$8, MemoryActionBinding, $7 	# [1-]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G13079	# [1-]
        sll	$17, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$21, 4($6)	# Fetch value [1]
        subl	$17, $5, $7 	# Compare [2di]
        bne	$7, G13083	# Trap on miss [1]
        extll	$21, 0, $17 	# Extract the pointer, and indirect [0di]
        br	$31, G13074	# This is another memory read tailcall. [1-]
.align 3
G13083:
	br	$31, DBCACHEMISSTRAP
#endif
G13079:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end MemoryReadData
.align 5
.globl MemoryReadGeneral
.ent MemoryReadGeneral 0
.align 3
MemoryReadGeneral:
	.frame $30, 0, $0
/* Memory Read Internal */
G13136:
        addq	$17, $14, $7 	# [1]
        s4addq	$18, $31, $8 	# Cycle-number -> table offset [1]
        ldq_u	$20, 0($7)	#  [1-]
        s4addq	$8, $14, $8 	# [0di]
        s4addq	$7, $31, $21 	# [1]
        subq	$17, $24, $5 	# Stack cache offset [1]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($8)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [0di]
        bne	$6, G13138	# [1-]
G13137:
        srl	$8, $20, $8 	# [1di]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13140	# [1di]
G13146:
        ret	$31, ($0), 1	# [1]
.align 3
MemoryReadGeneralDECODE:
        beq	$6, G13139	# [1]
.align 3
G13138:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$21, 0($5)	#  [2]
        ldl	$20, 4($5)	# Read from stack cache [1]
        br	$31, G13137	# [1]
.align 3
G13140:
.align 3
G13139:
        s4addq	$18, $31, $8 	# Cycle-number -> table offset [1-]
        s4addq	$8, $14, $8 	# [1]
        ldq	$8, PROCESSORSTATE_DATAREAD($8)	#  [2]
/* TagType. */
        and	$20, 63, $7 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
.align 3
G13144:
        and	$8, MemoryActionIndirect, $6 	# [3]
        beq	$6, G13143	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [1-]
        br	$31, G13136	# [0di]
.align 3
G13143:
        and	$8, MemoryActionTransform, $7 	# [1-]
        beq	$7, G13142	# [1]
        bic	$20, 63, $20 	# [1-]
        bis	$20, TypeExternalValueCellPointer, $20 	# [1]
        br	$31, G13146	# [1-]
#ifndef MINIMA
G13142:
#endif
#ifdef MINIMA
.align 3
G13142:
        and	$8, MemoryActionBinding, $7 	# [1-]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G13141	# [1-]
        sll	$17, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$21, 4($6)	# Fetch value [1]
        subl	$17, $5, $7 	# Compare [2di]
        bne	$7, G13145	# Trap on miss [1]
        extll	$21, 0, $17 	# Extract the pointer, and indirect [0di]
        br	$31, G13136	# This is another memory read tailcall. [1-]
.align 3
G13145:
	br	$31, DBCACHEMISSTRAP
#endif
G13141:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, $18, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end MemoryReadGeneral
.align 5
.globl MemoryReadHeader
.ent MemoryReadHeader 0
.align 3
MemoryReadHeader:
	.frame $30, 0, $0
/* Memory Read Internal */
G13147:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13149	# [1-]
G13148:
        lda	$7, 64	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13151	# [0di]
G13155:
        ret	$31, ($0), 1	# [1]
.align 3
MemoryReadHeaderDECODE:
        beq	$6, G13150	# [1]
.align 3
G13149:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$21, 0($5)	#  [2]
        ldl	$20, 4($5)	# Read from stack cache [1]
        br	$31, G13148	# [1]
.align 3
G13151:
        blbc	$7, G13150	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13147	# [1-]
.align 3
G13150:
        ldq	$8, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $7 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G13152:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end MemoryReadHeader
.align 5
.globl MemoryReadCdr
.ent MemoryReadCdr 0
.align 3
MemoryReadCdr:
	.frame $30, 0, $0
/* Memory Read Internal */
G13156:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_CDR_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13158	# [1-]
G13157:
        lda	$7, 192	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13160	# [0di]
G13164:
        ret	$31, ($0), 1	# [1]
.align 3
MemoryReadCdrDECODE:
        beq	$6, G13159	# [1]
.align 3
G13158:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$21, 0($5)	#  [2]
        ldl	$20, 4($5)	# Read from stack cache [1]
        br	$31, G13157	# [1]
.align 3
G13160:
        blbc	$7, G13159	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13156	# [1-]
.align 3
G13159:
        ldq	$8, PROCESSORSTATE_CDR($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $7 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G13161:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 9, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end MemoryReadCdr
.align 12
.align 5
.globl DoICacheFill
.ent DoICacheFill 0
.align 3
DoICacheFill:
.align 3
ICACHEMISS:
/* Here when instruction cache miss detected.  Fill the cache from */
/* PC and then resume interpreter loop */
/* First round the PC down to an even halfword address */
        ldq	$17, PROCESSORSTATE_ICACHEBASE($14)	# get the base of the icache [1]
        bic	$9, 1, $6 	# the even PC [0di]
        srl	$6, CacheLineRShift, $3 	# [1]
        lda	$16, -1	#  [1]
        ldah	$16, 4($16)	#  [1]
        sll	$3, CacheLineLShift, $3 	# [1]
        srl	$9, 1, $1 	# instn is instruction address here [1]
        addq	$6, $3, $3 	# [1]
        and	$3, $16, $3 	# [1]
        sll	$3, 5, $18 	# temp=cpos*32 [1]
        sll	$3, 4, $3 	# cpos=cpos*16 [1]
        addq	$17, $18, $19 	# temp2=base+cpos*32 [1]
        addq	$19, $3, $3 	# cpos=base+cpos*48 [1]
        bis	$6, 1, $7 	# the odd PC [1]
        bis	$3, $31, $13 	# Assume iPC is the even PC [1]
        cmpeq	$9, $7, $16 	# See if iPC is the odd PC [1]
        addq	$3, CACHELINESIZE, $4 	# [1]
        cmovne	$16, $4, $13 	# Stash the odd cache pointer if iPC is the odd PC [1]
        ldq	$22, PROCESSORSTATE_HALFWORDDISPATCH($14)	#  [1-]
        lda	$20, 1023	#  [0di]
        ldq	$21, PROCESSORSTATE_FULLWORDDISPATCH($14)	#  [1-]
        lda	$8, 20	#  [0di]
        addq	$1, $14, $24 	# [1]
        s4addq	$24, $31, $2 	# [1]
        fetch	0($24)	#  [1-]
        ldq_u	$19, 0($24)	#  [1]
        fetch	0($2)	#  [1]
        ldl	$2, 0($2)	#  [1]
        extbl	$19, $24, $19 	# [1-]
        br	$31, FILLICACHEPREFETCHED	# [0di]
.align 3
PCBACKONE:
/* Wire in continuation for even half */
        stq	$6, CACHELINE_NEXTPCDATA($4)	#  [1]
        subq	$3, CACHELINESIZE, $23 	# Backup in cache too [0di]
        stq	$3, CACHELINE_NEXTCP($4)	#  [1-]
        subq	$6, 1, $16 	# Backup PC one halfword [0di]
        stq	$23, CACHELINE_NEXTCP($3)	#  [1-]
/* TagType. */
        and	$19, 63, $19 	# arg4=tag-cdr code [0di]
        stq	$16, CACHELINE_NEXTPCDATA($3)	#  [1-]
/* Wire in continuation for odd half */
        br	$31, MAYBEUNPACK	# [1]
.align 3
PCADVONE:
        stq	$7, CACHELINE_NEXTPCDATA($3)	# Simple advance of PC one halfword. [1]
        addq	$7, 1, $16 	# [0di]
        stq	$4, CACHELINE_NEXTCP($3)	#  [1-]
        addq	$4, CACHELINESIZE, $23 	# [0di]
        stq	$16, CACHELINE_NEXTPCDATA($4)	#  [1-]
/* TagType. */
        and	$19, 63, $19 	# arg4=tag-cdr code [0di]
        stq	$23, CACHELINE_NEXTCP($4)	#  [1-]
        br	$31, MAYBEUNPACK	# [1]
/* This is the cache fill loop. */
.align 3
FILLICACHE:
        addq	$1, $14, $24 	# [1-]
        s4addq	$24, $31, $2 	# [1]
        ldq_u	$19, 0($24)	#  [1-]
        ldl	$2, 0($2)	#  [1]
        extbl	$19, $24, $19 	# [2-]
.align 3
FILLICACHEPREFETCHED:
#ifdef CACHEMETERING
/* Increment the fill count for both cache entries */
        ldl	$23, CACHELINE_ANNOTATION($3)	#  [1-]
        ldl	$24, CACHELINE_ANNOTATION($4)	#  [1]
        extll	$23, 0, $23 	# [2-]
        extll	$24, 0, $24 	# [1]
        addq	$23, 1, $23 	# [1]
        stl	$23, CACHELINE_ANNOTATION($3)	#  [0di]
        addq	$24, 1, $24 	# [1-]
        stl	$24, CACHELINE_ANNOTATION($4)	#  [0di]
#endif
        stq	$6, CACHELINE_PCDATA($3)	# Set address of even cache posn. [1]
        and	$19, 192, $16 	# CDR code << 6 [0di]
/* TagType. */
        and	$19, 63, $19 	# Strip cdr [1]
        stq	$7, CACHELINE_PCDATA($4)	# Set address of odd cache posn. [0di]
        extll	$2, 0, $2 	# Strip nasty bits out. [1-]
.align 3
G13165:
        sll	$19, 32, $17 	# ready to remerge [1]
        beq	$16, PCADVONE	# Zerotag means advance one HW [0di]
        subq	$16, 128, $16 	# 2<<6 [1]
        beq	$16, PCBACKONE	# Tag=2 means backup one HW [1]
        blt	$16, PCENDCF	# Tag=1 means end of compiled function [1]
.align 3
PCADVTWO:
/* Tag=3 means advance over one full word */
/* Wire in continuation for even half */
        addq	$6, 2, $16 	# Next word [1]
        bis	$31, $31, $31 	# [0]
        addq	$3, TWOCACHELINESIZE, $23 	# corresponding CP entry [1]
        stq	$16, CACHELINE_NEXTPCDATA($3)	# Next PC even of next word [0di]
        addq	$6, 4, $16 	# Skip one fullword [1]
        stq	$23, CACHELINE_NEXTCP($3)	# Next CP [0di]
/* Wire in continuation for odd half */
        addq	$3, FOURCACHELINESIZE, $23 	# corresponding CP entry [1]
        stq	$16, CACHELINE_NEXTPCDATA($4)	#  [0di]
/* TagType. */
        and	$19, 63, $19 	# arg4=tag-cdr code [1-]
        stq	$23, CACHELINE_NEXTCP($4)	#  [0di]
        br	$31, MAYBEUNPACK	# [1]
.align 3
DECODEPACKEDWORD:
/* Here to decode a packed word */
#ifdef CACHEMETERING
        ldl	$16, PROCESSORSTATE_METERVALUE($14)	#  [1]
        ldl	$19, PROCESSORSTATE_METERCOUNT($14)	# The number of remaining tokens. [1]
        ldq	$23, PROCESSORSTATE_METERDATABUFF($14)	# The cache miss meter buffer. [1]
        addq	$16, 1, $16 	# count the miss. [1di]
        ldl	$24, PROCESSORSTATE_METERPOS($14)	# Position for new data. [1-]
        stl	$16, PROCESSORSTATE_METERVALUE($14)	#  [1]
        bne	$19, G13166	# [1]
        ldl	$17, PROCESSORSTATE_METERMASK($14)	#  [0di]
        s4addq	$24, $23, $23 	# position of the current data item [1-]
        addq	$24, 1, $24 	# [1]
        and	$24, $17, $24 	# [1]
        ldl	$17, PROCESSORSTATE_METERMAX($14)	#  [1]
        subq	$16, $17, $25 	# [3]
        cmovgt	$25, $16, $17 	# [1]
        stl	$17, PROCESSORSTATE_METERMAX($14)	#  [1-]
        stl	$16, 0($23)	# store the datapoint [1]
        stl	$24, PROCESSORSTATE_METERPOS($14)	# Position for new data. [1]
        stl	$31, PROCESSORSTATE_METERVALUE($14)	#  [1]
        ldl	$19, PROCESSORSTATE_METERFREQ($14)	#  [1]
.align 3
G13166:
        stl	$19, PROCESSORSTATE_METERCOUNT($14)	#  [1]
#endif
        srl	$2, 18, $19 	# arg4 contains the odd packedword [1]
        srl	$2, 8, $23 	# even opcode+2bits [1]
        stq	$19, CACHELINE_INSTRUCTION($4)	# Save the odd instruction [0di]
        sll	$2, 54, $24 	# First phase of even operand sign extension. [1-]
        and	$2, $20, $25 	# even operand+2bits [1]
#ifndef CACHEMETERING
        stq	$31, CACHELINE_ANNOTATION($4)	#  [1-]
#endif
        and	$23, $20, $23 	# even opcode [0di]
        sra	$24, 38, $24 	# Second phase of even operand sign extension. [1]
        subq	$23, 92, $17 	# [1]
        s8addq	$23, $22, $23 	# [1]
        bis	$24, $25, $25 	# Merge signed/unsigned even operand [1]
        bic	$17, 3, $17 	# [1]
        stl	$25, CACHELINE_OPERAND($3)	#  [0di]
        cmoveq	$17, $17, $8 	# clear count if finish-call seen [1-]
        srl	$19, 8, $17 	# odd opcode+2bits [1]
        sll	$19, 54, $24 	# First phase of odd operand sign extension. [1]
        and	$19, $20, $16 	# odd operand+2bits [1]
        ldq	$23, 0($23)	#  [1-]
        and	$17, $20, $17 	# odd opcode [0di]
        sra	$24, 38, $24 	# Second phase of odd operand sign extension. [1]
        stq	$23, CACHELINE_CODE($3)	#  [0di]
        subq	$17, 92, $25 	# [1-]
        s8addq	$17, $22, $17 	# [1]
        bis	$24, $16, $16 	# Merge signed/unsigned odd operand [1]
        stl	$16, CACHELINE_OPERAND($4)	#  [0di]
        bic	$25, 3, $25 	# [1-]
        ldq	$17, 0($17)	#  [0di]
        cmoveq	$25, $25, $8 	# clear count if finish-call seen [1-]
        stq	$17, CACHELINE_CODE($4)	#  [0di]
        br	$31, ENDDECODE	# [1]
.align 3
MAYBEUNPACK:
        bis	$17, $2, $2 	# reassemble tag and word. [1-]
        stq	$2, CACHELINE_INSTRUCTION($3)	# save the even instruction [0di]
        subq	$19, 48, $23 	# t10>=0 if packed [1-]
#ifndef CACHEMETERING
        stq	$31, CACHELINE_ANNOTATION($3)	#  [0di]
#endif
#ifdef CACHEMETERING
        ldl	$6, PROCESSORSTATE_METERVALUE($14)	#  [1]
        ldl	$25, PROCESSORSTATE_METERCOUNT($14)	# The number of remaining tokens. [1]
        ldq	$24, PROCESSORSTATE_METERDATABUFF($14)	# The cache miss meter buffer. [1]
        addq	$6, 1, $6 	# count the miss. [1di]
        ldl	$16, PROCESSORSTATE_METERPOS($14)	# Position for new data. [1-]
        stl	$6, PROCESSORSTATE_METERVALUE($14)	#  [1]
        bne	$25, G13167	# [1]
        ldl	$17, PROCESSORSTATE_METERMASK($14)	#  [0di]
        s4addq	$16, $24, $24 	# position of the current data item [1-]
        addq	$16, 1, $16 	# [1]
        and	$16, $17, $16 	# [1]
        ldl	$17, PROCESSORSTATE_METERMAX($14)	#  [1]
        subq	$6, $17, $23 	# [3]
        cmovgt	$23, $6, $17 	# [1]
        stl	$17, PROCESSORSTATE_METERMAX($14)	#  [1-]
        stl	$6, 0($24)	# store the datapoint [1]
        stl	$16, PROCESSORSTATE_METERPOS($14)	# Position for new data. [1]
        stl	$31, PROCESSORSTATE_METERVALUE($14)	#  [1]
        ldl	$25, PROCESSORSTATE_METERFREQ($14)	#  [1]
.align 3
G13167:
        stl	$25, PROCESSORSTATE_METERCOUNT($14)	#  [1]
#endif
        bge	$23, DECODEPACKEDWORD	# B. if a packed instruction [1]
        s8addq	$19, $21, $24 	# t11 is the fwdispatch index [1-]
        ldq	$25, PROCESSORSTATE_I_STAGE_ERROR_HOOK($14)	#  [0di]
        subq	$19, 33, $16 	# [1-]
        ldq	$24, 0($24)	# Extract the opcode handler [1di]
        stq	$25, CACHELINE_CODE($4)	# Store I-STATE-ERROR at odd pc [1]
        cmoveq	$16, $16, $8 	# clear count if native instn seen [0di]
        stq	$24, CACHELINE_CODE($3)	#  [1-]
.align 3
ENDDECODE:
/* Here we decide if to stop filling the cache and return to the */
/* instruction interpretation stream, or whether to fill further */
        addq	$1, 1, $1 	# [1-]
        ble	$8, CACHEVALID	# If count is zero, resume [0di]
        sll	$1, 1, $6 	# [1-]
        subq	$8, 1, $8 	# decrement count [1]
        bis	$6, 1, $7 	# [1]
        ldq	$23, PROCESSORSTATE_ENDICACHE($14)	# pointer to the end of icache [0di]
        addq	$4, TWOCACHELINESIZE, $4 	# [1-]
        addq	$3, TWOCACHELINESIZE, $3 	# [1]
        subq	$4, $23, $23 	# [1]
        ble	$23, FILLICACHE	# Still room for more [1]
        br	$31, CACHEVALID	# [1]
.align 3
PCENDCF:
        ldq	$24, PROCESSORSTATE_I_STAGE_ERROR_HOOK($14)	#  [1]
        bis	$31, $31, $8 	# We reached the end of the fcn. [0di]
        stq	$24, CACHELINE_CODE($3)	# Store I-STATE-ERROR dispatch at even and odd pc [1-]
        stq	$24, CACHELINE_CODE($4)	#  [1]
        br	$31, ENDDECODE	# [1]
.end DoICacheFill
/* These are the instruction reentry points.  Instructions end by returning */
/* control to one of these tags.  Most normal instructions reenter by jumping */
/* to NEXTINSTRUCTION, which advances the PC and continues normally.   */
/* Instructions that change the PC usually go directly to INTERPRETINSTRUCTION. */
/* Instructions that fail/trap/exception etc, go to one of the other places. */
.align 5
.globl iInterpret
.ent iInterpret 2
.align 3
iInterpret:
	.frame $30, 1, $26
        stq	$9, PROCESSORSTATE_ASRR9($16)	#  [1]
        stq	$10, PROCESSORSTATE_ASRR10($16)	#  [1]
        stq	$11, PROCESSORSTATE_ASRR11($16)	#  [1]
        stq	$12, PROCESSORSTATE_ASRR12($16)	#  [1]
        stq	$13, PROCESSORSTATE_ASRR13($16)	#  [1]
        stq	$15, PROCESSORSTATE_ASRR15($16)	#  [1]
        stq	$26, PROCESSORSTATE_ASRR26($16)	#  [1]
        stq	$27, PROCESSORSTATE_ASRR27($16)	#  [1]
        stq	$29, PROCESSORSTATE_ASRR29($16)	#  [1]
        stq	$30, PROCESSORSTATE_ASRR30($16)	#  [1]
        stq	$14, PROCESSORSTATE_ASRR14($16)	#  [1]
        bis	$16, $31, $14 	# Setup our processor object handle [1]
/* Upon entry, load cached state. */
        ldq	$13, PROCESSORSTATE_CP($14)	#  [2]
        ldq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        ldq	$12, PROCESSORSTATE_SP($14)	#  [1]
        ldq	$10, PROCESSORSTATE_FP($14)	#  [1]
        ldq	$11, PROCESSORSTATE_LP($14)	#  [1]
        bne	$13, INTERPRETINSTRUCTION	# First time in iCP will be zero. [0di]
        br	$31, ICACHEMISS	# If this is the first time in cache is empty! [1]
.align 3
INTERPRETINSTRUCTIONPREDICTED:
        ldq	$2, CACHELINE_PCDATA($17)	# Get the PC to check cache hit. [1]
        lda	$16, 0($10)	# Assume FP mode [0di]
        ldq	$0, PROCESSORSTATE_STOP_INTERPRETER($14)	# Have we been asked to stop? [1-]
        lda	$19, -8($12)	# SP-pop mode constant [0di]
        ldq	$18, CACHELINE_INSTRUCTION($17)	# Grab the instruction/operand while stalled [1-]
        subq	$9, $2, $1 	# [1di]
        bne	$1, INTERPRETINSTRUCTIONFORBRANCH	# [1]
        bis	$17, $31, $13 	# [0di]
        bne	$0, TRAPORSUSPENDMACHINE	# Stop the world! someone wants out. [1-]
        fetch	0($17)	#  [0di]
        br	$31, CONTINUECURRENTINSTRUCTION	# [1]
.align 3
INTERPRETINSTRUCTIONFORJUMP:
.align 3
INTERPRETINSTRUCTIONFORBRANCH:
        ldq	$5, PROCESSORSTATE_ICACHEBASE($14)	# get the base of the icache [1]
        lda	$4, -1	#  [0di]
        ldah	$4, 4($4)	#  [1]
        srl	$9, 10, $17 	# [1]
        lda	$3, -64	#  [1]
        and	$17, $3, $17 	# [1]
        addq	$9, $17, $17 	# [1]
        and	$17, $4, $17 	# [1]
        sll	$17, 5, $4 	# temp=cpos*32 [1]
        sll	$17, 4, $17 	# cpos=cpos*16 [1]
        addq	$5, $4, $5 	# temp2=base+cpos*32 [1]
.align 3
G13174:
        addq	$5, $17, $17 	# cpos=base+cpos*48 [1]
#ifndef CACHEMETERING
        stq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        fetch	0($17)	#  [2]
        bis	$17, $31, $13 	# [0di]
.align 3
INTERPRETINSTRUCTION:
        ldq	$30, PROCESSORSTATE_ASRR30($14)	#  [1-]
        ldq	$0, PROCESSORSTATE_STOP_INTERPRETER($14)	# Have we been asked to stop? [1]
        lda	$16, 0($10)	# Assume FP mode [1-]
        ldq	$18, CACHELINE_INSTRUCTION($13)	# Grab the instruction/operand while stalled [0di]
        lda	$19, -8($12)	# SP-pop mode constant [1-]
        ldq	$2, CACHELINE_PCDATA($13)	# Get the PC to check cache hit. [0di]
        bne	$0, TRAPORSUSPENDMACHINE	# Stop the world! someone wants out. [1-]
        br	$31, CONTINUECURRENTINSTRUCTION	# [1]
.end iInterpret


/* End of file automatically generated from ../alpha-emulator/idispat.as */
