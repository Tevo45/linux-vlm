/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunjosh.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* 'AI' instructions. */
.align 5
.globl DoDereference
.ent DoDereference 0
/* Halfword operand from stack instruction - DoDereference */
	.globl DoDereferenceFP
	.globl DoDereferenceSP
	.globl DoDereferenceLP
	.globl DoDereferenceIM
.align 3
DoDereference:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoDereferenceIM"
#endif
.align 3
DoDereferenceIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G16058:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoDereference	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoDereferenceSP"
#endif
.align 3
DoDereferenceSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoDereference	# [0di]
	.byte 0x90
	.asciiz "DoDereferenceLP"
#endif
.align 3
DoDereferenceLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoDereference	# [1]
	.byte 0x84
	.asciiz "DoDereferenceFP"
#endif
.align 3
DoDereferenceFP:	# Entry point for FP relative
.align 3
headDoDereference:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoDereference:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $17 	# [3]
        extll	$16, 0, $16 	# [1]
        and	$17, 63, $1 	# Strip off any CDR code bits. [1]
        cmpeq	$1, TypeOneQForward, $2 	# [1]
.align 3
G16053:
        bne	$2, G16049	# [1]
        cmpeq	$1, TypeElementForward, $2 	# [1]
.align 3
G16054:
        bne	$2, G16049	# [1]
        cmpeq	$1, TypeHeaderForward, $2 	# [1]
.align 3
G16055:
        bne	$2, G16049	# [1]
        cmpeq	$1, TypeExternalValueCellPointer, $2 	# [1]
.align 3
G16056:
        beq	$2, G16036	# [1]
.align 3
G16049:
/* Here if argument (TypeOneQForward TypeElementForward TypeHeaderForward TypeExternalValueCellPointer) */
/* Memory Read Internal */
G16037:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$16, $14, $7 	# [0di]
        ldl	$6, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$7, $31, $3 	# [0di]
        ldq_u	$4, 0($7)	#  [1-]
        subq	$16, $5, $5 	# Stack cache offset [1di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $6, $6 	# In range? [0di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$4, $7, $4 	# [0di]
        bne	$6, G16039	# [1-]
G16038:
        lda	$7, 240	#  [0di]
        srl	$8, $4, $8 	# [1]
        srl	$7, $4, $7 	# [1]
        blbs	$8, G16041	# [1-]
G16048:
        and	$4, 63, $5 	# set CDR-NEXT [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
G16036:
        cmpeq	$1, TypeLogicVariable, $2 	# [1-]
.align 3
G16057:
        beq	$2, G16050	# [1]
/* Here if argument TypeLogicVariable */
        bis	$31, TypeExternalValueCellPointer, $5 	# [0di]
        stl	$16, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
G16050:
/* Here for all other cases */
        and	$17, 63, $5 	# set CDR-NEXT [1-]
        stl	$16, 8($12)	#  [1di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
G16035:
.align 3
G16039:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$3, 0($5)	#  [2]
        ldl	$4, 4($5)	# Read from stack cache [1]
        br	$31, G16038	# [1]
.align 3
G16041:
        blbc	$7, G16040	# [1]
        extll	$3, 0, $16 	# Do the indirect thing [0di]
        br	$31, G16037	# [1-]
.align 3
G16040:
        ldq	$8, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $7 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
.align 3
G16045:
        and	$8, MemoryActionTransform, $7 	# [3]
        beq	$7, G16044	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G16048	# [1-]
#ifndef MINIMA
G16044:
#endif
#ifdef MINIMA
.align 3
G16044:
        and	$8, MemoryActionBinding, $7 	# [1-]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G16043	# [1-]
        sll	$16, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$3, 4($6)	# Fetch value [1]
        subl	$16, $5, $7 	# Compare [2di]
        bne	$7, G16047	# Trap on miss [1]
        extll	$3, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G16037	# This is another memory read tailcall. [1-]
.align 3
G16047:
	br	$31, DBCACHEMISSTRAP
#endif
G16043:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoDereference
/* End of Halfword operand from stack instruction - DoDereference */
.align 5
.globl DoUnify
.ent DoUnify 0
/* Halfword operand from stack instruction - DoUnify */
	.globl DoUnifyFP
	.globl DoUnifySP
	.globl DoUnifyLP
	.globl DoUnifyIM
.align 3
DoUnify:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoUnifyIM"
#endif
.align 3
DoUnifyIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G16059:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoUnify	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoUnifySP"
#endif
.align 3
DoUnifySP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoUnify	# [0di]
	.byte 0x90
	.asciiz "DoUnifyLP"
#endif
.align 3
DoUnifyLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoUnify	# [1]
	.byte 0x84
	.asciiz "DoUnifyFP"
#endif
.align 3
DoUnifyFP:	# Entry point for FP relative
.align 3
headDoUnify:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoUnify:
/* arg1 has the operand, sign extended if immediate. */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [1-]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
        br	$31, NEXTINSTRUCTION	# [1-]
.end DoUnify
/* End of Halfword operand from stack instruction - DoUnify */
.align 5
.globl DoPushLocalLogicVariables
.ent DoPushLocalLogicVariables 0
/* Halfword operand from stack instruction - DoPushLocalLogicVariables */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPushLocalLogicVariablesFP
	.globl DoPushLocalLogicVariablesSP
	.globl DoPushLocalLogicVariablesLP
	.globl DoPushLocalLogicVariablesIM
.align 3
DoPushLocalLogicVariables:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoPushLocalLogicVariablesIM"
#endif
.align 3
DoPushLocalLogicVariablesIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoPushLocalLogicVariables	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPushLocalLogicVariablesSP"
#endif
.align 3
DoPushLocalLogicVariablesSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoPushLocalLogicVariables	# [0di]
	.byte 0x90
	.asciiz "DoPushLocalLogicVariablesLP"
#endif
.align 3
DoPushLocalLogicVariablesLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoPushLocalLogicVariables	# [1]
	.byte 0x84
	.asciiz "DoPushLocalLogicVariablesFP"
#endif
.align 3
DoPushLocalLogicVariablesFP:	# Entry point for FP relative
.align 3
headDoPushLocalLogicVariables:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoPushLocalLogicVariables:
/* arg1 has the operand, not sign extended if immediate. */
        bis	$31, TypeLogicVariable, $21 	# [1-]
        srl	$16, 32, $1 	# [2]
        extll	$16, 0, $17 	# [1]
        subq	$1, TypeFixnum, $2 	# [1]
        and	$2, 63, $2 	# Strip CDR code [1]
        bne	$2, PLLVILLOP	# [1]
        ldl	$4, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [1-]
        lda	$1, 128	#  [0di]
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1-]
        addq	$1, $17, $1 	# Account for what we're about to push [0di]
        s8addq	$1, $12, $1 	# SCA of desired end of cache [1]
        s8addq	$4, $2, $2 	# SCA of current end of cache [2]
        cmple	$1, $2, $4 	# [1]
        beq	$4, StackCacheOverflowHandler	# We're done if new SCA is within bounds [1]
        br	$31, PLLVLOOPEND	# [1]
.align 3
PLLVLOOPTOP:
        stl	$12, 8($12)	#  [1]
        stl	$21, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
.align 3
PLLVLOOPEND:
        subq	$17, 1, $17 	# [1]
        bge	$17, PLLVLOOPTOP	# J. If iterations to go. [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
PLLVILLOP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoPushLocalLogicVariables
/* End of Halfword operand from stack instruction - DoPushLocalLogicVariables */
.align 5
.globl DoPushGlobalLogicVariable
.ent DoPushGlobalLogicVariable 0
/* Halfword operand from stack instruction - DoPushGlobalLogicVariable */
	.globl DoPushGlobalLogicVariableFP
	.globl DoPushGlobalLogicVariableSP
	.globl DoPushGlobalLogicVariableLP
	.globl DoPushGlobalLogicVariableIM
.align 3
DoPushGlobalLogicVariable:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoPushGlobalLogicVariableIM"
#endif
.align 3
DoPushGlobalLogicVariableIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G16076:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoPushGlobalLogicVariable	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPushGlobalLogicVariableSP"
#endif
.align 3
DoPushGlobalLogicVariableSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoPushGlobalLogicVariable	# [0di]
	.byte 0x90
	.asciiz "DoPushGlobalLogicVariableLP"
#endif
.align 3
DoPushGlobalLogicVariableLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoPushGlobalLogicVariable	# [1]
	.byte 0x84
	.asciiz "DoPushGlobalLogicVariableFP"
#endif
.align 3
DoPushGlobalLogicVariableFP:	# Entry point for FP relative
.align 3
headDoPushGlobalLogicVariable:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoPushGlobalLogicVariable:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$1, PROCESSORSTATE_BAR2($14)	# Get the structure stack pointer [1]
        bis	$31, TypeExternalValueCellPointer, $3 	# [0di]
        stl	$1, 8($12)	#  [1-]
        stl	$3, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
/* Memory Read Internal */
G16061:
        ldq	$6, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $8 	# [1-]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$8, $31, $5 	# [1-]
        ldq_u	$4, 0($8)	#  [1di]
        subq	$1, $6, $6 	# Stack cache offset [1-]
        ldq	$22, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [0di]
        cmpult	$6, $7, $7 	# In range? [1-]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $8, $4 	# [1-]
        bne	$7, G16063	# [0di]
G16062:
        lda	$8, 240	#  [1-]
        srl	$22, $4, $22 	# [1]
        srl	$8, $4, $8 	# [1]
        blbs	$22, G16065	# [1di]
G16071:
/* Merge cdr-code */
        and	$3, 63, $5 	# [1-]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$1, $14, $6 	# [1-]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$6, $31, $5 	# [1-]
        ldq_u	$8, 0($6)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        cmpult	$7, $22, $22 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G16074:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$1, 0($5)	#  [1]
        bne	$22, G16073	# J. if in cache [1]
G16072:
        addq	$1, 1, $2 	# Increment the structure-stack-pointer [1-]
        stl	$2, PROCESSORSTATE_BAR2($14)	# Set the structure stack pointer [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G16073:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
.align 3
G16075:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $7, $7 	# Stack cache offset [2di]
        s8addq	$7, $6, $6 	# reconstruct SCA [1]
        stl	$1, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, G16072	# [1]
.align 3
G16063:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G16062	# [1]
.align 3
G16065:
        blbc	$8, G16064	# [1]
        extll	$5, 0, $1 	# Do the indirect thing [0di]
        br	$31, G16061	# [1-]
.align 3
G16064:
        ldq	$22, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $8 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $22, $8 	# Adjust for a longword load [2di]
        ldl	$22, 0($8)	# Get the memory action [2]
#ifndef MINIMA
G16068:
#endif
#ifdef MINIMA
.align 3
G16068:
        and	$22, MemoryActionBinding, $8 	# [3]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$8, G16067	# [1-]
        sll	$1, 1, $6 	# [0di]
        ldq	$8, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$6, $7, $6 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$6, $8, $6 	# [1]
        extll	$6, 0, $6 	# Clear sign-extension [1]
        s4addq	$6, $7, $7 	# [2]
        ldl	$6, 0($7)	# Fetch the key [2]
        ldl	$5, 4($7)	# Fetch value [1]
        subl	$1, $6, $8 	# Compare [2di]
        bne	$8, G16070	# Trap on miss [1]
        extll	$5, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G16061	# This is another memory read tailcall. [1-]
.align 3
G16070:
	br	$31, DBCACHEMISSTRAP
#endif
G16067:
/* Perform memory action */
        bis	$31, $22, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoPushGlobalLogicVariable
/* End of Halfword operand from stack instruction - DoPushGlobalLogicVariable */
.align 5
.globl DoLogicTailTest
.ent DoLogicTailTest 0
/* Halfword operand from stack instruction - DoLogicTailTest */
	.globl DoLogicTailTestFP
	.globl DoLogicTailTestSP
	.globl DoLogicTailTestLP
	.globl DoLogicTailTestIM
.align 3
DoLogicTailTest:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoLogicTailTestIM"
#endif
.align 3
DoLogicTailTestIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G16086:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoLogicTailTest	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLogicTailTestSP"
#endif
.align 3
DoLogicTailTestSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoLogicTailTest	# [0di]
	.byte 0x90
	.asciiz "DoLogicTailTestLP"
#endif
.align 3
DoLogicTailTestLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoLogicTailTest	# [1]
	.byte 0x84
	.asciiz "DoLogicTailTestFP"
#endif
.align 3
DoLogicTailTestFP:	# Entry point for FP relative
.align 3
headDoLogicTailTest:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoLogicTailTest:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $17 	# [3]
        and	$17, 63, $1 	# Strip off any CDR code bits. [2]
        cmpeq	$1, TypeList, $2 	# [1]
.align 3
G16083:
        beq	$2, G16078	# [1]
/* Here if argument TypeList */
        ldq	$3, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        stq	$3, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
G16078:
        cmpeq	$1, TypeExternalValueCellPointer, $2 	# [1-]
.align 3
G16084:
        beq	$2, G16079	# [1]
/* Here if argument TypeExternalValueCellPointer */
        ldq	$3, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        stq	$3, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
G16079:
        cmpeq	$1, TypeListInstance, $2 	# [1-]
.align 3
G16085:
        beq	$2, G16080	# [1]
/* Here if argument TypeListInstance */
        ldq	$3, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        stq	$3, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
G16080:
/* Here for all other cases */
        bis	$31, $2, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G16077:
.end DoLogicTailTest
/* End of Halfword operand from stack instruction - DoLogicTailTest */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunjosh.as */
