/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunsubp.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Subprimitives. */
.align 5
.globl DoEphemeralp
.ent DoEphemeralp 0
/* Halfword operand from stack instruction - DoEphemeralp */
	.globl DoEphemeralpFP
	.globl DoEphemeralpSP
	.globl DoEphemeralpLP
	.globl DoEphemeralpIM
.align 3
DoEphemeralp:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoEphemeralpIM"
#endif
.align 3
DoEphemeralpIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G15211:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoEphemeralp	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoEphemeralpSP"
#endif
.align 3
DoEphemeralpSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoEphemeralp	# [0di]
	.byte 0x90
	.asciiz "DoEphemeralpLP"
#endif
.align 3
DoEphemeralpLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoEphemeralp	# [1]
	.byte 0x84
	.asciiz "DoEphemeralpFP"
#endif
.align 3
DoEphemeralpFP:	# Entry point for FP relative
.align 3
headDoEphemeralp:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoEphemeralp:
/* arg1 has the operand, sign extended if immediate. */
        ldq	$1, PROCESSORSTATE_PTRTYPE($14)	# ptr type array [1]
        srl	$16, 32, $17 	# [2di]
        extll	$16, 0, $16 	# [1]
/* TagType. */
        and	$17, 63, $17 	# [1]
        s4addq	$17, $1, $2 	# [1]
        srl	$16, 27, $16 	# [1]
        ldl	$3, 0($2)	# =0 if not a pointer [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bne	$16, NONEPHEM	# J. if zone not ephemeral [0di]
        beq	$3, NONEPHEM	# J. if not a pointer [1]
        ldq	$6, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        stq	$6, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
NONEPHEM:
        ldq	$6, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        stq	$6, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.end DoEphemeralp
/* End of Halfword operand from stack instruction - DoEphemeralp */
.align 12
        and	$31, $31, $31 	# [1]
.align 12
.align 5
.globl DoUnsignedLessp
.ent DoUnsignedLessp 0
/* Halfword operand from stack instruction - DoUnsignedLessp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoUnsignedLesspFP
	.globl DoUnsignedLesspSP
	.globl DoUnsignedLesspLP
	.globl DoUnsignedLesspIM
.align 3
DoUnsignedLessp:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoUnsignedLesspSP"
#endif
.align 3
DoUnsignedLesspSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoUnsignedLessp	# [0di]
	.byte 0x90
	.asciiz "DoUnsignedLesspLP"
#endif
.align 3
DoUnsignedLesspLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoUnsignedLessp	# [1]
	.byte 0x84
	.asciiz "DoUnsignedLesspFP"
#endif
.align 3
DoUnsignedLesspFP:	# Entry point for FP relative
.align 3
headDoUnsignedLessp:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoUnsignedLessp:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$2, 0($12)	# Get data from arg1 [1]
        srl	$18, 12, $18 	# [0di]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        extll	$16, 0, $4 	# Get unsigned data from arg2 [1di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        and	$18, 1, $18 	# 1 if no-pop, 0 if pop [0di]
        extll	$2, 0, $2 	# Unsigned arg1 [1]
        s8addq	$18, $12, $12 	# Either a stack-push or a stack-write [1]
        subq	$4, $2, $6 	# t6:=arg2-arg1 unsigned [1]
        cmovgt	$6, $25, $24 	# [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$24, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
        br	$31, DoUnsignedLesspIM	# [1]
	.byte 0x82
	.asciiz "DoUnsignedLesspIM"
#endif
.align 5
.align 3
DoUnsignedLesspIM:	# Entry point for IMMEDIATE mode
        ldl	$2, 0($12)	# Get data from arg1 [1]
        srl	$18, 12, $18 	# [0di]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        extll	$2, 0, $2 	# ... [2di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        and	$18, 1, $18 	# 1 if no-pop, 0 if pop [0di]
        subq	$17, $2, $6 	# t6:=arg2-arg1 unsigned [1]
        s8addq	$18, $12, $12 	# Either a stack-push or a stack-write [1]
        cmovgt	$6, $25, $24 	# [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$24, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
.end DoUnsignedLessp
/* End of Halfword operand from stack instruction - DoUnsignedLessp */
.align 5
.globl DoAllocateListBlock
.ent DoAllocateListBlock 0
/* Halfword operand from stack instruction - DoAllocateListBlock */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAllocateListBlockFP
	.globl DoAllocateListBlockSP
	.globl DoAllocateListBlockLP
	.globl DoAllocateListBlockIM
.align 3
DoAllocateListBlock:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoAllocateListBlockIM"
#endif
.align 3
DoAllocateListBlockIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoAllocateListBlock	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAllocateListBlockSP"
#endif
.align 3
DoAllocateListBlockSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAllocateListBlock	# [0di]
	.byte 0x90
	.asciiz "DoAllocateListBlockLP"
#endif
.align 3
DoAllocateListBlockLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAllocateListBlock	# [1]
	.byte 0x84
	.asciiz "DoAllocateListBlockFP"
#endif
.align 3
DoAllocateListBlockFP:	# Entry point for FP relative
.align 3
headDoAllocateListBlock:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAllocateListBlock:
/* arg1 has the operand, not sign extended if immediate. */
        ldq	$1, PROCESSORSTATE_LCAREA($14)	#  [1]
        ldq	$18, 0($12)	#  [1]
        srl	$16, 32, $17 	# [1-]
        extll	$16, 0, $16 	# [1]
        subq	$17, TypeFixnum, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G15212	# [1]
        ldl	$4, PROCESSORSTATE_LCLENGTH($14)	#  [0di]
        cmpeq	$18, $1, $2 	# [1-]
        beq	$2, G15213	# Wrong area [1]
        subq	$4, $16, $2 	# Effectively an unsigned 32-bit compare [1]
        blt	$2, G15213	# Insufficient cache [1]
        ldq	$1, PROCESSORSTATE_LCADDRESS($14)	# Fetch address [1-]
        ldah	$3, -16384	#  [0di]
        extll	$3, 0, $3 	# [1]
        stl	$2, PROCESSORSTATE_LCLENGTH($14)	# Store remaining length [0di]
        stq	$1, 0($12)	# Cache address/tag -> TOS [1]
        stl	$1, PROCESSORSTATE_BAR1($14)	# Cache address -> BAR1 [1]
        extll	$1, 0, $1 	# [1]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	# Verify trap mode [0di]
        addq	$1, $16, $1 	# Increment address [2-]
        stl	$1, PROCESSORSTATE_LCADDRESS($14)	# Store updated address [0di]
        and	$3, $4, $3 	# [1-]
        bne	$3, NEXTINSTRUCTION	# Already above emulator mode [1]
        ldah	$3, 16384	#  [1]
        bis	$4, $3, $4 	# [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15212:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15213:
/* SetTag. */
        sll	$17, 32, $1 	# [1]
        bis	$16, $1, $1 	# [2]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.end DoAllocateListBlock
/* End of Halfword operand from stack instruction - DoAllocateListBlock */
.align 5
.globl DoAllocateStructureBlock
.ent DoAllocateStructureBlock 0
/* Halfword operand from stack instruction - DoAllocateStructureBlock */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAllocateStructureBlockFP
	.globl DoAllocateStructureBlockSP
	.globl DoAllocateStructureBlockLP
	.globl DoAllocateStructureBlockIM
.align 3
DoAllocateStructureBlock:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoAllocateStructureBlockIM"
#endif
.align 3
DoAllocateStructureBlockIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoAllocateStructureBlock	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAllocateStructureBlockSP"
#endif
.align 3
DoAllocateStructureBlockSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAllocateStructureBlock	# [0di]
	.byte 0x90
	.asciiz "DoAllocateStructureBlockLP"
#endif
.align 3
DoAllocateStructureBlockLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAllocateStructureBlock	# [1]
	.byte 0x84
	.asciiz "DoAllocateStructureBlockFP"
#endif
.align 3
DoAllocateStructureBlockFP:	# Entry point for FP relative
.align 3
headDoAllocateStructureBlock:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAllocateStructureBlock:
/* arg1 has the operand, not sign extended if immediate. */
        ldq	$1, PROCESSORSTATE_SCAREA($14)	#  [1]
        ldq	$18, 0($12)	#  [1]
        srl	$16, 32, $17 	# [1-]
        extll	$16, 0, $16 	# [1]
        subq	$17, TypeFixnum, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G15214	# [1]
        ldl	$4, PROCESSORSTATE_SCLENGTH($14)	#  [0di]
        cmpeq	$18, $1, $2 	# [1-]
        beq	$2, G15215	# Wrong area [1]
        subq	$4, $16, $2 	# Effectively an unsigned 32-bit compare [1]
        blt	$2, G15215	# Insufficient cache [1]
        ldq	$1, PROCESSORSTATE_SCADDRESS($14)	# Fetch address [1-]
        ldah	$3, -16384	#  [0di]
        extll	$3, 0, $3 	# [1]
        stl	$2, PROCESSORSTATE_SCLENGTH($14)	# Store remaining length [0di]
        stq	$1, 0($12)	# Cache address/tag -> TOS [1]
        stl	$1, PROCESSORSTATE_BAR1($14)	# Cache address -> BAR1 [1]
        extll	$1, 0, $1 	# [1]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	# Verify trap mode [0di]
        addq	$1, $16, $1 	# Increment address [2-]
        stl	$1, PROCESSORSTATE_SCADDRESS($14)	# Store updated address [0di]
        and	$3, $4, $3 	# [1-]
        bne	$3, NEXTINSTRUCTION	# Already above emulator mode [1]
        ldah	$3, 16384	#  [1]
        bis	$4, $3, $4 	# [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15214:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15215:
/* SetTag. */
        sll	$17, 32, $1 	# [1]
        bis	$16, $1, $1 	# [2]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.end DoAllocateStructureBlock
/* End of Halfword operand from stack instruction - DoAllocateStructureBlock */
.align 5
.globl DoPointerDifference
.ent DoPointerDifference 0
/* Halfword operand from stack instruction - DoPointerDifference */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPointerDifferenceFP
	.globl DoPointerDifferenceSP
	.globl DoPointerDifferenceLP
	.globl DoPointerDifferenceIM
.align 3
DoPointerDifference:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPointerDifferenceSP"
#endif
.align 3
DoPointerDifferenceSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoPointerDifference	# [0di]
	.byte 0x90
	.asciiz "DoPointerDifferenceLP"
#endif
.align 3
DoPointerDifferenceLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoPointerDifference	# [1]
	.byte 0x84
	.asciiz "DoPointerDifferenceFP"
#endif
.align 3
DoPointerDifferenceFP:	# Entry point for FP relative
.align 3
headDoPointerDifference:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoPointerDifference:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$1, 0($12)	# Get the data of ARG1 [1]
        extll	$16, 0, $2 	# Get the data of ARG2 [2di]
        subl	$1, $2, $3 	# (%32-bit-difference (data arg1) (data arg2)) [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeFixnum, $4 	# [0di]
        stl	$3, 0($12)	# Save result and coerce to a FIXNUM [1-]
        stl	$4, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
        br	$31, DoPointerDifferenceIM	# [1]
	.byte 0x82
	.asciiz "DoPointerDifferenceIM"
#endif
.align 5
.align 3
DoPointerDifferenceIM:	# Entry point for IMMEDIATE mode
        sll	$17, 56, $2 	# [1-]
        ldl	$1, 0($12)	# Get the data of arg1 [0di]
        sra	$2, 56, $2 	# [2-]
        subl	$1, $2, $3 	# (%32-bit-difference (data arg1) (data arg2)) [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeFixnum, $4 	# [1-]
        stl	$3, 0($12)	# Save result and coerce to a FIXNUM [0di]
        stl	$4, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.end DoPointerDifference
/* End of Halfword operand from stack instruction - DoPointerDifference */
.align 5
.globl DoPointerIncrement
.ent DoPointerIncrement 0
/* Halfword operand from stack instruction - DoPointerIncrement */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPointerIncrementFP
	.globl DoPointerIncrementSP
	.globl DoPointerIncrementLP
	.globl DoPointerIncrementIM
.align 3
DoPointerIncrement:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPointerIncrementSP"
#endif
.align 3
DoPointerIncrementSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoPointerIncrement	# [0di]
	.byte 0x90
	.asciiz "DoPointerIncrementLP"
#endif
.align 3
DoPointerIncrementLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoPointerIncrement	# [1]
	.byte 0x84
	.asciiz "DoPointerIncrementFP"
#endif
.align 3
DoPointerIncrementFP:	# Entry point for FP relative
.align 3
beginDoPointerIncrement:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$2, 0($16)	# Get the data of arg2 [2]
        addl	$2, 1, $3 	# (%32-bit-plus (data arg1) 1) [3]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$3, 0($16)	# Put result back [1]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoPointerIncrementIM"
#endif
DoPointerIncrementIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoPointerIncrement.
.end DoPointerIncrement
/* End of Halfword operand from stack instruction - DoPointerIncrement */
.align 5
.globl DoStoreConditional
.ent DoStoreConditional 0
/* Halfword operand from stack instruction - DoStoreConditional */
	.globl DoStoreConditionalFP
	.globl DoStoreConditionalSP
	.globl DoStoreConditionalLP
	.globl DoStoreConditionalIM
.align 3
DoStoreConditional:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoStoreConditionalIM"
#endif
.align 3
DoStoreConditionalIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G15232:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoStoreConditional	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoStoreConditionalSP"
#endif
.align 3
DoStoreConditionalSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoStoreConditional	# [0di]
	.byte 0x90
	.asciiz "DoStoreConditionalLP"
#endif
.align 3
DoStoreConditionalLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoStoreConditional	# [1]
	.byte 0x84
	.asciiz "DoStoreConditionalFP"
#endif
.align 3
DoStoreConditionalFP:	# Entry point for FP relative
.align 3
headDoStoreConditional:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoStoreConditional:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $17 	# [3]
        ldl	$19, 0($12)	# old tag and data [0di]
        ldl	$18, 4($12)	# old tag and data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        extll	$16, 0, $16 	# [1]
        ldl	$21, 0($12)	# address tag and data [1-]
        ldl	$20, 4($12)	# address tag and data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$21, 0, $21 	# [1]
/* TagType. */
        and	$20, 63, $1 	# [1]
        subq	$1, TypeLocative, $2 	# [1]
        and	$2, 63, $2 	# Strip CDR code [1]
        bne	$2, STORECONDIOP	# [1]
/* Read the location, checking write access */
/* Memory Read Internal */
G15216:
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$21, $14, $3 	# [0di]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$3, $31, $5 	# [0di]
        ldq_u	$4, 0($3)	#  [1-]
        subq	$21, $1, $1 	# Stack cache offset [1di]
        cmpult	$1, $2, $2 	# In range? [1]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $3, $4 	# [1-]
        bne	$2, G15218	# [0di]
G15217:
        ldq	$1, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        lda	$3, 240	#  [0di]
        srl	$1, $4, $1 	# [3]
        srl	$3, $4, $3 	# [1]
        blbs	$1, G15220	# [1-]
G15227:
        subl	$19, $5, $1 	# Check for data match - NOT [1]
        xor	$18, $4, $2 	# Zero if tags match [1]
        bne	$1, STORECONDNIL	# Jump if data didn't match [0di]
/* TagType. */
        and	$2, 63, $2 	# Stip result of comparing CDR-CODEs [1-]
        bne	$2, STORECONDNIL	# Jump if tags don't match [1]
        and	$17, 63, $1 	# Strip CDR-CODE [1-]
        and	$4, 192, $4 	# Retain CDR-CODE [1]
        bis	$1, $4, $4 	# Merge new tag with old CDR-CODE [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$21, $14, $1 	# [1-]
        ldl	$6, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$1, $31, $5 	# [1-]
        ldq_u	$3, 0($1)	#  [1di]
        subq	$21, $2, $2 	# Stack cache offset [1-]
        cmpult	$2, $6, $6 	# In range? [1]
        insbl	$4, $1, $2 	# [1]
        mskbl	$3, $1, $3 	# [1]
.align 3
G15230:
        bis	$3, $2, $3 	# [2]
        stq_u	$3, 0($1)	#  [0di]
        stl	$16, 0($5)	#  [1]
        bne	$6, G15229	# J. if in cache [1]
G15228:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        ldq	$6, PROCESSORSTATE_TADDRESS($14)	#  [1]
        stq	$6, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
STORECONDNIL:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        ldq	$6, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        stq	$6, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
STORECONDIOP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 65, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15229:
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G15231:
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$21, $2, $2 	# Stack cache offset [2di]
        s8addq	$2, $1, $1 	# reconstruct SCA [1]
        stl	$16, 0($1)	# Store in stack [2]
        stl	$4, 4($1)	# write the stack cache [1]
        br	$31, G15228	# [1]
.align 3
G15218:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$5, 0($1)	#  [2]
        ldl	$4, 4($1)	# Read from stack cache [1]
        br	$31, G15217	# [1]
.align 3
G15220:
        blbc	$3, G15219	# [1]
        extll	$5, 0, $21 	# Do the indirect thing [0di]
        br	$31, G15216	# [1-]
.align 3
G15219:
        ldq	$1, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $3 	# Discard the CDR code [0di]
        stq	$21, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $1, $3 	# Adjust for a longword load [2di]
        ldl	$1, 0($3)	# Get the memory action [2]
.align 3
G15224:
        and	$1, MemoryActionTransform, $3 	# [3]
        beq	$3, G15223	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G15227	# [1-]
#ifndef MINIMA
G15223:
#endif
#ifdef MINIMA
.align 3
G15223:
        and	$1, MemoryActionBinding, $3 	# [1-]
        ldq	$2, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$3, G15222	# [1-]
        sll	$21, 1, $1 	# [0di]
        ldq	$3, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$1, $2, $1 	# Hash index [1di]
        bis	$31, 1, $2 	# [1]
        sll	$2, IvoryMemoryData, $2 	# [1]
        addl	$1, $3, $1 	# [1]
        extll	$1, 0, $1 	# Clear sign-extension [1]
        s4addq	$1, $2, $2 	# [2]
        ldl	$1, 0($2)	# Fetch the key [2]
        ldl	$5, 4($2)	# Fetch value [1]
        subl	$21, $1, $3 	# Compare [2di]
        bne	$3, G15226	# Trap on miss [1]
        extll	$5, 0, $21 	# Extract the pointer, and indirect [0di]
        br	$31, G15216	# This is another memory read tailcall. [1-]
.align 3
G15226:
	br	$31, DBCACHEMISSTRAP
#endif
G15222:
/* Perform memory action */
        bis	$31, $1, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoStoreConditional
/* End of Halfword operand from stack instruction - DoStoreConditional */
.align 5
.globl DoMemoryWrite
.ent DoMemoryWrite 0
/* Halfword operand from stack instruction - DoMemoryWrite */
	.globl DoMemoryWriteFP
	.globl DoMemoryWriteSP
	.globl DoMemoryWriteLP
	.globl DoMemoryWriteIM
.align 3
DoMemoryWrite:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoMemoryWriteIM"
#endif
.align 3
DoMemoryWriteIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G15236:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoMemoryWrite	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMemoryWriteSP"
#endif
.align 3
DoMemoryWriteSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoMemoryWrite	# [0di]
	.byte 0x90
	.asciiz "DoMemoryWriteLP"
#endif
.align 3
DoMemoryWriteLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoMemoryWrite	# [1]
	.byte 0x84
	.asciiz "DoMemoryWriteFP"
#endif
.align 3
DoMemoryWriteFP:	# Entry point for FP relative
.align 3
headDoMemoryWrite:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoMemoryWrite:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$19, 0($12)	#  [1]
        ldl	$18, 4($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        srl	$16, 32, $17 	# [1]
        extll	$16, 0, $16 	# [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        addq	$19, $14, $1 	# [0di]
        ldl	$5, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$1, $31, $4 	# [0di]
        ldq_u	$3, 0($1)	#  [1-]
        subq	$19, $2, $2 	# Stack cache offset [1di]
        cmpult	$2, $5, $5 	# In range? [1]
        insbl	$17, $1, $2 	# [1]
        mskbl	$3, $1, $3 	# [1]
.align 3
G15234:
        bis	$3, $2, $3 	# [2]
        stq_u	$3, 0($1)	#  [0di]
        stl	$16, 0($4)	#  [1]
        bne	$5, G15233	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15233:
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
.align 3
G15235:
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$19, $2, $2 	# Stack cache offset [2di]
        s8addq	$2, $1, $1 	# reconstruct SCA [1]
        stl	$16, 0($1)	# Store in stack [2]
        stl	$17, 4($1)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end DoMemoryWrite
/* End of Halfword operand from stack instruction - DoMemoryWrite */
.align 5
.globl DoPStoreContents
.ent DoPStoreContents 0
/* Halfword operand from stack instruction - DoPStoreContents */
	.globl DoPStoreContentsFP
	.globl DoPStoreContentsSP
	.globl DoPStoreContentsLP
	.globl DoPStoreContentsIM
.align 3
DoPStoreContents:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoPStoreContentsIM"
#endif
.align 3
DoPStoreContentsIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G15249:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoPStoreContents	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPStoreContentsSP"
#endif
.align 3
DoPStoreContentsSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoPStoreContents	# [0di]
	.byte 0x90
	.asciiz "DoPStoreContentsLP"
#endif
.align 3
DoPStoreContentsLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoPStoreContents	# [1]
	.byte 0x84
	.asciiz "DoPStoreContentsFP"
#endif
.align 3
DoPStoreContentsFP:	# Entry point for FP relative
.align 3
headDoPStoreContents:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoPStoreContents:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$19, 0($12)	# address tag and data [1]
        ldl	$18, 4($12)	# address tag and data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        srl	$16, 32, $17 	# [1]
        extll	$16, 0, $16 	# [1]
/* Memory Read Internal */
G15237:
        ldq	$6, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$19, $14, $8 	# [0di]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$8, $31, $5 	# [0di]
        ldq_u	$4, 0($8)	#  [1-]
        subq	$19, $6, $6 	# Stack cache offset [1di]
        cmpult	$6, $7, $7 	# In range? [1]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $8, $4 	# [1-]
        bne	$7, G15239	# [0di]
G15238:
G15245:
/* Merge cdr-code */
        and	$17, 63, $5 	# [1-]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$19, $14, $6 	# [1-]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$6, $31, $5 	# [1-]
        ldq_u	$8, 0($6)	#  [1di]
        subq	$19, $7, $7 	# Stack cache offset [1-]
        cmpult	$7, $22, $22 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G15247:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$16, 0($5)	#  [1]
        bne	$22, G15246	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15246:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
.align 3
G15248:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$19, $7, $7 	# Stack cache offset [2di]
        s8addq	$7, $6, $6 	# reconstruct SCA [1]
        stl	$16, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15239:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G15238	# [1]
.end DoPStoreContents
/* End of Halfword operand from stack instruction - DoPStoreContents */
.align 5
.globl DoSetCdrCode1
.ent DoSetCdrCode1 0
/* Halfword operand from stack instruction - DoSetCdrCode1 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetCdrCode1FP
	.globl DoSetCdrCode1SP
	.globl DoSetCdrCode1LP
	.globl DoSetCdrCode1IM
.align 3
DoSetCdrCode1:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetCdrCode1SP"
#endif
.align 3
DoSetCdrCode1SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetCdrCode1	# [0di]
	.byte 0x90
	.asciiz "DoSetCdrCode1LP"
#endif
.align 3
DoSetCdrCode1LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetCdrCode1	# [1]
	.byte 0x84
	.asciiz "DoSetCdrCode1FP"
#endif
.align 3
DoSetCdrCode1FP:	# Entry point for FP relative
.align 3
beginDoSetCdrCode1:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, 4($16)	# Get CDR CODE/TAG of operand [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        and	$1, 63, $1 	# Strip off any existing CDR code bits [1-]
        bis	$1, 64, $1 	# OR in the CDR [1]
        stl	$1, 4($16)	# Replace the CDE CODE/TAG [1-]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetCdrCode1IM"
#endif
DoSetCdrCode1IM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetCdrCode1.
.end DoSetCdrCode1
/* End of Halfword operand from stack instruction - DoSetCdrCode1 */
.align 5
.globl DoSetCdrCode2
.ent DoSetCdrCode2 0
/* Halfword operand from stack instruction - DoSetCdrCode2 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetCdrCode2FP
	.globl DoSetCdrCode2SP
	.globl DoSetCdrCode2LP
	.globl DoSetCdrCode2IM
.align 3
DoSetCdrCode2:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetCdrCode2SP"
#endif
.align 3
DoSetCdrCode2SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetCdrCode2	# [0di]
	.byte 0x90
	.asciiz "DoSetCdrCode2LP"
#endif
.align 3
DoSetCdrCode2LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetCdrCode2	# [1]
	.byte 0x84
	.asciiz "DoSetCdrCode2FP"
#endif
.align 3
DoSetCdrCode2FP:	# Entry point for FP relative
.align 3
beginDoSetCdrCode2:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, 4($16)	# Get CDR CODE/TAG of operand [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        and	$1, 63, $1 	# Strip off any existing CDR code bits [1-]
        bis	$1, 128, $1 	# OR in the CDR [1]
        stl	$1, 4($16)	# Replace the CDE CODE/TAG [1-]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetCdrCode2IM"
#endif
DoSetCdrCode2IM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetCdrCode2.
.end DoSetCdrCode2
/* End of Halfword operand from stack instruction - DoSetCdrCode2 */
.align 5
.globl DoJump
.ent DoJump 0
/* Halfword operand from stack instruction - DoJump */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoJumpFP
	.globl DoJumpSP
	.globl DoJumpLP
	.globl DoJumpIM
.align 3
DoJump:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoJumpSP"
#endif
.align 3
DoJumpSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoJump	# [0di]
	.byte 0x90
	.asciiz "DoJumpLP"
#endif
.align 3
DoJumpLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoJump	# [1]
	.byte 0x84
	.asciiz "DoJumpFP"
#endif
.align 3
DoJumpFP:	# Entry point for FP relative
.align 3
beginDoJump:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$4, 0($16)	# Read address and even/odd PC tag. [2]
        ldl	$3, 4($16)	#  [1]
        extll	$4, 0, $4 	# [2di]
        subq	$3, TypeEvenPC, $5 	# [1]
        and	$5, 62, $5 	# Strip CDR code, low bits [1]
        bne	$5, JEXC	# [1]
        sll	$4, 1, $4 	# [0di]
        and	$3, 1, $9 	# [1]
        addq	$9, $4, $9 	# [1]
        and	$3, 128, $5 	# [1]
        beq	$5, INTERPRETINSTRUCTIONFORJUMP	# [1]
/* Bit 39=1 indicates we need to update control reg */
        and	$3, 64, $6 	# Get the cleanup bit [1-]
        ldq	$5, PROCESSORSTATE_CONTROL($14)	# Processor control register. [0di]
        sll	$6, 17, $6 	# shift into cleanup-in-progress place [1-]
        ldah	$7, 128	#  [1]
        bic	$5, $7, $5 	# Mask [1]
        bis	$5, $6, $5 	# Set [1]
        stq	$5, PROCESSORSTATE_CONTROL($14)	#  [1-]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [1]
.align 3
JEXC:
        bis	$31, 1, $18 	# arg3 = stackp [1-]
        bis	$31, 0, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
#ifdef TRACING
	.byte 0x82
	.asciiz "DoJumpIM"
#endif
DoJumpIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoJump.
.end DoJump
/* End of Halfword operand from stack instruction - DoJump */
.align 5
.globl DoCheckPreemptRequest
.ent DoCheckPreemptRequest 0
/* Halfword 10 bit immediate instruction - DoCheckPreemptRequest */
	.globl DoCheckPreemptRequestFP
	.globl DoCheckPreemptRequestSP
	.globl DoCheckPreemptRequestLP
	.globl DoCheckPreemptRequestIM
.align 3
DoCheckPreemptRequest:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoCheckPreemptRequest"
#endif
.align 3
DoCheckPreemptRequestIM:
.align 3
DoCheckPreemptRequestSP:
.align 3
DoCheckPreemptRequestLP:
.align 3
DoCheckPreemptRequestFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldl	$1, PROCESSORSTATE_INTERRUPTREG($14)	#  [0di]
        and	$1, 2, $2 	# [3]
        cmpeq	$2, 2, $2 	# [1]
        bis	$1, $2, $1 	# [2]
        stl	$1, PROCESSORSTATE_INTERRUPTREG($14)	#  [0di]
        beq	$1, NEXTINSTRUCTION	# [1]
        stq	$1, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end DoCheckPreemptRequest
/* End of Halfword operand from stack instruction - DoCheckPreemptRequest */
.align 5
.globl DoHalt
.ent DoHalt 0
/* Halfword 10 bit immediate instruction - DoHalt */
	.globl DoHaltFP
	.globl DoHaltSP
	.globl DoHaltLP
	.globl DoHaltIM
.align 3
DoHalt:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoHalt"
#endif
.align 3
DoHaltIM:
.align 3
DoHaltSP:
.align 3
DoHaltLP:
.align 3
DoHaltFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        ldl	$1, PROCESSORSTATE_CONTROL($14)	#  [0di]
        srl	$1, 30, $1 	# Isolate current trap mode (FEP mode = -1) [3]
        addl	$1, 1, $1 	# t1 is zero iff we're in trap mode FEP [2]
        bne	$1, HALTEXC	# [1]
	br	$31, HALTMACHINE
.align 3
HALTEXC:
        bis	$31, 1, $18 	# arg3 = stackp [1-]
        bis	$31, 0, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.end DoHalt
/* End of Halfword operand from stack instruction - DoHalt */
.align 5
.globl DoNoOp
.ent DoNoOp 0
/* Halfword 10 bit immediate instruction - DoNoOp */
	.globl DoNoOpFP
	.globl DoNoOpSP
	.globl DoNoOpLP
	.globl DoNoOpIM
.align 3
DoNoOp:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoNoOp"
#endif
.align 3
DoNoOpIM:
.align 3
DoNoOpSP:
.align 3
DoNoOpLP:
.align 3
DoNoOpFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        br	$31, NEXTINSTRUCTION	# [0di]
.end DoNoOp
/* End of Halfword operand from stack instruction - DoNoOp */
.align 5
.globl DoAlu
.ent DoAlu 0
/* Halfword operand from stack instruction - DoAlu */
	.globl DoAluFP
	.globl DoAluSP
	.globl DoAluLP
	.globl DoAluIM
.align 3
DoAlu:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoAluIM"
#endif
.align 3
DoAluIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G15320:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoAlu	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAluSP"
#endif
.align 3
DoAluSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAlu	# [0di]
	.byte 0x90
	.asciiz "DoAluLP"
#endif
.align 3
DoAluLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAlu	# [1]
	.byte 0x84
	.asciiz "DoAluFP"
#endif
.align 3
DoAluFP:	# Entry point for FP relative
.align 3
headDoAlu:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAlu:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $17 	# Get tag of ARG2 [3]
        extll	$16, 0, $16 	# Get data of ARG2 [1]
        ldl	$19, 0($12)	# Get ARG1 [1-]
        ldl	$18, 4($12)	#  [1]
        extll	$19, 0, $19 	# [2-]
        subq	$17, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, ALUEXC	# [1]
        subq	$18, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, ALUEXC	# [1]
        ldq	$20, PROCESSORSTATE_ALUOP($14)	#  [0di]
        stq	$31, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1]
        ldq	$21, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1]
        cmpeq	$20, ALUFunctionBoolean, $1 	# [1-]
.align 3
G15310:
        beq	$1, G15251	# [1]
/* Here if argument ALUFunctionBoolean */
        srl	$21, 10, $23 	# [1di]
        and	$23, 15, $23 	# Extract the ALU boolean function [2]
        cmpeq	$23, BooleClear, $1 	# [1]
.align 3
G15270:
        bne	$1, G15252	# [1]
.align 3
G15253:
        cmpeq	$23, BooleAnd, $1 	# [1]
.align 3
G15271:
        beq	$1, G15254	# [1]
/* Here if argument BooleAnd */
        and	$19, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15254:
        cmpeq	$23, BooleAndC1, $1 	# [1-]
.align 3
G15272:
        beq	$1, G15255	# [1]
/* Here if argument BooleAndC1 */
        bic	$16, $19, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15255:
        cmpeq	$23, Boole2, $1 	# [1-]
.align 3
G15273:
        beq	$1, G15256	# [1]
/* Here if argument Boole2 */
        bis	$16, $31, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15256:
        cmpeq	$23, BooleAndC2, $1 	# [1-]
.align 3
G15274:
        beq	$1, G15257	# [1]
/* Here if argument BooleAndC2 */
        bic	$19, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15257:
        cmpeq	$23, Boole1, $1 	# [1-]
.align 3
G15275:
        beq	$1, G15258	# [1]
/* Here if argument Boole1 */
        bis	$19, $31, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15258:
        cmpeq	$23, BooleXor, $1 	# [1-]
.align 3
G15276:
        beq	$1, G15259	# [1]
/* Here if argument BooleXor */
        xor	$19, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15259:
        cmpeq	$23, BooleIor, $1 	# [1-]
.align 3
G15277:
        beq	$1, G15260	# [1]
/* Here if argument BooleIor */
        bis	$19, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15260:
        cmpeq	$23, BooleNor, $1 	# [1-]
.align 3
G15278:
        beq	$1, G15261	# [1]
/* Here if argument BooleNor */
        bis	$19, $16, $23 	# [0di]
        ornot	$31, $23, $23 	# [1]
        br	$31, G15252	# [0di]
.align 3
G15261:
        cmpeq	$23, BooleEquiv, $1 	# [1-]
.align 3
G15279:
        beq	$1, G15262	# [1]
/* Here if argument BooleEquiv */
        xor	$19, $16, $23 	# [0di]
        ornot	$31, $23, $23 	# [1]
        br	$31, G15252	# [0di]
.align 3
G15262:
        cmpeq	$23, BooleC1, $1 	# [1-]
.align 3
G15280:
        beq	$1, G15263	# [1]
/* Here if argument BooleC1 */
        ornot	$31, $19, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15263:
        cmpeq	$23, BooleOrC1, $1 	# [1-]
.align 3
G15281:
        beq	$1, G15264	# [1]
/* Here if argument BooleOrC1 */
        ornot	$16, $19, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15264:
        cmpeq	$23, BooleC2, $1 	# [1-]
.align 3
G15282:
        beq	$1, G15265	# [1]
/* Here if argument BooleC2 */
        ornot	$31, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15265:
        cmpeq	$23, BooleOrC2, $1 	# [1-]
.align 3
G15283:
        beq	$1, G15266	# [1]
/* Here if argument BooleOrC2 */
        bic	$19, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15266:
        cmpeq	$23, BooleNand, $1 	# [1-]
.align 3
G15284:
        beq	$1, G15267	# [1]
/* Here if argument BooleNand */
        and	$19, $16, $23 	# [0di]
        br	$31, G15252	# [1-]
.align 3
G15267:
        cmpeq	$23, BooleSet, $1 	# [1-]
.align 3
G15285:
        beq	$1, G15252	# [1]
/* Here if argument BooleSet */
        ornot	$31, $31, $23 	# [0di]
.align 3
G15252:
        stl	$23, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15251:
        cmpeq	$20, ALUFunctionByte, $1 	# [1-]
.align 3
G15311:
        beq	$1, G15286	# [1]
/* Here if argument ALUFunctionByte */
        ldq	$2, PROCESSORSTATE_BYTEROTATE($14)	# Get rotate [0di]
        ldq	$3, PROCESSORSTATE_BYTESIZE($14)	# Get bytesize [1]
/* Get background */
        srl	$21, 10, $1 	# [0di]
        and	$1, 3, $1 	# Extract the byte background [2]
        cmpeq	$1, ALUByteBackgroundOp1, $4 	# [1]
.align 3
G15293:
        beq	$4, G15289	# [1]
/* Here if argument ALUByteBackgroundOp1 */
        bis	$19, $31, $1 	# [0di]
.align 3
G15288:
        srl	$21, 12, $5 	# [1]
        and	$5, 1, $5 	# Extractthe byte rotate latch [2]
        sll	$16, $2, $23 	# [1]
        extll	$23, 4, $4 	# [2]
        extll	$23, 0, $23 	# [1]
        bis	$23, $4, $23 	# OP2 rotated [2]
        beq	$5, G15287	# Don't update rotate latch if not requested [1-]
        stq	$23, PROCESSORSTATE_ROTATELATCH($14)	#  [1]
.align 3
G15287:
        lda	$5, -2	#  [1-]
        sll	$5, $3, $5 	# [1]
        ornot	$31, $5, $5 	# Compute mask [2]
/* Get byte function */
        srl	$21, 13, $4 	# [1]
        and	$4, 1, $4 	# [2]
        cmpeq	$4, ALUByteFunctionDpb, $3 	# [1]
.align 3
G15298:
        beq	$3, G15295	# [1]
/* Here if argument ALUByteFunctionDpb */
        sll	$5, $2, $5 	# Position mask [0di]
.align 3
G15294:
        and	$23, $5, $23 	# rotated&mask [2]
        bic	$1, $5, $1 	# background&~mask [1]
        bis	$23, $1, $23 	# [1]
        stl	$23, 0($12)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15286:
        cmpeq	$20, ALUFunctionAdder, $1 	# [1-]
.align 3
G15312:
        beq	$1, G15299	# [1]
/* Here if argument ALUFunctionAdder */
        srl	$21, 11, $3 	# [0di]
        and	$3, 3, $3 	# Extract the op2 [2]
        srl	$21, 10, $2 	# [1]
        and	$2, 1, $2 	# Extract the adder carry in [2]
        cmpeq	$3, ALUAdderOp2Op2, $4 	# [1]
.align 3
G15307:
        beq	$4, G15302	# [1]
/* Here if argument ALUAdderOp2Op2 */
        bis	$16, $31, $1 	# [0di]
.align 3
G15301:
        addq	$19, $1, $23 	# [1]
        addq	$23, $2, $23 	# [1]
        srl	$23, 31, $3 	# Sign bit [1]
        srl	$23, 32, $4 	# Next bit [1]
        xor	$3, $4, $3 	# Low bit is now overflow indicator [2]
        srl	$21, 24, $4 	# Get the load-carry-in bit [1]
        stq	$3, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1-]
        blbc	$4, G15300	# [1]
        extll	$23, 4, $3 	# Get the carry [1-]
        lda	$4, 1024	#  [1]
        bic	$21, $4, $21 	# [1]
        and	$3, 1, $4 	# [1]
        sll	$4, 10, $4 	# [1]
        bis	$21, $4, $21 	# Set the adder carry in [2]
        stq	$21, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1-]
.align 3
G15300:
        cmplt	$19, $1, $3 	# [1-]
        stq	$3, PROCESSORSTATE_ALUBORROW($14)	#  [0di]
        addl	$19, $31, $19 	# [1-]
        addl	$16, $31, $16 	# [1]
        cmplt	$19, $1, $3 	# [1]
        stq	$3, PROCESSORSTATE_ALULESSTHAN($14)	#  [0di]
        stl	$23, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15299:
        cmpeq	$20, ALUFunctionMultiplyDivide, $1 	# [1-]
.align 3
G15313:
        beq	$1, G15250	# [1]
/* Here if argument ALUFunctionMultiplyDivide */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
        stl	$23, 0($12)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15250:
.align 3
ALUEXC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 80, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15302:
        cmpeq	$3, ALUAdderOp2Zero, $4 	# [1]
.align 3
G15314:
        beq	$4, G15303	# [1]
/* Here if argument ALUAdderOp2Zero */
        bis	$31, $31, $1 	# [0di]
        br	$31, G15301	# [1-]
.align 3
G15303:
        cmpeq	$3, ALUAdderOp2Invert, $4 	# [1-]
.align 3
G15315:
        beq	$4, G15304	# [1]
/* Here if argument ALUAdderOp2Invert */
        addl	$16, $31, $1 	# [0di]
        subq	$31, $1, $1 	# [1]
        extll	$1, 0, $1 	# [1]
        br	$31, G15301	# [1-]
.align 3
G15304:
        cmpeq	$3, ALUAdderOp2MinusOne, $4 	# [1-]
.align 3
G15316:
        beq	$4, G15301	# [1]
/* Here if argument ALUAdderOp2MinusOne */
        ornot	$31, $31, $1 	# [0di]
        extll	$1, 0, $1 	# [1]
        br	$31, G15301	# [0di]
.align 3
G15295:
        cmpeq	$4, ALUByteFunctionLdb, $3 	# [1-]
.align 3
G15317:
        bne	$3, G15294	# [1]
        br	$31, G15294	# [1]
.align 3
G15289:
        cmpeq	$1, ALUByteBackgroundRotateLatch, $4 	# [1-]
.align 3
G15318:
        beq	$4, G15290	# [1]
/* Here if argument ALUByteBackgroundRotateLatch */
        ldq	$1, PROCESSORSTATE_ROTATELATCH($14)	#  [0di]
        br	$31, G15288	# [1]
.align 3
G15290:
        cmpeq	$1, ALUByteBackgroundZero, $4 	# [2-]
.align 3
G15319:
        beq	$4, G15288	# [1]
/* Here if argument ALUByteBackgroundZero */
        bis	$31, $31, $1 	# [0di]
        br	$31, G15288	# [1-]
.end DoAlu
/* End of Halfword operand from stack instruction - DoAlu */
.align 5
.globl DoSpareOp
.ent DoSpareOp 0
/* Halfword 10 bit immediate instruction - DoSpareOp */
	.globl DoSpareOpFP
	.globl DoSpareOpSP
	.globl DoSpareOpLP
	.globl DoSpareOpIM
.align 3
DoSpareOp:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoSpareOp"
#endif
.align 3
DoSpareOpIM:
.align 3
DoSpareOpSP:
.align 3
DoSpareOpLP:
.align 3
DoSpareOpFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        ldq	$1, CACHELINE_INSTRUCTION($13)	# Get the instruction [0di]
        srl	$1, 10, $1 	# Position the opcode [3]
        and	$1, 255, $1 	# Extract it [2]
        bis	$31, 0, $16 	# arg1 = instruction arity [1]
        bis	$31, $1, $17 	# arg2 = instruction opcode [1]
        bis	$31, 1, $18 	# arg3 = stackp [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# when not stackp arg5=the arg [1]
        bis	$31, 0, $21 	# arg6=tag to dispatch on [1]
	br	$31, EXCEPTION	# Unimplemented
        br	$31, NEXTINSTRUCTION	# [1-]
.end DoSpareOp
/* End of Halfword operand from stack instruction - DoSpareOp */
/* Reading and writing internal registers */
.align 5
.globl ReadRegisterFP
.ent ReadRegisterFP 0
.align 3
ReadRegisterFP:
/* Convert stack cache address to VMA */
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$10, $5, $5 	# stack cache base relative offset [2-]
        srl	$5, 3, $5 	# convert byte address to word address [1]
        addq	$5, $4, $4 	# reconstruct VMA [2]
        bis	$31, TypeLocative, $5 	# [1]
        stl	$4, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterFP
.align 5
.globl ReadRegisterLP
.ent ReadRegisterLP 0
.align 3
ReadRegisterLP:
/* Convert stack cache address to VMA */
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$11, $5, $5 	# stack cache base relative offset [2-]
        srl	$5, 3, $5 	# convert byte address to word address [1]
        addq	$5, $4, $4 	# reconstruct VMA [2]
        bis	$31, TypeLocative, $5 	# [1]
        stl	$4, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterLP
.align 5
.globl ReadRegisterSP
.ent ReadRegisterSP 0
.align 3
ReadRegisterSP:
/* Convert stack cache address to VMA */
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $5, $5 	# stack cache base relative offset [2-]
        srl	$5, 3, $5 	# convert byte address to word address [1]
        addq	$5, $4, $4 	# reconstruct VMA [2]
        bis	$31, TypeLocative, $5 	# [1]
        stl	$4, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterSP
.align 5
.globl ReadRegisterStackCacheLowerBound
.ent ReadRegisterStackCacheLowerBound 0
.align 3
ReadRegisterStackCacheLowerBound:
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        bis	$31, TypeLocative, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterStackCacheLowerBound
.align 5
.globl ReadRegisterBARx
.ent ReadRegisterBARx 0
.align 3
ReadRegisterBARx:
        srl	$16, 7, $2 	# BAR number into T2 [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        lda	$1, PROCESSORSTATE_BAR0($14)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        s8addq	$2, $1, $1 	# Now T1 points to the BAR [1-]
        ldq	$3, 0($1)	#  [2]
        bis	$31, TypeLocative, $4 	# [1-]
        stl	$3, 8($12)	#  [0di]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.end ReadRegisterBARx
.align 5
.globl ReadRegisterContinuation
.ent ReadRegisterContinuation 0
.align 3
ReadRegisterContinuation:
        ldq	$3, PROCESSORSTATE_CONTINUATION($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterContinuation
.align 5
.globl ReadRegisterAluAndRotateControl
.ent ReadRegisterAluAndRotateControl 0
.align 3
ReadRegisterAluAndRotateControl:
        ldq	$3, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterAluAndRotateControl
.align 5
.globl ReadRegisterControlRegister
.ent ReadRegisterControlRegister 0
.align 3
ReadRegisterControlRegister:
        ldl	$3, PROCESSORSTATE_CONTROL($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterControlRegister
.align 5
.globl ReadRegisterCRArgumentSize
.ent ReadRegisterCRArgumentSize 0
.align 3
ReadRegisterCRArgumentSize:
        ldl	$3, PROCESSORSTATE_CONTROL($14)	#  [1]
        and	$3, 255, $3 	# Get the argument size field [3]
        bis	$31, TypeFixnum, $5 	# [1]
        stl	$3, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterCRArgumentSize
.align 5
.globl ReadRegisterEphemeralOldspaceRegister
.ent ReadRegisterEphemeralOldspaceRegister 0
.align 3
ReadRegisterEphemeralOldspaceRegister:
        ldl	$3, PROCESSORSTATE_EPHEMERALOLDSPACE($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterEphemeralOldspaceRegister
.align 5
.globl ReadRegisterZoneOldspaceRegister
.ent ReadRegisterZoneOldspaceRegister 0
.align 3
ReadRegisterZoneOldspaceRegister:
        ldl	$3, PROCESSORSTATE_ZONEOLDSPACE($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterZoneOldspaceRegister
.align 5
.globl ReadRegisterChipRevision
.ent ReadRegisterChipRevision 0
.align 3
ReadRegisterChipRevision:
        bis	$31, 5, $3 	# [1-]
        bis	$31, TypeFixnum, $5 	# [1]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterChipRevision
.align 5
.globl ReadRegisterFPCoprocessorPresent
.ent ReadRegisterFPCoprocessorPresent 0
.align 3
ReadRegisterFPCoprocessorPresent:
        bis	$31, TypeFixnum, $4 	# [1-]
        stl	$31, 8($12)	#  [1di]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterFPCoprocessorPresent
.align 5
.globl ReadRegisterPreemptRegister
.ent ReadRegisterPreemptRegister 0
.align 3
ReadRegisterPreemptRegister:
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1]
        and	$3, 3, $3 	# [3]
        bis	$31, TypeFixnum, $5 	# [1]
        stl	$3, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterPreemptRegister
.align 5
.globl ReadRegisterIcacheControl
.ent ReadRegisterIcacheControl 0
.align 3
ReadRegisterIcacheControl:
        bis	$31, TypeFixnum, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterIcacheControl
.align 5
.globl ReadRegisterPrefetcherControl
.ent ReadRegisterPrefetcherControl 0
.align 3
ReadRegisterPrefetcherControl:
        bis	$31, TypeFixnum, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterPrefetcherControl
.align 5
.globl ReadRegisterMapCacheControl
.ent ReadRegisterMapCacheControl 0
.align 3
ReadRegisterMapCacheControl:
        bis	$31, TypeFixnum, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterMapCacheControl
.align 5
.globl ReadRegisterMemoryControl
.ent ReadRegisterMemoryControl 0
.align 3
ReadRegisterMemoryControl:
        bis	$31, TypeFixnum, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterMemoryControl
.align 5
.globl ReadRegisterStackCacheOverflowLimit
.ent ReadRegisterStackCacheOverflowLimit 0
.align 3
ReadRegisterStackCacheOverflowLimit:
        ldl	$3, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        addq	$3, $4, $3 	# [3]
        bis	$31, TypeLocative, $4 	# [1]
        stl	$3, 8($12)	#  [1-]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterStackCacheOverflowLimit
.align 5
.globl ReadRegisterMicrosecondClock
.ent ReadRegisterMicrosecondClock 0
.align 3
ReadRegisterMicrosecondClock:
        bis	$31, TypeFixnum, $1 	# [1-]
        stl	$31, 8($12)	#  [1di]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterMicrosecondClock
.align 5
.globl ReadRegisterTOS
.ent ReadRegisterTOS 0
.align 3
ReadRegisterTOS:
        ldq	$1, 0($12)	#  [1]
        addq	$12, 8, $12 	# [1]
        sll	$1, 26, $2 	# [2]
        srl	$2, 26, $2 	# [2]
        stq	$2, 0($12)	# Push CDR-NEXT TOS [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterTOS
.align 5
.globl ReadRegisterEventCount
.ent ReadRegisterEventCount 0
.align 3
ReadRegisterEventCount:
        ldq	$3, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1]
        bis	$31, TypeFixnum, $4 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterEventCount
.align 5
.globl ReadRegisterBindingStackPointer
.ent ReadRegisterBindingStackPointer 0
.align 3
ReadRegisterBindingStackPointer:
        ldq	$3, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterBindingStackPointer
.align 5
.globl ReadRegisterCatchBlockList
.ent ReadRegisterCatchBlockList 0
.align 3
ReadRegisterCatchBlockList:
        ldq	$3, PROCESSORSTATE_CATCHBLOCK($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterCatchBlockList
.align 5
.globl ReadRegisterControlStackLimit
.ent ReadRegisterControlStackLimit 0
.align 3
ReadRegisterControlStackLimit:
        ldl	$3, PROCESSORSTATE_CSLIMIT($14)	#  [1]
        bis	$31, TypeLocative, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterControlStackLimit
.align 5
.globl ReadRegisterControlStackExtraLimit
.ent ReadRegisterControlStackExtraLimit 0
.align 3
ReadRegisterControlStackExtraLimit:
        ldl	$3, PROCESSORSTATE_CSEXTRALIMIT($14)	#  [1]
        bis	$31, TypeLocative, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterControlStackExtraLimit
.align 5
.globl ReadRegisterBindingStackLimit
.ent ReadRegisterBindingStackLimit 0
.align 3
ReadRegisterBindingStackLimit:
        ldq	$3, PROCESSORSTATE_BINDINGSTACKLIMIT($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterBindingStackLimit
.align 5
.globl ReadRegisterPHTBase
.ent ReadRegisterPHTBase 0
.align 3
ReadRegisterPHTBase:
        bis	$31, TypeLocative, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterPHTBase
.align 5
.globl ReadRegisterPHTMask
.ent ReadRegisterPHTMask 0
.align 3
ReadRegisterPHTMask:
        bis	$31, TypeFixnum, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterPHTMask
.align 5
.globl ReadRegisterCountMapReloads
.ent ReadRegisterCountMapReloads 0
.align 3
ReadRegisterCountMapReloads:
        bis	$31, TypeFixnum, $5 	# [1-]
        stl	$31, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.end ReadRegisterCountMapReloads
.align 5
.globl ReadRegisterListCacheArea
.ent ReadRegisterListCacheArea 0
.align 3
ReadRegisterListCacheArea:
        ldq	$3, PROCESSORSTATE_LCAREA($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterListCacheArea
.align 5
.globl ReadRegisterListCacheAddress
.ent ReadRegisterListCacheAddress 0
.align 3
ReadRegisterListCacheAddress:
        ldq	$3, PROCESSORSTATE_LCADDRESS($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterListCacheAddress
.align 5
.globl ReadRegisterListCacheLength
.ent ReadRegisterListCacheLength 0
.align 3
ReadRegisterListCacheLength:
        ldl	$3, PROCESSORSTATE_LCLENGTH($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterListCacheLength
.align 5
.globl ReadRegisterStructureCacheArea
.ent ReadRegisterStructureCacheArea 0
.align 3
ReadRegisterStructureCacheArea:
        ldq	$3, PROCESSORSTATE_SCAREA($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterStructureCacheArea
.align 5
.globl ReadRegisterStructureCacheAddress
.ent ReadRegisterStructureCacheAddress 0
.align 3
ReadRegisterStructureCacheAddress:
        ldq	$3, PROCESSORSTATE_SCADDRESS($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterStructureCacheAddress
.align 5
.globl ReadRegisterStructureCacheLength
.ent ReadRegisterStructureCacheLength 0
.align 3
ReadRegisterStructureCacheLength:
        ldl	$3, PROCESSORSTATE_SCLENGTH($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterStructureCacheLength
.align 5
.globl ReadRegisterDynamicBindingCacheBase
.ent ReadRegisterDynamicBindingCacheBase 0
.align 3
ReadRegisterDynamicBindingCacheBase:
        ldq	$3, PROCESSORSTATE_DBCBASE($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterDynamicBindingCacheBase
.align 5
.globl ReadRegisterDynamicBindingCacheMask
.ent ReadRegisterDynamicBindingCacheMask 0
.align 3
ReadRegisterDynamicBindingCacheMask:
        ldq	$3, PROCESSORSTATE_DBCMASK($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        sll	$3, 26, $5 	# [3]
        srl	$5, 26, $5 	# [2]
        stq	$5, 0($12)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterDynamicBindingCacheMask
.align 5
.globl ReadRegisterChoicePointer
.ent ReadRegisterChoicePointer 0
.align 3
ReadRegisterChoicePointer:
        ldl	$3, PROCESSORSTATE_CHOICEPTR($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterChoicePointer
.align 5
.globl ReadRegisterStructureStackChoicePointer
.ent ReadRegisterStructureStackChoicePointer 0
.align 3
ReadRegisterStructureStackChoicePointer:
        ldl	$3, PROCESSORSTATE_SSTKCHOICEPTR($14)	#  [1]
        bis	$31, TypeFixnum, $5 	# [0di]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterStructureStackChoicePointer
.align 5
.globl ReadRegisterFEPModeTrapVectorAddress
.ent ReadRegisterFEPModeTrapVectorAddress 0
.align 3
ReadRegisterFEPModeTrapVectorAddress:
        ldq	$3, PROCESSORSTATE_FEPMODETRAPVECADDRESS($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end ReadRegisterFEPModeTrapVectorAddress
.align 5
.globl ReadRegisterStackFrameMaximumSize
.ent ReadRegisterStackFrameMaximumSize 0
.align 3
ReadRegisterStackFrameMaximumSize:
        lda	$3, 128	#  [1-]
        bis	$31, TypeFixnum, $5 	# [1]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterStackFrameMaximumSize
.align 5
.globl ReadRegisterStackCacheDumpQuantum
.ent ReadRegisterStackCacheDumpQuantum 0
.align 3
ReadRegisterStackCacheDumpQuantum:
        lda	$3, 896	#  [1-]
        bis	$31, TypeFixnum, $5 	# [1]
        stl	$3, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterStackCacheDumpQuantum
.align 5
.globl ReadRegisterConstantNIL
.ent ReadRegisterConstantNIL 0
.align 3
ReadRegisterConstantNIL:
        ldq	$5, PROCESSORSTATE_TADDRESS($14)	#  [1]
        stq	$5, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterConstantNIL
.align 5
.globl ReadRegisterConstantT
.ent ReadRegisterConstantT 0
.align 3
ReadRegisterConstantT:
        ldq	$5, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        stq	$5, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.end ReadRegisterConstantT
.align 5
.globl ReadRegisterError
.ent ReadRegisterError 0
.align 3
ReadRegisterError:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end ReadRegisterError
.align 5
.globl WriteRegisterFP
.ent WriteRegisterFP 0
.align 3
WriteRegisterFP:
#ifdef IVERIFY
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of the stack cache [1-]
        ldl	$1, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        subq	$18, $2, $2 	# Stack cache offset [2-]
        cmpult	$2, $1, $3 	# In range? [1]
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        beq	$3, BADREGISTER	# J. if not in cache [0di]
        s8addq	$2, $1, $1 	# reconstruct SCA [3-]
        bis	$1, $31, $10 	# [1]
        br	$31, NEXTINSTRUCTION	# [1-]
#else
        bis	$31, 0, $20 	# [0di]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
#endif
.end WriteRegisterFP
.align 5
.globl WriteRegisterLP
.ent WriteRegisterLP 0
.align 3
WriteRegisterLP:
#ifdef IVERIFY
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of the stack cache [1-]
        ldl	$1, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        subq	$18, $2, $2 	# Stack cache offset [2-]
        cmpult	$2, $1, $3 	# In range? [1]
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        beq	$3, BADREGISTER	# J. if not in cache [0di]
        s8addq	$2, $1, $1 	# reconstruct SCA [3-]
        bis	$1, $31, $11 	# [1]
        br	$31, NEXTINSTRUCTION	# [1-]
#else
        bis	$31, 0, $20 	# [0di]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
#endif
.end WriteRegisterLP
.align 5
.globl WriteRegisterSP
.ent WriteRegisterSP 0
.align 3
WriteRegisterSP:
#ifdef IVERIFY
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of the stack cache [1-]
        ldl	$1, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        subq	$18, $2, $2 	# Stack cache offset [2-]
        cmpult	$2, $1, $3 	# In range? [1]
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        beq	$3, BADREGISTER	# J. if not in cache [0di]
        s8addq	$2, $1, $1 	# reconstruct SCA [3-]
        bis	$1, $31, $12 	# [1]
        br	$31, NEXTINSTRUCTION	# [1-]
#else
        bis	$31, 0, $20 	# [0di]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
#endif
.end WriteRegisterSP
.align 5
.globl WriteRegisterStackCacheLowerBound
.ent WriteRegisterStackCacheLowerBound 0
.align 3
WriteRegisterStackCacheLowerBound:
#ifdef IVERIFY
        stq	$18, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldq	$1, PROCESSORSTATE_STACKCACHESIZE($14)	#  [1]
        addq	$18, $1, $1 	# [3]
        stq	$1, PROCESSORSTATE_STACKCACHETOPVMA($14)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
#else
        bis	$31, 0, $20 	# [0di]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
#endif
.end WriteRegisterStackCacheLowerBound
.align 5
.globl WriteRegisterContinuation
.ent WriteRegisterContinuation 0
.align 3
WriteRegisterContinuation:
        sll	$17, 32, $19 	# [1]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterContinuation
.align 5
.globl WriteRegisterAluAndRotateControl
.ent WriteRegisterAluAndRotateControl 0
.align 3
WriteRegisterAluAndRotateControl:
        srl	$18, 14, $1 	# [1-]
        and	$1, 3, $1 	# Extract the function class bits [2]
        stq	$18, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1-]
        srl	$18, 5, $2 	# [0di]
        and	$2, 31, $2 	# Extract the byte size [2]
        stq	$1, PROCESSORSTATE_ALUOP($14)	#  [0di]
        and	$18, 31, $3 	# Extract the Byte Rotate [1-]
        stq	$2, PROCESSORSTATE_BYTESIZE($14)	#  [0di]
        stq	$3, PROCESSORSTATE_BYTEROTATE($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterAluAndRotateControl
.align 5
.globl WriteRegisterControlRegister
.ent WriteRegisterControlRegister 0
.align 3
WriteRegisterControlRegister:
        stl	$18, PROCESSORSTATE_CONTROL($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterControlRegister
.align 5
.globl WriteRegisterEphemeralOldspaceRegister
.ent WriteRegisterEphemeralOldspaceRegister 0
.align 3
WriteRegisterEphemeralOldspaceRegister:
        stq	$31, PROCESSORSTATE_AC0ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC1ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC2ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC3ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC4ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC5ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC6ARRAY($14)	#  [1]
        stq	$31, PROCESSORSTATE_AC7ARRAY($14)	#  [1]
        stl	$18, PROCESSORSTATE_EPHEMERALOLDSPACE($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterEphemeralOldspaceRegister
.align 5
.globl WriteRegisterZoneOldspaceRegister
.ent WriteRegisterZoneOldspaceRegister 0
.align 3
WriteRegisterZoneOldspaceRegister:
        stl	$18, PROCESSORSTATE_ZONEOLDSPACE($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterZoneOldspaceRegister
.align 5
.globl WriteRegisterFPCoprocessorPresent
.ent WriteRegisterFPCoprocessorPresent 0
.align 3
WriteRegisterFPCoprocessorPresent:
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterFPCoprocessorPresent
.align 5
.globl WriteRegisterPreemptRegister
.ent WriteRegisterPreemptRegister 0
.align 3
WriteRegisterPreemptRegister:
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1]
        bic	$3, 3, $3 	# [3]
        and	$18, 3, $18 	# [1]
        bis	$3, $18, $3 	# [1]
        stl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1-]
        blbc	$3, NEXTINSTRUCTION	# [1]
        stq	$3, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterPreemptRegister
.align 5
.globl WriteRegisterStackCacheOverflowLimit
.ent WriteRegisterStackCacheOverflowLimit 0
.align 3
WriteRegisterStackCacheOverflowLimit:
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        extll	$1, 0, $1 	# [3]
        subq	$18, $1, $1 	# [2]
        stl	$1, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterStackCacheOverflowLimit
.align 5
.globl WriteRegisterTOS
.ent WriteRegisterTOS 0
.align 3
WriteRegisterTOS:
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterTOS
.align 5
.globl WriteRegisterEventCount
.ent WriteRegisterEventCount 0
.align 3
WriteRegisterEventCount:
        stq	$18, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterEventCount
.align 5
.globl WriteRegisterBindingStackPointer
.ent WriteRegisterBindingStackPointer 0
.align 3
WriteRegisterBindingStackPointer:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterBindingStackPointer
.align 5
.globl WriteRegisterCatchBlockList
.ent WriteRegisterCatchBlockList 0
.align 3
WriteRegisterCatchBlockList:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_CATCHBLOCK($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterCatchBlockList
.align 5
.globl WriteRegisterControlStackLimit
.ent WriteRegisterControlStackLimit 0
.align 3
WriteRegisterControlStackLimit:
        stl	$18, PROCESSORSTATE_CSLIMIT($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterControlStackLimit
.align 5
.globl WriteRegisterControlStackExtraLimit
.ent WriteRegisterControlStackExtraLimit 0
.align 3
WriteRegisterControlStackExtraLimit:
        stl	$18, PROCESSORSTATE_CSEXTRALIMIT($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterControlStackExtraLimit
.align 5
.globl WriteRegisterBindingStackLimit
.ent WriteRegisterBindingStackLimit 0
.align 3
WriteRegisterBindingStackLimit:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_BINDINGSTACKLIMIT($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterBindingStackLimit
.align 5
.globl WriteRegisterListCacheArea
.ent WriteRegisterListCacheArea 0
.align 3
WriteRegisterListCacheArea:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_LCAREA($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterListCacheArea
.align 5
.globl WriteRegisterListCacheAddress
.ent WriteRegisterListCacheAddress 0
.align 3
WriteRegisterListCacheAddress:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_LCADDRESS($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterListCacheAddress
.align 5
.globl WriteRegisterListCacheLength
.ent WriteRegisterListCacheLength 0
.align 3
WriteRegisterListCacheLength:
        stl	$18, PROCESSORSTATE_LCLENGTH($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterListCacheLength
.align 5
.globl WriteRegisterStructureCacheArea
.ent WriteRegisterStructureCacheArea 0
.align 3
WriteRegisterStructureCacheArea:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_SCAREA($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterStructureCacheArea
.align 5
.globl WriteRegisterStructureCacheAddress
.ent WriteRegisterStructureCacheAddress 0
.align 3
WriteRegisterStructureCacheAddress:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_SCADDRESS($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterStructureCacheAddress
.align 5
.globl WriteRegisterStructureCacheLength
.ent WriteRegisterStructureCacheLength 0
.align 3
WriteRegisterStructureCacheLength:
        stl	$18, PROCESSORSTATE_SCLENGTH($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterStructureCacheLength
.align 5
.globl WriteRegisterDynamicBindingCacheBase
.ent WriteRegisterDynamicBindingCacheBase 0
.align 3
WriteRegisterDynamicBindingCacheBase:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterDynamicBindingCacheBase
.align 5
.globl WriteRegisterDynamicBindingCacheMask
.ent WriteRegisterDynamicBindingCacheMask 0
.align 3
WriteRegisterDynamicBindingCacheMask:
        sll	$17, 32, $19 	# [1-]
        bis	$19, $18, $19 	# construct the combined word [2]
        stq	$19, PROCESSORSTATE_DBCMASK($14)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterDynamicBindingCacheMask
.align 5
.globl WriteRegisterChoicePointer
.ent WriteRegisterChoicePointer 0
.align 3
WriteRegisterChoicePointer:
        stl	$18, PROCESSORSTATE_CHOICEPTR($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterChoicePointer
.align 5
.globl WriteRegisterStructureStackChoicePointer
.ent WriteRegisterStructureStackChoicePointer 0
.align 3
WriteRegisterStructureStackChoicePointer:
        stl	$18, PROCESSORSTATE_SSTKCHOICEPTR($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterStructureStackChoicePointer
.align 5
.globl WriteRegisterFEPModeTrapVectorAddress
.ent WriteRegisterFEPModeTrapVectorAddress 0
.align 3
WriteRegisterFEPModeTrapVectorAddress:
        stl	$18, PROCESSORSTATE_FEPMODETRAPVECADDRESS($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterFEPModeTrapVectorAddress
.align 5
.globl WriteRegisterMappingTableCache
.ent WriteRegisterMappingTableCache 0
.align 3
WriteRegisterMappingTableCache:
        br	$31, NEXTINSTRUCTION	# [1]
.end WriteRegisterMappingTableCache
.align 5
.globl WriteRegisterError
.ent WriteRegisterError 0
.align 3
WriteRegisterError:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end WriteRegisterError
/* Coprocessor read and write are implemented in C in order to */
/* encourage creativity!  The hooks are in aicoproc.c */
.align 5
.globl DoCoprocessorRead
.ent DoCoprocessorRead 0
/* Halfword 10 bit immediate instruction - DoCoprocessorRead */
	.globl DoCoprocessorReadFP
	.globl DoCoprocessorReadSP
	.globl DoCoprocessorReadLP
	.globl DoCoprocessorReadIM
.align 3
DoCoprocessorRead:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoCoprocessorRead"
#endif
.align 3
DoCoprocessorReadIM:
.align 3
DoCoprocessorReadSP:
.align 3
DoCoprocessorReadLP:
.align 3
DoCoprocessorReadFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$0, PROCESSORSTATE_COPROCESSORREADHOOK($14)	#  [0di]
        stq	$13, PROCESSORSTATE_CP($14)	#  [1]
        stq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        stq	$12, PROCESSORSTATE_SP($14)	#  [1]
        stq	$10, PROCESSORSTATE_FP($14)	#  [1]
        stq	$11, PROCESSORSTATE_LP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        bis	$0, $31, $27 	# [0di]
        jsr	$26, ($0), 0	# [1-]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        ldq	$13, PROCESSORSTATE_CP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        ldq	$12, PROCESSORSTATE_SP($14)	#  [1]
        ldq	$10, PROCESSORSTATE_FP($14)	#  [1]
        ldq	$11, PROCESSORSTATE_LP($14)	#  [1]
/* Long -1 is never a valid LISP value */
        lda	$1, -1	#  [1-]
        cmpeq	$0, $1, $1 	# [1]
        bne	$1, CPREADEXC	# J. if CoprocessorRead exception return [1]
        addq	$12, 8, $12 	# [0di]
        sll	$0, 26, $1 	# [1]
        srl	$1, 26, $1 	# [2]
        stq	$1, 0($12)	# Push the result of coprocessor read! [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CPREADEXC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoCoprocessorRead
/* End of Halfword operand from stack instruction - DoCoprocessorRead */
.align 5
.globl DoCoprocessorWrite
.ent DoCoprocessorWrite 0
/* Halfword 10 bit immediate instruction - DoCoprocessorWrite */
	.globl DoCoprocessorWriteFP
	.globl DoCoprocessorWriteSP
	.globl DoCoprocessorWriteLP
	.globl DoCoprocessorWriteIM
.align 3
DoCoprocessorWrite:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoCoprocessorWrite"
#endif
.align 3
DoCoprocessorWriteIM:
.align 3
DoCoprocessorWriteSP:
.align 3
DoCoprocessorWriteLP:
.align 3
DoCoprocessorWriteFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$17, 0($12)	# The value to be written [0di]
        subq	$12, 8, $12 	# Pop Stack. [1]
        lda	$2, CoprocessorRegisterUnwindStackForRestartOrApply	#  [1]
        subq	$16, $2, $2 	# [1]
        bne	$2, G15322	# [1]
/* Here if argument CoprocessorRegisterUnwindStackForRestartOrApply */
        ldl	$1, 0($12)	# peek at new continuation to look at tag [1-]
        ldl	$2, 4($12)	#  [1]
        extll	$1, 0, $1 	# [2-]
        subq	$2, TypeEvenPC, $3 	# [1]
        and	$3, 62, $3 	# Strip CDR code, low bits [1]
        bne	$3, UNWINDILLEGALCONTINUATION	# [1]
        ldq	$1, 0($12)	# Get new continuation [1-]
        subq	$12, 8, $12 	# Pop Stack. [1]
        stq	$1, PROCESSORSTATE_CONTINUATION($14)	# Update continuation register [1-]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1]
        ldl	$1, 0($12)	# Get new FP [1]
        ldl	$2, 4($12)	# Get new FP [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
        subq	$2, TypeLocative, $3 	# [1]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, UNWINDILLEGALFP	# [1]
/* Convert VMA to stack cache address */
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldq	$10, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $2, $2 	# stack cache base relative offset [2di]
        s8addq	$2, $10, $10 	# reconstruct SCA [1]
        ldl	$1, 0($12)	# Get new LP [0di]
        ldl	$2, 4($12)	# Get new LP [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
        subq	$2, TypeLocative, $3 	# [1]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, UNWINDILLEGALLP	# [1]
/* Convert VMA to stack cache address */
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldq	$11, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $2, $2 	# stack cache base relative offset [2-]
        s8addq	$2, $11, $11 	# reconstruct SCA [1]
/* Update CDR-CODEs to make it a legitimate frame */
        ldl	$1, 4($10)	# Tag of saved continuation register [1-]
        ldl	$2, 12($10)	# Tag of saved control register [1]
        bis	$1, 192, $1 	# Set CDR-CODE to 3 [2-]
        stl	$1, 4($10)	# Put it back [0di]
        bis	$2, 192, $2 	# Set CDR-CODE to 3 [1-]
        stl	$2, 12($10)	# Put it back [0di]
/* Copy the current trap-on-exit bit into the saved control register */
        ldl	$1, PROCESSORSTATE_CONTROL($14)	# Get control register [1]
        ldl	$2, 8($10)	# Get saved control register [1]
        extll	$2, 0, $2 	# [3]
        ldah	$3, 256	#  [1]
        bic	$2, $3, $2 	# Remove saved control register's trap-on-exit bit [1]
        and	$1, $3, $1 	# Extract control register's trap-on-exit bit [1]
        bis	$2, $1, $2 	# Copy it into saved control register [1]
        stl	$2, 8($10)	# Update saved control register [0di]
/* Restore the new control register with proper trap mode */
        ldl	$1, 0($12)	# peek at new control register to look at tag [1]
        ldl	$2, 4($12)	#  [1]
        extll	$1, 0, $1 	# [2-]
        subq	$2, TypeFixnum, $3 	# [1]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, UNWINDILLEGALCONTROL	# [1]
        ldl	$1, 0($12)	# Get new control register [1-]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [2]
        stl	$1, PROCESSORSTATE_CONTROL($14)	#  [0di]
        br	$31, G15321	# [1]
.align 3
G15322:
        lda	$2, CoprocessorRegisterFlushIDCaches	#  [1-]
        subq	$16, $2, $2 	# [1]
        bne	$2, G15323	# [1]
/* Here if argument CoprocessorRegisterFlushIDCaches */
/* We're about to flush the instruction cache so we can't rely */
/* on ContinueToNextInstruction working.  Instead, we must load */
/* the next PC now and explicitly fill the cache. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$1, PROCESSORSTATE_FLUSHCACHES_HOOK($14)	#  [1]
        stq	$13, PROCESSORSTATE_CP($14)	#  [1]
        stq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        stq	$12, PROCESSORSTATE_SP($14)	#  [1]
        stq	$10, PROCESSORSTATE_FP($14)	#  [1]
        stq	$11, PROCESSORSTATE_LP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        bis	$1, $31, $27 	# [1-]
        jsr	$26, ($1), 0	# [0di]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        ldq	$13, PROCESSORSTATE_CP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        ldq	$12, PROCESSORSTATE_SP($14)	#  [1]
        ldq	$10, PROCESSORSTATE_FP($14)	#  [1]
        ldq	$11, PROCESSORSTATE_LP($14)	#  [1]
/* Compute proper iCP after FlushCaches resets it. */
	br	$31, ICACHEMISS
        br	$31, G15321	# [1]
.align 3
G15323:
        lda	$2, CoprocessorRegisterFlushCachesForVMA	#  [1-]
        subq	$16, $2, $2 	# [1]
        bne	$2, G15324	# [1]
/* Here if argument CoprocessorRegisterFlushCachesForVMA */
        extll	$17, 0, $17 	# Extract the VMA [0di]
        sll	$17, 1, $1 	# convert continuation to an even pc [2]
/* Convert a halfword address into a CP pointer. */
        srl	$1, CacheLineRShift, $2 	# Get third byte into bottom [2]
        ldq	$4, PROCESSORSTATE_ICACHEBASE($14)	# get the base of the icache [1-]
        lda	$3, -1	#  [0di]
        ldah	$3, 4($3)	#  [1]
        sll	$2, CacheLineLShift, $2 	# Now third byte is zero-shifted [1]
        addq	$1, $2, $2 	# [2]
        and	$2, $3, $2 	# [1]
        sll	$2, 5, $3 	# temp=cpos*32 [1]
        sll	$2, 4, $2 	# cpos=cpos*16 [1]
        addq	$4, $3, $4 	# temp2=base+cpos*32 [1]
        addq	$4, $2, $2 	# cpos=base+cpos*48 [1]
        ldq	$3, CACHELINE_PCDATA($2)	#  [2]
        cmpeq	$1, $3, $3 	# Is this VMA in the cache? [3]
        beq	$3, DCWNOTINCACHE	# No. [1]
        stq	$31, CACHELINE_PCDATA($2)	# Yes, flush it [1]
        stq	$31, CACHELINE_PCDATA+CACHELINESIZE($2)	#  [1]
.align 3
DCWNOTINCACHE:
        br	$31, G15321	# [1]
.align 3
G15324:
        lda	$2, CoprocessorRegisterFlushHiddenArrayRegisters	#  [1-]
        subq	$16, $2, $2 	# [1]
        bne	$2, G15325	# [1]
/* Here if argument CoprocessorRegisterFlushHiddenArrayRegisters */
        extll	$17, 0, $17 	# Get the VMA of the new stack array [0di]
        lda	$8, AutoArrayRegMask	#  [1]
        and	$17, $8, $8 	# [1]
        lda	$7, PROCESSORSTATE_AC0ARRAY($14)	#  [1]
        addq	$7, $8, $7 	# Here is our array register block [1]
        ldq	$8, ARRAYCACHE_ARRAY($7)	# And here is the cached array [2]
        cmpeq	$17, $8, $8 	# t8==1 iff cached array is ours [3]
        beq	$8, ARRAYNOTINCACHE	# [1]
        stq	$31, ARRAYCACHE_ARRAY($7)	# Flush it [1]
.align 3
ARRAYNOTINCACHE:
        br	$31, G15321	# [1]
.align 3
G15325:
/* Here for all other cases */
/* Standard coprocessor register processing */
        ldq	$0, PROCESSORSTATE_COPROCESSORWRITEHOOK($14)	#  [1]
        stq	$13, PROCESSORSTATE_CP($14)	#  [1]
        stq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        stq	$12, PROCESSORSTATE_SP($14)	#  [1]
        stq	$10, PROCESSORSTATE_FP($14)	#  [1]
        stq	$11, PROCESSORSTATE_LP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        bis	$0, $31, $27 	# [1-]
        jsr	$26, ($0), 0	# [0di]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        ldq	$13, PROCESSORSTATE_CP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        ldq	$12, PROCESSORSTATE_SP($14)	#  [1]
        ldq	$10, PROCESSORSTATE_FP($14)	#  [1]
        ldq	$11, PROCESSORSTATE_LP($14)	#  [1]
        beq	$0, CPREADEXC	# J. if CoprocessorWrite exception return [0di]
        br	$31, G15321	# [1]
.align 3
G15326:
.align 3
G15321:
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
UNWINDILLEGALCONTINUATION:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
UNWINDILLEGALCONTROL:
        bis	$31, 0, $20 	# [1]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
UNWINDILLEGALFP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
UNWINDILLEGALLP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
CPWRITEEXC:
        bis	$31, 0, $20 	# [1]
        bis	$31, 84, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoCoprocessorWrite
/* End of Halfword operand from stack instruction - DoCoprocessorWrite */
.align 5
.globl GetRPCC
.ent GetRPCC 2
.align 3
GetRPCC:
	.frame $30, 0, $26
        rpcc	$0		#  [1-]
        sll	$0, 32, $16 	# [0di]
        addq	$0, $16, $16 	# [2]
        srl	$16, 32, $0 	# [1]
        ret	$31, ($26), 1	# [1-]
.end GetRPCC
.align 5
.globl SpinWheels
.ent SpinWheels 1
.align 3
SpinWheels:
	.frame $30, 0, $26
        bis	$31, 1, $16 	# [3]
        sll	$16, 25, $16 	# [1]
.align 3
SPINWHEELAXIS:
        addq	$16, -1, $16 	# [2]
        bgt	$16, SPINWHEELAXIS	# [1]
        ret	$31, ($26), 1	# [1]
.end SpinWheels
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunsubp.as */
