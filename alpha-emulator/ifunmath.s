/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunmath.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Arithmetic. */
.align 5
.globl DoUnaryMinus
.ent DoUnaryMinus 0
/* Halfword operand from stack instruction - DoUnaryMinus */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoUnaryMinusFP
	.globl DoUnaryMinusSP
	.globl DoUnaryMinusLP
	.globl DoUnaryMinusIM
.align 3
DoUnaryMinus:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoUnaryMinusSP"
#endif
.align 3
DoUnaryMinusSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoUnaryMinus	# [0di]
	.byte 0x90
	.asciiz "DoUnaryMinusLP"
#endif
.align 3
DoUnaryMinusLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoUnaryMinus	# [1]
	.byte 0x84
	.asciiz "DoUnaryMinusFP"
#endif
.align 3
DoUnaryMinusFP:	# Entry point for FP relative
.align 3
beginDoUnaryMinus:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$7, CACHELINE_NEXTCP($13)	#  [1]
        ldl	$20, 4($16)	# tag of ARG2 [1]
        ldl	$21, 0($16)	#  [1]
        ldq	$2, PROCESSORSTATE_MOSTNEGATIVEFIXNUM($14)	#  [1]
        lds	$f1, 0($16)	#  [1]
        and	$20, 63, $5 	# Strip off any CDR code bits. [0di]
        cmpeq	$5, TypeFixnum, $4 	# [1]
.align 3
G14611:
        beq	$4, G14607	# [1]
/* Here if argument TypeFixnum */
        subl	$21, $2, $2 	# [0di]
        subl	$31, $21, $17 	# [1]
        beq	$2, UNARYMINUSEXC	# [0di]
        bis	$6, $31, $9 	# [1-]
        stl	$5, 12($12)	# Semi-cheat, we know t5 has CDRNext/TypeFixnum [0di]
        bis	$7, $31, $13 	# [1-]
        stl	$17, 8($12)	# Push the data [0di]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G14607:
        cmpeq	$5, TypeSingleFloat, $4 	# [1-]
.align 3
G14612:
        beq	$4, G14608	# [1]
/* Here if argument TypeSingleFloat */
        subs	$f31, $f1, $f0 	# [1]
        trapb			# Force the trap to occur here [4]
        bis	$6, $31, $9 	# [1]
        stl	$5, 12($12)	# Semi-cheat, we know t5 has CDRNext/TypeSingleFloat [1-]
        bis	$7, $31, $13 	# [0di]
        sts	$f0, 8($12)	# Push the data [1]
        addq	$12, 8, $12 	# [1]
        br	$31, CACHEVALID	# [1-]
.align 3
G14608:
/* Here for all other cases */
.align 3
UNARYMINUSEXC:
        bis	$31, $20, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, UNARYNUMERICEXCEPTION
.align 3
G14606:
#ifdef TRACING
        br	$31, DoUnaryMinusIM	# [1-]
	.byte 0x82
	.asciiz "DoUnaryMinusIM"
#endif
.align 5
.align 3
DoUnaryMinusIM:	# Entry point for IMMEDIATE mode
        subl	$31, $17, $17 	# Negate the 8 bit immediate operand [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeFixnum, $7 	# [0di]
        stl	$17, 8($12)	#  [1-]
        stl	$7, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.end DoUnaryMinus
/* End of Halfword operand from stack instruction - DoUnaryMinus */
.align 5
.globl DoMultiply
.ent DoMultiply 0
/* Halfword operand from stack instruction - DoMultiply */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMultiplyFP
	.globl DoMultiplySP
	.globl DoMultiplyLP
	.globl DoMultiplyIM
.align 3
DoMultiply:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMultiplySP"
#endif
.align 3
DoMultiplySP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoMultiply	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoMultiply	# [0di]
	.byte 0x90
	.asciiz "DoMultiplyLP"
#endif
.align 3
DoMultiplyLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMultiply	# [1]
	.byte 0x84
	.asciiz "DoMultiplyFP"
#endif
.align 3
DoMultiplyFP:	# Entry point for FP relative
.align 3
beginDoMultiply:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lds	$f1, 0($12)	#  [0di]
        extll	$21, 4, $1 	# ARG1 tag [1-]
        ldl	$3, 4($16)	# ARG2 tag [1di]
        addl	$21, $31, $2 	# ARG1 data [1-]
        ldl	$4, 0($16)	# ARG2 data [0di]
        lds	$f2, 0($16)	#  [1]
        and	$1, 63, $22 	# Strip off any CDR code bits. [0di]
        and	$3, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$22, TypeFixnum, $23 	# [1]
.align 3
G14652:
        beq	$23, G14623	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$24, TypeFixnum, $25 	# [0di]
.align 3
G14629:
        beq	$25, G14625	# [1]
/* Here if argument TypeFixnum */
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [0di]
        mullv	$2, $4, $5 	# compute 64-bit result [1-]
        ldq	$7, CACHELINE_NEXTCP($13)	#  [0di]
        trapb			# Force the trap to occur here [21]
        stl	$22, 4($12)	# Semi-cheat, we know temp2 has CDRNext/TypeFixnum [20]
        bis	$6, $31, $9 	# [1-]
        stl	$5, 0($12)	#  [0di]
        bis	$7, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G14625:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14630:
        beq	$25, G14626	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G14613	# [1]
.align 3
G14626:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G14631:
        beq	$25, G14620	# [1]
/* Here if argument TypeDoubleFloat */
        cvtlq	$f1, $f1 	# [3]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G14616	# [1]
.align 3
G14624:
.align 3
G14623:
        cmpeq	$22, TypeSingleFloat, $23 	# [1-]
.align 3
G14653:
        beq	$23, G14632	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$24, TypeSingleFloat, $25 	# [0di]
.align 3
G14638:
        beq	$25, G14634	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G14613:
        muls	$f1, $f2, $f0 	# [2]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1-]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14634:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14639:
        beq	$25, G14635	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G14613	# [1]
.align 3
G14635:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G14640:
        beq	$25, G14620	# [1]
/* Here if argument TypeDoubleFloat */
.align 3
G14616:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        br	$31, G14617	# [1]
.align 3
G14633:
.align 3
G14632:
        cmpeq	$22, TypeDoubleFloat, $23 	# [1-]
.align 3
G14654:
        beq	$23, G14641	# [1]
/* Here if argument TypeDoubleFloat */
        cmpeq	$24, TypeDoubleFloat, $25 	# [0di]
.align 3
G14647:
        beq	$25, G14643	# [1]
/* Here if argument TypeDoubleFloat */
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [0di]
	bsr	$0, FetchDoubleFloat
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [1-]
.align 3
G14617:
        extll	$4, 0, $17 	# [1-]
	bsr	$0, FetchDoubleFloat
        ldt	$f2, PROCESSORSTATE_FP0($14)	#  [0di]
.align 3
G14614:
        mult	$f1, $f2, $f0 	# [3]
        stt	$f0, PROCESSORSTATE_FP0($14)	#  [0di]
	bsr	$0, ConsDoubleFloat
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1-]
        stl	$17, 0($12)	#  [0di]
        stl	$8, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14643:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14648:
        beq	$25, G14644	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G14615:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [1-]
	bsr	$0, FetchDoubleFloat
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [0di]
        br	$31, G14614	# [1]
.align 3
G14644:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14649:
        beq	$25, G14620	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G14615	# [1]
.align 3
G14642:
.align 3
G14641:
/* Here for all other cases */
.align 3
G14619:
.align 3
DOMULOVFL:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G14621	# [1-]
.align 3
G14620:
        bis	$3, $31, $1 	# [1-]
        br	$31, DOMULOVFL	# [0di]
.align 3
G14621:
.align 3
G14622:
#ifdef TRACING
        br	$31, DoMultiplyIM	# [1]
	.byte 0x82
	.asciiz "DoMultiplyIM"
#endif
.align 5
.align 3
DoMultiplyIM:	# Entry point for IMMEDIATE mode
        sll	$17, 56, $17 	# [1-]
        extll	$21, 4, $1 	# [1]
        addl	$21, $31, $2 	# get ARG1 tag/data [1]
        sra	$17, 56, $17 	# [1]
        and	$1, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$24, TypeFixnum, $25 	# [1]
.align 3
G14659:
        beq	$25, G14656	# [1]
/* Here if argument TypeFixnum */
        mulq	$2, $17, $3 	# compute 64-bit result [0di]
        ldq	$4, CACHELINE_NEXTPCDATA($13)	#  [1-]
        addl	$3, $31, $23 	# compute 32-bit sign-extended result [22di]
        ldq	$5, CACHELINE_NEXTCP($13)	#  [1-]
        cmpeq	$3, $23, $23 	# is it the same as the 64-bit result? [0di]
        beq	$23, DOMULOVFL	# if not, we overflowed [1]
        stl	$24, 4($12)	# Semi-cheat, we know temp2 has CDRNext/TypeFixnum [1]
        bis	$4, $31, $9 	# [1-]
        stl	$3, 0($12)	#  [0di]
        bis	$5, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G14656:
/* Here for all other cases */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        bis	$31, $31, $17 	# [1]
        br	$31, beginDoMultiply	# [0di]
.align 3
G14655:
.end DoMultiply
/* End of Halfword operand from stack instruction - DoMultiply */
.align 12
        and	$31, $31, $31 	# [1]
.align 12
.align 5
.globl BinaryArithmeticDivisionPrelude
.ent BinaryArithmeticDivisionPrelude 0
.align 3
BinaryArithmeticDivisionPrelude:
        lda	$30, -8($30)	#  [1]
	.frame $30, 8, $0
        lds	$f1, 0($12)	#  [0di]
        addl	$21, $31, $2 	# ARG1 data [1-]
        ldl	$4, 0($16)	# ARG2 data [0di]
        extll	$21, 4, $1 	# ARG1 tag [1-]
        ldl	$3, 4($16)	# ARG2 tag [0di]
        lds	$f2, 0($16)	#  [1]
        and	$1, 63, $22 	# Strip off any CDR code bits. [1di]
        and	$3, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$22, TypeFixnum, $23 	# [1]
.align 3
G14697:
        beq	$23, G14670	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$24, TypeFixnum, $25 	# [0di]
.align 3
G14676:
        beq	$25, G14672	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f1, $f1 	# [1]
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f1, $f1 	# [5]
        cvtqt	$f2, $f2 	# [1]
.align 3
G14671:
.align 3
G14669:
.align 3
G14660:
        lda	$30, 8($30)	#  [1-]
        ret	$31, ($0), 1	# [0di]
.align 3
G14670:
        cmpeq	$22, TypeSingleFloat, $23 	# [1-]
.align 3
G14698:
        beq	$23, G14677	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$24, TypeSingleFloat, $25 	# [0di]
.align 3
G14683:
        bne	$25, G14660	# [1]
.align 3
G14679:
        cmpeq	$24, TypeFixnum, $25 	# [1]
.align 3
G14684:
        beq	$25, G14680	# [1]
/* Here if argument TypeFixnum */
        bis	$31, $1, $3 	# contagion [0di]
        cvtlq	$f2, $f2 	# [1-]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G14660	# [1]
.align 3
G14680:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G14685:
        beq	$25, G14667	# [1]
/* Here if argument TypeDoubleFloat */
.align 3
G14662:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        br	$31, G14663	# [1]
.align 3
G14678:
.align 3
G14677:
        cmpeq	$22, TypeDoubleFloat, $23 	# [1-]
.align 3
G14699:
        beq	$23, G14686	# [1]
/* Here if argument TypeDoubleFloat */
        cmpeq	$24, TypeDoubleFloat, $25 	# [0di]
.align 3
G14692:
        beq	$25, G14688	# [1]
/* Here if argument TypeDoubleFloat */
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [0di]
        stq	$0, 0($30)	#  [1-]
	bsr	$0, FetchDoubleFloat
        ldq	$0, 0($30)	#  [1]
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [1]
.align 3
G14663:
        extll	$4, 0, $17 	# [1-]
        stq	$0, 0($30)	#  [0di]
	bsr	$0, FetchDoubleFloat
        ldq	$0, 0($30)	#  [1]
        ldt	$f2, PROCESSORSTATE_FP0($14)	#  [1]
        br	$31, G14660	# [1]
.align 3
G14688:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14693:
        beq	$25, G14689	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G14661:
        bis	$31, $1, $3 	# contagion [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [0di]
        stq	$0, 0($30)	#  [1-]
	bsr	$0, FetchDoubleFloat
        ldq	$0, 0($30)	#  [1]
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [1]
        br	$31, G14660	# [1]
.align 3
G14689:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14694:
        beq	$25, G14667	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G14661	# [1]
.align 3
G14687:
.align 3
G14686:
/* Here for all other cases */
.align 3
G14666:
.align 3
G14664:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G14668	# [1-]
.align 3
G14667:
        bis	$3, $31, $1 	# [1-]
        br	$31, G14664	# [0di]
.align 3
G14668:
.align 3
G14672:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14700:
        beq	$25, G14673	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G14660	# [1]
.align 3
G14673:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G14701:
        beq	$25, G14667	# [1]
/* Here if argument TypeDoubleFloat */
        cvtlq	$f1, $f1 	# [3]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G14662	# [1]
.end BinaryArithmeticDivisionPrelude
.align 5
.globl DoQuotient
.ent DoQuotient 0
/* Halfword operand from stack instruction - DoQuotient */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoQuotientFP
	.globl DoQuotientSP
	.globl DoQuotientLP
	.globl DoQuotientIM
.align 3
DoQuotient:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoQuotientIM"
#endif
.align 3
DoQuotientIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoQuotient	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoQuotientSP"
#endif
.align 3
DoQuotientSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoQuotient	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoQuotient	# [0di]
	.byte 0x90
	.asciiz "DoQuotientLP"
#endif
.align 3
DoQuotientLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoQuotient	# [1]
	.byte 0x84
	.asciiz "DoQuotientFP"
#endif
.align 3
DoQuotientFP:	# Entry point for FP relative
.align 3
beginDoQuotient:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
	bsr	$0, BinaryArithmeticDivisionPrelude
        and	$3, 63, $8 	# Strip off any CDR code bits. [1]
        cmpeq	$8, TypeFixnum, $22 	# [1]
.align 3
G14707:
        beq	$22, G14703	# [1]
/* Here if argument TypeFixnum */
        divt	$f1, $f2, $f0 	# [1]
        cvttqvc	$f0, $f0 	# [63]
        cvtqlv	$f0, $f0 	# [6]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
.align 3
G14702:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14703:
        cmpeq	$8, TypeSingleFloat, $22 	# [1-]
.align 3
G14708:
        beq	$22, G14704	# [1]
/* Here if argument TypeSingleFloat */
        divs	$f1, $f2, $f0 	# [1]
        trapb			# Force the trap to occur here [32]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        br	$31, G14702	# [1]
.align 3
G14704:
        cmpeq	$8, TypeDoubleFloat, $22 	# [1-]
.align 3
G14709:
        beq	$22, G14702	# [1]
/* Here if argument TypeDoubleFloat */
        divt	$f1, $f2, $f0 	# [24]
        stt	$f0, PROCESSORSTATE_FP0($14)	#  [1-]
	bsr	$0, ConsDoubleFloat
        bis	$31, TypeDoubleFloat, $8 	# [1]
        stl	$17, 0($12)	#  [1-]
        stl	$8, 4($12)	# write the stack cache [1]
        br	$31, G14702	# [1]
.end DoQuotient
/* End of Halfword operand from stack instruction - DoQuotient */
.align 5
.globl DoRationalQuotient
.ent DoRationalQuotient 0
/* Halfword operand from stack instruction - DoRationalQuotient */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoRationalQuotientFP
	.globl DoRationalQuotientSP
	.globl DoRationalQuotientLP
	.globl DoRationalQuotientIM
.align 3
DoRationalQuotient:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoRationalQuotientIM"
#endif
.align 3
DoRationalQuotientIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoRationalQuotient	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRationalQuotientSP"
#endif
.align 3
DoRationalQuotientSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoRationalQuotient	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoRationalQuotient	# [0di]
	.byte 0x90
	.asciiz "DoRationalQuotientLP"
#endif
.align 3
DoRationalQuotientLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoRationalQuotient	# [1]
	.byte 0x84
	.asciiz "DoRationalQuotientFP"
#endif
.align 3
DoRationalQuotientFP:	# Entry point for FP relative
.align 3
beginDoRationalQuotient:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
	bsr	$0, BinaryArithmeticDivisionPrelude
        and	$3, 63, $8 	# Strip off any CDR code bits. [1]
        cmpeq	$8, TypeFixnum, $22 	# [1]
.align 3
G14715:
        beq	$22, G14711	# [1]
/* Here if argument TypeFixnum */
        divt	$f1, $f2, $f0 	# [42]
        cvttqsvi	$f0, $f0 	# [63]
        cvtqlv	$f0, $f0 	# [6]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
.align 3
G14710:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14711:
        cmpeq	$8, TypeSingleFloat, $22 	# [1-]
.align 3
G14716:
        beq	$22, G14712	# [1]
/* Here if argument TypeSingleFloat */
        divs	$f1, $f2, $f0 	# [1]
        trapb			# Force the trap to occur here [32]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        br	$31, G14710	# [1]
.align 3
G14712:
        cmpeq	$8, TypeDoubleFloat, $22 	# [1-]
.align 3
G14717:
        beq	$22, G14710	# [1]
/* Here if argument TypeDoubleFloat */
        divt	$f1, $f2, $f0 	# [24]
        stt	$f0, PROCESSORSTATE_FP0($14)	#  [1-]
	bsr	$0, ConsDoubleFloat
        bis	$31, TypeDoubleFloat, $8 	# [1]
        stl	$17, 0($12)	#  [1-]
        stl	$8, 4($12)	# write the stack cache [1]
        br	$31, G14710	# [1]
.end DoRationalQuotient
/* End of Halfword operand from stack instruction - DoRationalQuotient */
.align 5
.globl DoFloor
.ent DoFloor 0
/* Halfword operand from stack instruction - DoFloor */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoFloorFP
	.globl DoFloorSP
	.globl DoFloorLP
	.globl DoFloorIM
.align 3
DoFloor:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoFloorIM"
#endif
.align 3
DoFloorIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoFloor	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoFloorSP"
#endif
.align 3
DoFloorSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoFloor	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoFloor	# [0di]
	.byte 0x90
	.asciiz "DoFloorLP"
#endif
.align 3
DoFloorLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoFloor	# [1]
	.byte 0x84
	.asciiz "DoFloorFP"
#endif
.align 3
DoFloorFP:	# Entry point for FP relative
.align 3
beginDoFloor:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
	bsr	$0, BinaryArithmeticDivisionPrelude
        divt	$f1, $f2, $f0 	# [45di]
        cvttqvm	$f0, $f0 	# [63]
        cvtqt	$f0, $f3 	# [6]
        mult	$f3, $f2, $f3 	# [6]
        subt	$f1, $f3, $f3 	# [6]
        cvtqlv	$f0, $f0 	# [1]
        and	$3, 63, $8 	# Strip off any CDR code bits. [0di]
        cmpeq	$8, TypeFixnum, $22 	# [1]
.align 3
G14723:
        beq	$22, G14719	# [1]
/* Here if argument TypeFixnum */
        cvttq	$f3, $f3 	# [3]
        cvtql	$f3, $f3 	# [6]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [1-]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
.align 3
G14718:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14719:
        cmpeq	$8, TypeSingleFloat, $22 	# [1-]
.align 3
G14724:
        beq	$22, G14720	# [1]
/* Here if argument TypeSingleFloat */
        cvtts	$f3, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [0di]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
        br	$31, G14718	# [1-]
.align 3
G14720:
        cmpeq	$8, TypeDoubleFloat, $22 	# [1-]
.align 3
G14725:
        beq	$22, G14718	# [1]
/* Here if argument TypeDoubleFloat */
        trapb			# Force the trap to occur here [1]
        stt	$f3, PROCESSORSTATE_FP0($14)	#  [1]
	bsr	$0, ConsDoubleFloat
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1]
        stl	$17, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, G14718	# [1-]
.end DoFloor
/* End of Halfword operand from stack instruction - DoFloor */
.align 5
.globl DoCeiling
.ent DoCeiling 0
/* Halfword operand from stack instruction - DoCeiling */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoCeilingFP
	.globl DoCeilingSP
	.globl DoCeilingLP
	.globl DoCeilingIM
.align 3
DoCeiling:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoCeilingIM"
#endif
.align 3
DoCeilingIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoCeiling	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoCeilingSP"
#endif
.align 3
DoCeilingSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoCeiling	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoCeiling	# [0di]
	.byte 0x90
	.asciiz "DoCeilingLP"
#endif
.align 3
DoCeilingLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoCeiling	# [1]
	.byte 0x84
	.asciiz "DoCeilingFP"
#endif
.align 3
DoCeilingFP:	# Entry point for FP relative
.align 3
beginDoCeiling:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
	bsr	$0, BinaryArithmeticDivisionPrelude
        cpysn	$f2, $f2, $f2 	# [1]
        divt	$f1, $f2, $f0 	# [1]
        cvttqvm	$f0, $f0 	# [63]
        cvtqt	$f0, $f3 	# [6]
        cpysn	$f3, $f3, $f0 	# [1]
        cvttq	$f0, $f0 	# [1]
        mult	$f3, $f2, $f3 	# [4]
        subt	$f1, $f3, $f3 	# [6]
        cvtqlv	$f0, $f0 	# [1]
        and	$3, 63, $8 	# Strip off any CDR code bits. [1-]
        cmpeq	$8, TypeFixnum, $22 	# [1]
.align 3
G14731:
        beq	$22, G14727	# [1]
/* Here if argument TypeFixnum */
        cvttq	$f3, $f3 	# [2]
        cvtql	$f3, $f3 	# [6]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [1-]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
.align 3
G14726:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14727:
        cmpeq	$8, TypeSingleFloat, $22 	# [1-]
.align 3
G14732:
        beq	$22, G14728	# [1]
/* Here if argument TypeSingleFloat */
        cvtts	$f3, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [0di]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
        br	$31, G14726	# [1-]
.align 3
G14728:
        cmpeq	$8, TypeDoubleFloat, $22 	# [1-]
.align 3
G14733:
        beq	$22, G14726	# [1]
/* Here if argument TypeDoubleFloat */
        trapb			# Force the trap to occur here [1]
        stt	$f3, PROCESSORSTATE_FP0($14)	#  [1]
	bsr	$0, ConsDoubleFloat
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1]
        stl	$17, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, G14726	# [1-]
.end DoCeiling
/* End of Halfword operand from stack instruction - DoCeiling */
.align 5
.globl DoTruncate
.ent DoTruncate 0
/* Halfword operand from stack instruction - DoTruncate */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoTruncateFP
	.globl DoTruncateSP
	.globl DoTruncateLP
	.globl DoTruncateIM
.align 3
DoTruncate:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoTruncateIM"
#endif
.align 3
DoTruncateIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoTruncate	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoTruncateSP"
#endif
.align 3
DoTruncateSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoTruncate	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoTruncate	# [0di]
	.byte 0x90
	.asciiz "DoTruncateLP"
#endif
.align 3
DoTruncateLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoTruncate	# [1]
	.byte 0x84
	.asciiz "DoTruncateFP"
#endif
.align 3
DoTruncateFP:	# Entry point for FP relative
.align 3
beginDoTruncate:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
	bsr	$0, BinaryArithmeticDivisionPrelude
        divt	$f1, $f2, $f0 	# [0di]
        cvttqvc	$f0, $f0 	# [63]
        cvtqt	$f0, $f3 	# [6]
        mult	$f3, $f2, $f3 	# [6]
        subt	$f1, $f3, $f3 	# [6]
        cvtqlv	$f0, $f0 	# [1]
        and	$3, 63, $8 	# Strip off any CDR code bits. [0di]
        cmpeq	$8, TypeFixnum, $22 	# [1]
.align 3
G14748:
        beq	$22, G14744	# [1]
/* Here if argument TypeFixnum */
        cvttq	$f3, $f3 	# [3]
        cvtql	$f3, $f3 	# [6]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [1-]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
.align 3
G14743:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14744:
        cmpeq	$8, TypeSingleFloat, $22 	# [1-]
.align 3
G14749:
        beq	$22, G14745	# [1]
/* Here if argument TypeSingleFloat */
        cvtts	$f3, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [0di]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
        br	$31, G14743	# [1-]
.align 3
G14745:
        cmpeq	$8, TypeDoubleFloat, $22 	# [1-]
.align 3
G14750:
        beq	$22, G14743	# [1]
/* Here if argument TypeDoubleFloat */
        trapb			# Force the trap to occur here [1]
        stt	$f3, PROCESSORSTATE_FP0($14)	#  [1]
	bsr	$0, ConsDoubleFloat
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1]
        stl	$17, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, G14743	# [1-]
.end DoTruncate
/* End of Halfword operand from stack instruction - DoTruncate */
.align 5
.globl DoRound
.ent DoRound 0
/* Halfword operand from stack instruction - DoRound */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoRoundFP
	.globl DoRoundSP
	.globl DoRoundLP
	.globl DoRoundIM
.align 3
DoRound:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoRoundIM"
#endif
.align 3
DoRoundIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoRound	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRoundSP"
#endif
.align 3
DoRoundSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoRound	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoRound	# [0di]
	.byte 0x90
	.asciiz "DoRoundLP"
#endif
.align 3
DoRoundLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoRound	# [1]
	.byte 0x84
	.asciiz "DoRoundFP"
#endif
.align 3
DoRoundFP:	# Entry point for FP relative
.align 3
beginDoRound:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
	bsr	$0, BinaryArithmeticDivisionPrelude
        divt	$f1, $f2, $f0 	# [0di]
        cvttqv	$f0, $f0 	# [63]
        cvtqt	$f0, $f3 	# [6]
        mult	$f3, $f2, $f3 	# [6]
        subt	$f1, $f3, $f3 	# [6]
        cvtqlv	$f0, $f0 	# [1]
        and	$3, 63, $8 	# Strip off any CDR code bits. [0di]
        cmpeq	$8, TypeFixnum, $22 	# [1]
.align 3
G14756:
        beq	$22, G14752	# [1]
/* Here if argument TypeFixnum */
        cvttq	$f3, $f3 	# [3]
        cvtql	$f3, $f3 	# [6]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [1-]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
.align 3
G14751:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14752:
        cmpeq	$8, TypeSingleFloat, $22 	# [1-]
.align 3
G14757:
        beq	$22, G14753	# [1]
/* Here if argument TypeSingleFloat */
        cvtts	$f3, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 12($12)	# write the stack cache [0di]
        sts	$f3, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1]
        br	$31, G14751	# [1-]
.align 3
G14753:
        cmpeq	$8, TypeDoubleFloat, $22 	# [1-]
.align 3
G14758:
        beq	$22, G14751	# [1]
/* Here if argument TypeDoubleFloat */
        trapb			# Force the trap to occur here [1]
        stt	$f3, PROCESSORSTATE_FP0($14)	#  [1]
	bsr	$0, ConsDoubleFloat
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f0, 0($12)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1]
        stl	$17, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, G14751	# [1-]
.end DoRound
/* End of Halfword operand from stack instruction - DoRound */
/* Other arithmetic. */
.align 5
.globl DoMax
.ent DoMax 0
/* Halfword operand from stack instruction - DoMax */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMaxFP
	.globl DoMaxSP
	.globl DoMaxLP
	.globl DoMaxIM
.align 3
DoMax:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoMaxIM"
#endif
.align 3
DoMaxIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoMax	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMaxSP"
#endif
.align 3
DoMaxSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoMax	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoMax	# [0di]
	.byte 0x90
	.asciiz "DoMaxLP"
#endif
.align 3
DoMaxLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMax	# [1]
	.byte 0x84
	.asciiz "DoMaxFP"
#endif
.align 3
DoMaxFP:	# Entry point for FP relative
.align 3
beginDoMax:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lds	$f1, 0($12)	#  [0di]
        extll	$21, 4, $1 	# ARG1 tag [1-]
        ldl	$3, 4($16)	# ARG2 tag [1di]
        addl	$21, $31, $2 	# ARG1 data [1-]
        ldl	$4, 0($16)	# ARG2 data [0di]
        lds	$f2, 0($16)	#  [1]
        and	$1, 63, $22 	# Strip off any CDR code bits. [0di]
        and	$3, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$22, TypeFixnum, $23 	# [1]
.align 3
G14782:
        beq	$23, G14766	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$24, TypeFixnum, $25 	# [0di]
.align 3
G14771:
        beq	$25, G14768	# [1]
/* Here if argument TypeFixnum */
        subq	$2, $4, $5 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        cmovgt	$5, $2, $4 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        stl	$4, 0($12)	# We know temp2 has CDRNext/TypeFixnum [1]
        stl	$22, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14768:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14772:
        beq	$25, G14763	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqs	$f1, $f1 	# [6]
        br	$31, G14760	# [1]
.align 3
G14767:
.align 3
G14766:
        cmpeq	$22, TypeSingleFloat, $23 	# [1-]
.align 3
G14783:
        beq	$23, G14773	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$24, TypeSingleFloat, $25 	# [0di]
.align 3
G14778:
        beq	$25, G14775	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G14760:
        subs	$f1, $f2, $f0 	# [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        fcmovgt	$f0, $f1, $f2 	# [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        trapb			# Force the trap to occur here [3]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f2, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14775:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14779:
        beq	$25, G14763	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqs	$f2, $f2 	# [6]
        br	$31, G14760	# [1]
.align 3
G14774:
.align 3
G14773:
/* Here for all other cases */
.align 3
G14762:
.align 3
G14759:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G14764	# [1-]
.align 3
G14763:
        bis	$3, $31, $1 	# [1-]
        br	$31, G14759	# [0di]
.align 3
G14764:
.align 3
G14765:
.end DoMax
/* End of Halfword operand from stack instruction - DoMax */
.align 5
.globl DoMin
.ent DoMin 0
/* Halfword operand from stack instruction - DoMin */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMinFP
	.globl DoMinSP
	.globl DoMinLP
	.globl DoMinIM
.align 3
DoMin:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoMinIM"
#endif
.align 3
DoMinIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $16 	# sign extend the byte argument. [1-]
        bis	$31, $31, $17 	# [1]
        sra	$16, 56, $16 	# Rest of sign extension [1]
        stl	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoMin	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMinSP"
#endif
.align 3
DoMinSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoMin	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoMin	# [0di]
	.byte 0x90
	.asciiz "DoMinLP"
#endif
.align 3
DoMinLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMin	# [1]
	.byte 0x84
	.asciiz "DoMinFP"
#endif
.align 3
DoMinFP:	# Entry point for FP relative
.align 3
beginDoMin:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lds	$f1, 0($12)	#  [0di]
        extll	$21, 4, $1 	# ARG1 tag [1-]
        ldl	$3, 4($16)	# ARG2 tag [1di]
        addl	$21, $31, $2 	# ARG1 data [1-]
        ldl	$4, 0($16)	# ARG2 data [0di]
        lds	$f2, 0($16)	#  [1]
        and	$1, 63, $22 	# Strip off any CDR code bits. [0di]
        and	$3, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$22, TypeFixnum, $23 	# [1]
.align 3
G14807:
        beq	$23, G14791	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$24, TypeFixnum, $25 	# [0di]
.align 3
G14796:
        beq	$25, G14793	# [1]
/* Here if argument TypeFixnum */
        subq	$2, $4, $5 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        cmovlt	$5, $2, $4 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        stl	$4, 0($12)	# We know temp2 has CDRNext/TypeFixnum [1]
        stl	$22, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14793:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14797:
        beq	$25, G14788	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqs	$f1, $f1 	# [6]
        br	$31, G14785	# [1]
.align 3
G14792:
.align 3
G14791:
        cmpeq	$22, TypeSingleFloat, $23 	# [1-]
.align 3
G14808:
        beq	$23, G14798	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$24, TypeSingleFloat, $25 	# [0di]
.align 3
G14803:
        beq	$25, G14800	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G14785:
        subs	$f1, $f2, $f0 	# [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        fcmovlt	$f0, $f1, $f2 	# [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        trapb			# Force the trap to occur here [3]
        bis	$31, TypeSingleFloat, $8 	# [1]
        stl	$8, 4($12)	# write the stack cache [1-]
        sts	$f2, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14800:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14804:
        beq	$25, G14788	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqs	$f2, $f2 	# [6]
        br	$31, G14785	# [1]
.align 3
G14799:
.align 3
G14798:
/* Here for all other cases */
.align 3
G14787:
.align 3
G14784:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G14789	# [1-]
.align 3
G14788:
        bis	$3, $31, $1 	# [1-]
        br	$31, G14784	# [0di]
.align 3
G14789:
.align 3
G14790:
.end DoMin
/* End of Halfword operand from stack instruction - DoMin */
.align 5
.globl DoMultiplyDouble
.ent DoMultiplyDouble 0
/* Halfword operand from stack instruction - DoMultiplyDouble */
	.globl DoMultiplyDoubleFP
	.globl DoMultiplyDoubleSP
	.globl DoMultiplyDoubleLP
	.globl DoMultiplyDoubleIM
.align 3
DoMultiplyDouble:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoMultiplyDoubleIM"
#endif
.align 3
DoMultiplyDoubleIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G14809:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoMultiplyDouble	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMultiplyDoubleSP"
#endif
.align 3
DoMultiplyDoubleSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoMultiplyDouble	# [0di]
	.byte 0x90
	.asciiz "DoMultiplyDoubleLP"
#endif
.align 3
DoMultiplyDoubleLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoMultiplyDouble	# [1]
	.byte 0x84
	.asciiz "DoMultiplyDoubleFP"
#endif
.align 3
DoMultiplyDoubleFP:	# Entry point for FP relative
.align 3
headDoMultiplyDouble:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoMultiplyDouble:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $2 	# ARG2 tag [3]
        ldl	$3, 0($12)	# ARG1 data, sign extended [0di]
        addl	$16, 0, $4 	# ARG2 data, sign extended [1-]
        ldl	$1, 4($12)	# ARG1 tag [0di]
/* TagType. */
        and	$1, 63, $1 	# Strip CDR code if any. [3]
        subq	$1, TypeFixnum, $1 	# [1]
/* TagType. */
        and	$2, 63, $2 	# Strip CDR code if any. [1]
        mulq	$3, $4, $5 	# Perform the 63 bit multiply. [1]
        subq	$2, TypeFixnum, $2 	# [1]
        bne	$1, MULDEXC	# [0di]
        bne	$2, MULDEXC	# [1]
        extll	$5, 0, $6 	# Get the low 32 bit half. [21di]
        extll	$5, 4, $5 	# Get the high 32 bit half. [1]
        stl	$6, 0($12)	# Put the result back on the stack [0di]
        bis	$31, TypeFixnum, $1 	# [1-]
        stl	$5, 8($12)	# Push high order half [0di]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
MULDEXC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 80, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoMultiplyDouble
/* End of Halfword operand from stack instruction - DoMultiplyDouble */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunmath.as */
