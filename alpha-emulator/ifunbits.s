/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunbits.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Bits. */
.align 5
.globl DoLogand
.ent DoLogand 0
/* Halfword operand from stack instruction - DoLogand */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLogandFP
	.globl DoLogandSP
	.globl DoLogandLP
	.globl DoLogandIM
.align 3
DoLogand:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLogandSP"
#endif
.align 3
DoLogandSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoLogand	# [0di]
	.byte 0x90
	.asciiz "DoLogandLP"
#endif
.align 3
DoLogandLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoLogand	# [1]
	.byte 0x84
	.asciiz "DoLogandFP"
#endif
.align 3
DoLogandFP:	# Entry point for FP relative
.align 3
headDoLogand:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoLogand:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$3, 4($12)	# Get tag from ARG1 [1]
        ldl	$4, 0($12)	# Grab data for ARG1 [1]
        extbl	$16, 4, $1 	# Get tag from ARG2 [1-]
        subq	$3, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15444	# [1]
        subq	$1, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15445	# [1]
/* Here we know that both args are fixnums! */
        and	$4, $16, $4 	# Do the operation [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $31, $31 	# [0]
        extll	$4, 0, $4 	# Strip high bits [1]
        bis	$31, TypeFixnum, $1 	# [1]
        stl	$4, 0($12)	# Push result [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G15444:	# Here if ARG1 not fixnum
        bis	$31, $3, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15445:	# Here if ARG2 not fixnum
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
#ifdef TRACING
        br	$31, DoLogandIM	# [1-]
	.byte 0x82
	.asciiz "DoLogandIM"
#endif
.align 5
.align 3
DoLogandIM:	# Entry point for IMMEDIATE mode
        ldl	$3, 4($12)	# Get tag from ARG1 [1]
        sll	$17, 56, $17 	# [0di]
        ldl	$4, 0($12)	# Grab data for ARG1 [1-]
        sra	$17, 56, $17 	# [1di]
        subq	$3, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15446	# [1]
/* Here we know that both args are fixnums! */
        and	$4, $17, $4 	# Do the operation [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $31, $31 	# [0]
        extll	$4, 0, $4 	# Strip high bits [1]
        bis	$31, TypeFixnum, $1 	# [1]
        stl	$4, 0($12)	# Push result [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G15446:	# Here if ARG1 not fixnum
        bis	$31, TypeFixnum, $16 	# [1-]
        extll	$17, 0, $17 	# [1]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $3, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.end DoLogand
/* End of Halfword operand from stack instruction - DoLogand */
.align 5
.globl DoLogior
.ent DoLogior 0
/* Halfword operand from stack instruction - DoLogior */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLogiorFP
	.globl DoLogiorSP
	.globl DoLogiorLP
	.globl DoLogiorIM
.align 3
DoLogior:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLogiorSP"
#endif
.align 3
DoLogiorSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoLogior	# [0di]
	.byte 0x90
	.asciiz "DoLogiorLP"
#endif
.align 3
DoLogiorLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoLogior	# [1]
	.byte 0x84
	.asciiz "DoLogiorFP"
#endif
.align 3
DoLogiorFP:	# Entry point for FP relative
.align 3
headDoLogior:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoLogior:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$3, 4($12)	# Get tag from ARG1 [1]
        ldl	$4, 0($12)	# Grab data for ARG1 [1]
        extbl	$16, 4, $1 	# Get tag from ARG2 [1-]
        subq	$3, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15447	# [1]
        subq	$1, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15448	# [1]
/* Here we know that both args are fixnums! */
        bis	$4, $16, $4 	# Do the operation [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $31, $31 	# [0]
        extll	$4, 0, $4 	# Strip high bits [1]
        bis	$31, TypeFixnum, $1 	# [1]
        stl	$4, 0($12)	# Push result [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G15447:	# Here if ARG1 not fixnum
        bis	$31, $3, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15448:	# Here if ARG2 not fixnum
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
#ifdef TRACING
        br	$31, DoLogiorIM	# [1-]
	.byte 0x82
	.asciiz "DoLogiorIM"
#endif
.align 5
.align 3
DoLogiorIM:	# Entry point for IMMEDIATE mode
        ldl	$3, 4($12)	# Get tag from ARG1 [1]
        sll	$17, 56, $17 	# [0di]
        ldl	$4, 0($12)	# Grab data for ARG1 [1-]
        sra	$17, 56, $17 	# [1di]
        subq	$3, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15449	# [1]
/* Here we know that both args are fixnums! */
        bis	$4, $17, $4 	# Do the operation [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $31, $31 	# [0]
        extll	$4, 0, $4 	# Strip high bits [1]
        bis	$31, TypeFixnum, $1 	# [1]
        stl	$4, 0($12)	# Push result [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G15449:	# Here if ARG1 not fixnum
        bis	$31, TypeFixnum, $16 	# [1-]
        extll	$17, 0, $17 	# [1]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $3, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.end DoLogior
/* End of Halfword operand from stack instruction - DoLogior */
.align 5
.globl DoLogxor
.ent DoLogxor 0
/* Halfword operand from stack instruction - DoLogxor */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLogxorFP
	.globl DoLogxorSP
	.globl DoLogxorLP
	.globl DoLogxorIM
.align 3
DoLogxor:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLogxorSP"
#endif
.align 3
DoLogxorSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoLogxor	# [0di]
	.byte 0x90
	.asciiz "DoLogxorLP"
#endif
.align 3
DoLogxorLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoLogxor	# [1]
	.byte 0x84
	.asciiz "DoLogxorFP"
#endif
.align 3
DoLogxorFP:	# Entry point for FP relative
.align 3
headDoLogxor:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoLogxor:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$3, 4($12)	# Get tag from ARG1 [1]
        ldl	$4, 0($12)	# Grab data for ARG1 [1]
        extbl	$16, 4, $1 	# Get tag from ARG2 [1-]
        subq	$3, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15450	# [1]
        subq	$1, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15451	# [1]
/* Here we know that both args are fixnums! */
        xor	$4, $16, $4 	# Do the operation [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $31, $31 	# [0]
        extll	$4, 0, $4 	# Strip high bits [1]
        bis	$31, TypeFixnum, $1 	# [1]
        stl	$4, 0($12)	# Push result [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G15450:	# Here if ARG1 not fixnum
        bis	$31, $3, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15451:	# Here if ARG2 not fixnum
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
#ifdef TRACING
        br	$31, DoLogxorIM	# [1-]
	.byte 0x82
	.asciiz "DoLogxorIM"
#endif
.align 5
.align 3
DoLogxorIM:	# Entry point for IMMEDIATE mode
        ldl	$3, 4($12)	# Get tag from ARG1 [1]
        sll	$17, 56, $17 	# [0di]
        ldl	$4, 0($12)	# Grab data for ARG1 [1-]
        sra	$17, 56, $17 	# [1di]
        subq	$3, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, G15452	# [1]
/* Here we know that both args are fixnums! */
        xor	$4, $17, $4 	# Do the operation [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $31, $31 	# [0]
        extll	$4, 0, $4 	# Strip high bits [1]
        bis	$31, TypeFixnum, $1 	# [1]
        stl	$4, 0($12)	# Push result [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G15452:	# Here if ARG1 not fixnum
        bis	$31, TypeFixnum, $16 	# [1-]
        extll	$17, 0, $17 	# [1]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $3, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.end DoLogxor
/* End of Halfword operand from stack instruction - DoLogxor */
.align 5
.globl DoAsh
.ent DoAsh 0
/* Halfword operand from stack instruction - DoAsh */
	.globl DoAshFP
	.globl DoAshSP
	.globl DoAshLP
	.globl DoAshIM
.align 3
DoAsh:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoAshIM"
#endif
.align 3
DoAshIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G15466:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoAsh	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAshSP"
#endif
.align 3
DoAshSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAsh	# [0di]
	.byte 0x90
	.asciiz "DoAshLP"
#endif
.align 3
DoAshLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAsh	# [1]
	.byte 0x84
	.asciiz "DoAshFP"
#endif
.align 3
DoAshFP:	# Entry point for FP relative
.align 3
headDoAsh:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAsh:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$19, 0($12)	# Get ARG1. [1]
        ldl	$18, 4($12)	#  [1]
        extll	$19, 0, $19 	# [2-]
        srl	$16, 32, $17 	# Get ARG2's tag. [1]
        addl	$16, $31, $16 	# Sign extended the rotation amount. [1]
        and	$17, 63, $1 	# Strip off any CDR code bits. [1]
        and	$18, 63, $3 	# Strip off any CDR code bits. [1]
        cmpeq	$1, TypeFixnum, $2 	# [1]
.align 3
G15465:
        beq	$2, G15458	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$3, TypeFixnum, $4 	# [0di]
.align 3
G15462:
        beq	$4, G15455	# [1]
/* Here if argument TypeFixnum */
        beq	$19, ZERASH	# B. if ash of zero -- trivial case [1]
        ble	$16, NEGASH	# B. if negative ash. [1]
        addl	$19, $31, $19 	# Sign extend ARG1 before shifting. [0di]
        subq	$16, 32, $20 	# [1]
        bgt	$20, ASHOVEXC	# [1]
        sll	$19, $16, $20 	# Shift Left [1]
        xor	$19, $20, $21 	# [2]
        srl	$21, 31, $21 	# arg6<0>=1 if overflow, 0 otherwise [1]
/* TagType. */
        and	$17, 63, $17 	# [1]
        bne	$21, ASHOVEXC	# J. if overflow [1-]
        stl	$20, 0($12)	#  [1]
        stl	$17, 4($12)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
NEGASH:
        subq	$31, $16, $16 	# [1-]
        addl	$19, $31, $19 	# Sign extend ARG1 before shifting. [1]
        sra	$19, $16, $20 	# Shift Right [1]
/* TagType. */
        and	$17, 63, $17 	# [1]
        stl	$20, 0($12)	#  [1-]
        stl	$17, 4($12)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
ZERASH:
        bis	$31, TypeFixnum, $20 	# [1-]
        stl	$19, 0($12)	#  [0di]
        stl	$20, 4($12)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15459:
.align 3
G15458:
/* Here for all other cases */
.align 3
G15454:
        extll	$16, 0, $16 	# [1-]
/* SetTag. */
        sll	$17, 32, $2 	# [1]
        bis	$16, $2, $2 	# [2]
        bis	$31, $17, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G15456	# [0di]
.align 3
G15455:
        extll	$16, 0, $16 	# [1-]
/* SetTag. */
        sll	$17, 32, $2 	# [1]
        bis	$16, $2, $2 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15456:
.align 3
G15457:
.align 3
ASHOVEXC:
        extll	$16, 0, $16 	# [1]
/* SetTag. */
        sll	$17, 32, $1 	# [1]
        bis	$16, $1, $1 	# [2]
        bis	$31, $17, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.end DoAsh
/* End of Halfword operand from stack instruction - DoAsh */
.align 5
.globl DoRot
.ent DoRot 0
/* Halfword operand from stack instruction - DoRot */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoRotFP
	.globl DoRotSP
	.globl DoRotLP
	.globl DoRotIM
.align 3
DoRot:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRotSP"
#endif
.align 3
DoRotSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDoRot	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoRot	# [0di]
	.byte 0x90
	.asciiz "DoRotLP"
#endif
.align 3
DoRotLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoRot	# [1]
	.byte 0x84
	.asciiz "DoRotFP"
#endif
.align 3
DoRotFP:	# Entry point for FP relative
.align 3
beginDoRot:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
.align 3
G15468:
        extll	$21, 4, $4 	# Arg1 on the stack [1]
        ldq	$7, CACHELINE_NEXTPCDATA($13)	#  [0di]
        extll	$21, 0, $1 	# Arg1 on the stack [1-]
        ldl	$5, 4($16)	# Arg2 from operand [0di]
        and	$4, 63, $4 	# Strip CDR code if any. [1-]
        ldl	$2, 0($16)	# Arg2 from operand [0di]
        subq	$4, TypeFixnum, $4 	# [1-]
        ldq	$8, CACHELINE_NEXTCP($13)	#  [0di]
        and	$5, 63, $5 	# Strip CDR code if any. [1-]
        bne	$4, G15467	# [0di]
        extll	$2, 0, $2 	# [1-]
        subq	$5, TypeFixnum, $5 	# [1]
.align 3
G15469:
        bne	$5, G15467	# [1]
        and	$2, 31, $2 	# Get low 5 bits of the rotation [0di]
        sll	$1, $2, $3 	# Shift left to get new high bits [1]
        extll	$3, 4, $6 	# Get new low bits [2]
        bis	$3, $6, $3 	# Glue two parts of shifted operand together [2]
.align 3
G15470:
        bis	$7, $31, $9 	# [1]
        stl	$3, 0($12)	# Put the result back on the stack [0di]
        bis	$8, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
#ifdef TRACING
        br	$31, DoRotIM	# [1]
	.byte 0x82
	.asciiz "DoRotIM"
#endif
.align 5
.align 3
DoRotIM:	# Entry point for IMMEDIATE mode
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        br	$31, G15468	# [1-]
.align 3
G15467:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 80, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoRot
/* End of Halfword operand from stack instruction - DoRot */
.align 5
.globl DoLsh
.ent DoLsh 0
/* Halfword operand from stack instruction - DoLsh */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLshFP
	.globl DoLshSP
	.globl DoLshLP
	.globl DoLshIM
.align 3
DoLsh:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLshSP"
#endif
.align 3
DoLshSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDoLsh	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoLsh	# [0di]
	.byte 0x90
	.asciiz "DoLshLP"
#endif
.align 3
DoLshLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoLsh	# [1]
	.byte 0x84
	.asciiz "DoLshFP"
#endif
.align 3
DoLshFP:	# Entry point for FP relative
.align 3
beginDoLsh:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
.align 3
G15472:
        extll	$21, 4, $4 	# Arg1 on the stack [1]
        ldq	$7, CACHELINE_NEXTPCDATA($13)	#  [0di]
        extll	$21, 0, $1 	# Arg1 on the stack [1-]
        ldl	$5, 4($16)	# Arg2 from operand [0di]
        and	$4, 63, $4 	# Strip CDR code if any. [1-]
        ldl	$2, 0($16)	# Arg2 from operand [0di]
        subq	$4, TypeFixnum, $4 	# [1-]
        ldq	$8, CACHELINE_NEXTCP($13)	#  [0di]
        and	$5, 63, $5 	# Strip CDR code if any. [1-]
        bne	$4, G15471	# [0di]
        subq	$5, TypeFixnum, $5 	# [1-]
.align 3
G15473:
        bne	$5, G15471	# [1]
        blt	$2, NEGLSH	# B. if negative lsh. [1]
        subq	$2, 32, $3 	# [1-]
        bge	$3, RETURNZERO	# [1]
        sll	$1, $2, $3 	# Shift Left [1]
        br	$31, LSHDONE	# [0di]
.align 3
NEGLSH:
        subq	$31, $2, $2 	# [1-]
        subq	$2, 32, $3 	# [1]
        bge	$3, RETURNZERO	# [1]
        srl	$1, $2, $3 	# Shift Right [1]
        br	$31, LSHDONE	# [1-]
.align 3
RETURNZERO:
        bic	$3, $3, $3 	# [1-]
.align 3
LSHDONE:
.align 3
G15474:
        bis	$7, $31, $9 	# [1]
        stl	$3, 0($12)	# Put the result back on the stack [0di]
        bis	$8, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
#ifdef TRACING
        br	$31, DoLshIM	# [1]
	.byte 0x82
	.asciiz "DoLshIM"
#endif
.align 5
.align 3
DoLshIM:	# Entry point for IMMEDIATE mode
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G15475:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        br	$31, G15472	# [0di]
.align 3
G15471:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 80, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoLsh
/* End of Halfword operand from stack instruction - DoLsh */
.align 5
.globl Do32BitPlus
.ent Do32BitPlus 0
/* Halfword operand from stack instruction - Do32BitPlus */
/* arg2 has the preloaded 8 bit operand. */
	.globl Do32BitPlusFP
	.globl Do32BitPlusSP
	.globl Do32BitPlusLP
	.globl Do32BitPlusIM
.align 3
Do32BitPlus:
#ifdef TRACING
	.byte 0x88
	.asciiz "Do32BitPlusSP"
#endif
.align 3
Do32BitPlusSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDo32BitPlus	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDo32BitPlus	# [0di]
	.byte 0x90
	.asciiz "Do32BitPlusLP"
#endif
.align 3
Do32BitPlusLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDo32BitPlus	# [1]
	.byte 0x84
	.asciiz "Do32BitPlusFP"
#endif
.align 3
Do32BitPlusFP:	# Entry point for FP relative
.align 3
beginDo32BitPlus:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
.align 3
G15477:
        extll	$21, 4, $4 	# Arg1 on the stack [1]
        ldq	$7, CACHELINE_NEXTPCDATA($13)	#  [0di]
        extll	$21, 0, $1 	# Arg1 on the stack [1-]
        ldl	$5, 4($16)	# Arg2 from operand [0di]
        and	$4, 63, $4 	# Strip CDR code if any. [1-]
        ldl	$2, 0($16)	# Arg2 from operand [0di]
        subq	$4, TypeFixnum, $4 	# [1-]
        ldq	$8, CACHELINE_NEXTCP($13)	#  [0di]
        and	$5, 63, $5 	# Strip CDR code if any. [1-]
        bne	$4, G15476	# [0di]
        extll	$2, 0, $2 	# [1-]
        subq	$5, TypeFixnum, $5 	# [1]
.align 3
G15478:
        bne	$5, G15476	# [1]
        addq	$1, $2, $3 	# Perform the 32 bit Add. [0di]
.align 3
G15479:
        bis	$7, $31, $9 	# [1]
        stl	$3, 0($12)	# Put the result back on the stack [0di]
        bis	$8, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
#ifdef TRACING
        br	$31, Do32BitPlusIM	# [1]
	.byte 0x82
	.asciiz "Do32BitPlusIM"
#endif
.align 5
.align 3
Do32BitPlusIM:	# Entry point for IMMEDIATE mode
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        br	$31, G15477	# [1-]
.align 3
G15476:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 80, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end Do32BitPlus
/* End of Halfword operand from stack instruction - Do32BitPlus */
.align 5
.globl Do32BitDifference
.ent Do32BitDifference 0
/* Halfword operand from stack instruction - Do32BitDifference */
/* arg2 has the preloaded 8 bit operand. */
	.globl Do32BitDifferenceFP
	.globl Do32BitDifferenceSP
	.globl Do32BitDifferenceLP
	.globl Do32BitDifferenceIM
.align 3
Do32BitDifference:
#ifdef TRACING
	.byte 0x88
	.asciiz "Do32BitDifferenceSP"
#endif
.align 3
Do32BitDifferenceSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDo32BitDifference	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDo32BitDifference	# [0di]
	.byte 0x90
	.asciiz "Do32BitDifferenceLP"
#endif
.align 3
Do32BitDifferenceLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDo32BitDifference	# [1]
	.byte 0x84
	.asciiz "Do32BitDifferenceFP"
#endif
.align 3
Do32BitDifferenceFP:	# Entry point for FP relative
.align 3
beginDo32BitDifference:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
.align 3
G15481:
        extll	$21, 4, $4 	# Arg1 on the stack [1]
        ldq	$7, CACHELINE_NEXTPCDATA($13)	#  [0di]
        extll	$21, 0, $1 	# Arg1 on the stack [1-]
        ldl	$5, 4($16)	# Arg2 from operand [0di]
        and	$4, 63, $4 	# Strip CDR code if any. [1-]
        ldl	$2, 0($16)	# Arg2 from operand [0di]
        subq	$4, TypeFixnum, $4 	# [1-]
        ldq	$8, CACHELINE_NEXTCP($13)	#  [0di]
        and	$5, 63, $5 	# Strip CDR code if any. [1-]
        bne	$4, G15480	# [0di]
        extll	$2, 0, $2 	# [1-]
        subq	$5, TypeFixnum, $5 	# [1]
.align 3
G15482:
        bne	$5, G15480	# [1]
        subq	$1, $2, $3 	# Perform the 32 bit Difference. [0di]
.align 3
G15483:
        bis	$7, $31, $9 	# [1]
        stl	$3, 0($12)	# Put the result back on the stack [0di]
        bis	$8, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
#ifdef TRACING
        br	$31, Do32BitDifferenceIM	# [1]
	.byte 0x82
	.asciiz "Do32BitDifferenceIM"
#endif
.align 5
.align 3
Do32BitDifferenceIM:	# Entry point for IMMEDIATE mode
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        br	$31, G15481	# [1-]
.align 3
G15480:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 80, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end Do32BitDifference
/* End of Halfword operand from stack instruction - Do32BitDifference */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunbits.as */
