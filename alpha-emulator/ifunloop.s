/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunloop.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Branch and loop instructions. */
.align 5
.globl DoBranchTrueElseNoPop
.ent DoBranchTrueElseNoPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueElseNoPop */
	.globl DoBranchTrueElseNoPopFP
	.globl DoBranchTrueElseNoPopSP
	.globl DoBranchTrueElseNoPopLP
	.globl DoBranchTrueElseNoPopIM
.align 3
DoBranchTrueElseNoPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueElseNoPop"
#endif
.align 3
DoBranchTrueElseNoPopIM:
.align 3
DoBranchTrueElseNoPopSP:
.align 3
DoBranchTrueElseNoPopLP:
.align 3
DoBranchTrueElseNoPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, NEXTINSTRUCTION	# [1]
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueElseNoPop
/* End of Halfword operand from stack instruction - DoBranchTrueElseNoPop */
.align 5
.globl DoBranchTrueElseExtraPop
.ent DoBranchTrueElseExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueElseExtraPop */
	.globl DoBranchTrueElseExtraPopFP
	.globl DoBranchTrueElseExtraPopSP
	.globl DoBranchTrueElseExtraPopLP
	.globl DoBranchTrueElseExtraPopIM
.align 3
DoBranchTrueElseExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueElseExtraPop"
#endif
.align 3
DoBranchTrueElseExtraPopIM:
.align 3
DoBranchTrueElseExtraPopSP:
.align 3
DoBranchTrueElseExtraPopLP:
.align 3
DoBranchTrueElseExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, DoBrElsePopExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 16, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrElsePopExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueElseExtraPop
/* End of Halfword operand from stack instruction - DoBranchTrueElseExtraPop */
.align 5
.globl DoBranchFalseElseExtraPop
.ent DoBranchFalseElseExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseElseExtraPop */
	.globl DoBranchFalseElseExtraPopFP
	.globl DoBranchFalseElseExtraPopSP
	.globl DoBranchFalseElseExtraPopLP
	.globl DoBranchFalseElseExtraPopIM
.align 3
DoBranchFalseElseExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseElseExtraPop"
#endif
.align 3
DoBranchFalseElseExtraPopIM:
.align 3
DoBranchFalseElseExtraPopSP:
.align 3
DoBranchFalseElseExtraPopLP:
.align 3
DoBranchFalseElseExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, DoBrnElsePopExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 16, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrnElsePopExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseElseExtraPop
/* End of Halfword operand from stack instruction - DoBranchFalseElseExtraPop */
.align 5
.globl DoBranchFalseExtraPop
.ent DoBranchFalseExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseExtraPop */
	.globl DoBranchFalseExtraPopFP
	.globl DoBranchFalseExtraPopSP
	.globl DoBranchFalseExtraPopLP
	.globl DoBranchFalseExtraPopIM
.align 3
DoBranchFalseExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseExtraPop"
#endif
.align 3
DoBranchFalseExtraPopIM:
.align 3
DoBranchFalseExtraPopSP:
.align 3
DoBranchFalseExtraPopLP:
.align 3
DoBranchFalseExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, DoBrnPopElsePopExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 16, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrnPopElsePopExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 16, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseExtraPop
/* End of Halfword operand from stack instruction - DoBranchFalseExtraPop */
.align 5
.globl DoLoopDecrementTos
.ent DoLoopDecrementTos 0
/* Halfword 10 bit immediate instruction - DoLoopDecrementTos */
	.globl DoLoopDecrementTosFP
	.globl DoLoopDecrementTosSP
	.globl DoLoopDecrementTosLP
	.globl DoLoopDecrementTosIM
.align 3
DoLoopDecrementTos:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoLoopDecrementTos"
#endif
.align 3
DoLoopDecrementTosIM:
.align 3
DoLoopDecrementTosSP:
.align 3
DoLoopDecrementTosLP:
.align 3
DoLoopDecrementTosFP:
        sra	$18, 48, $16 	# [1-]
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# [1]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [1-]
#endif
        extll	$21, 0, $2 	# [0di]
        subq	$1, TypeFixnum, $3 	# [1]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, G14298	# [1]
        subl	$2, 1, $3 	# [1]
        cmplt	$3, $2, $4 	# [1]
        beq	$4, G14300	# [1]
        bis	$31, TypeFixnum, $6 	# [1-]
        stl	$3, 0($12)	#  [0di]
        stl	$6, 4($12)	# write the stack cache [1]
        ble	$3, NEXTINSTRUCTION	# [1]
/* Here if branch taken. */
        addq	$9, $16, $9 	# Update the PC in halfwords [1-]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.align 3
G14298:
        subq	$1, TypeFixnum, $3 	# [1-]
        and	$3, 56, $3 	# Strip CDR code, low bits [1]
        bne	$3, G14299	# [1]
.align 3
G14300:
        addq	$9, $16, $20 	# Compute next-pc [1-]
        bis	$31, 1, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LOOPEXCEPTION
.align 3
G14299:
        bis	$31, 0, $20 	# [1]
        bis	$31, 81, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoLoopDecrementTos
/* End of Halfword operand from stack instruction - DoLoopDecrementTos */
.align 5
.globl DoLoopIncrementTosLessThan
.ent DoLoopIncrementTosLessThan 0
/* Halfword 10 bit immediate instruction - DoLoopIncrementTosLessThan */
	.globl DoLoopIncrementTosLessThanFP
	.globl DoLoopIncrementTosLessThanSP
	.globl DoLoopIncrementTosLessThanLP
	.globl DoLoopIncrementTosLessThanIM
.align 3
DoLoopIncrementTosLessThan:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoLoopIncrementTosLessThan"
#endif
.align 3
DoLoopIncrementTosLessThanIM:
.align 3
DoLoopIncrementTosLessThanSP:
.align 3
DoLoopIncrementTosLessThanLP:
.align 3
DoLoopIncrementTosLessThanFP:
        sra	$18, 48, $16 	# [1]
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# [1]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [1-]
#endif
        extll	$21, 0, $2 	# [0di]
        subq	$1, TypeFixnum, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G14301	# [1]
        ldl	$4, -8($12)	# Get arg1. [0di]
        ldl	$3, -4($12)	#  [1]
        extll	$4, 0, $4 	# [2di]
        subq	$3, TypeFixnum, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G14302	# [1]
        addl	$2, 1, $5 	# [1]
        cmple	$2, $5, $6 	# [1]
        beq	$6, G14303	# [1]
        bis	$31, TypeFixnum, $6 	# [1]
        stl	$5, 0($12)	#  [0di]
        stl	$6, 4($12)	# write the stack cache [1]
        cmple	$5, $4, $6 	# [1]
        beq	$6, NEXTINSTRUCTION	# [1]
/* Here if branch taken. */
.align 3
G14305:
        addq	$9, $16, $9 	# Update the PC in halfwords [1-]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.align 3
G14301:
        subq	$1, TypeFixnum, $5 	# [1-]
        and	$5, 56, $5 	# Strip CDR code, low bits [1]
        bne	$5, G14304	# [1]
.align 3
G14302:
        subq	$3, TypeFixnum, $5 	# [1]
        and	$5, 56, $5 	# Strip CDR code, low bits [1]
        bne	$5, G14304	# [1]
.align 3
G14303:
        addq	$9, $16, $20 	# Compute next-pc [1-]
        bis	$31, 1, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LOOPEXCEPTION
.align 3
G14304:
        bis	$31, 0, $20 	# [1]
        bis	$31, 16, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoLoopIncrementTosLessThan
/* End of Halfword operand from stack instruction - DoLoopIncrementTosLessThan */
.align 5
.globl DoBranchTrueExtraPop
.ent DoBranchTrueExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueExtraPop */
	.globl DoBranchTrueExtraPopFP
	.globl DoBranchTrueExtraPopSP
	.globl DoBranchTrueExtraPopLP
	.globl DoBranchTrueExtraPopIM
.align 3
DoBranchTrueExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueExtraPop"
#endif
.align 3
DoBranchTrueExtraPopIM:
.align 3
DoBranchTrueExtraPopSP:
.align 3
DoBranchTrueExtraPopLP:
.align 3
DoBranchTrueExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, DoBrPopElsePopExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 16, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrPopElsePopExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 16, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueExtraPop
/* End of Halfword operand from stack instruction - DoBranchTrueExtraPop */
.align 5
.globl DoBranchTrueAndNoPopElseNoPopExtraPop
.ent DoBranchTrueAndNoPopElseNoPopExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPopElseNoPopExtraPop */
	.globl DoBranchTrueAndNoPopElseNoPopExtraPopFP
	.globl DoBranchTrueAndNoPopElseNoPopExtraPopSP
	.globl DoBranchTrueAndNoPopElseNoPopExtraPopLP
	.globl DoBranchTrueAndNoPopElseNoPopExtraPopIM
.align 3
DoBranchTrueAndNoPopElseNoPopExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueAndNoPopElseNoPopExtraPop"
#endif
.align 3
DoBranchTrueAndNoPopElseNoPopExtraPopIM:
.align 3
DoBranchTrueAndNoPopElseNoPopExtraPopSP:
.align 3
DoBranchTrueAndNoPopElseNoPopExtraPopLP:
.align 3
DoBranchTrueAndNoPopElseNoPopExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, DoBrExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueAndNoPopElseNoPopExtraPop
/* End of Halfword operand from stack instruction - DoBranchTrueAndNoPopElseNoPopExtraPop */
.align 5
.globl DoBranchFalseAndNoPopElseNoPopExtraPop
.ent DoBranchFalseAndNoPopElseNoPopExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPopElseNoPopExtraPop */
	.globl DoBranchFalseAndNoPopElseNoPopExtraPopFP
	.globl DoBranchFalseAndNoPopElseNoPopExtraPopSP
	.globl DoBranchFalseAndNoPopElseNoPopExtraPopLP
	.globl DoBranchFalseAndNoPopElseNoPopExtraPopIM
.align 3
DoBranchFalseAndNoPopElseNoPopExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseAndNoPopElseNoPopExtraPop"
#endif
.align 3
DoBranchFalseAndNoPopElseNoPopExtraPopIM:
.align 3
DoBranchFalseAndNoPopElseNoPopExtraPopSP:
.align 3
DoBranchFalseAndNoPopElseNoPopExtraPopLP:
.align 3
DoBranchFalseAndNoPopElseNoPopExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, DoBrnExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrnExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseAndNoPopElseNoPopExtraPop
/* End of Halfword operand from stack instruction - DoBranchFalseAndNoPopElseNoPopExtraPop */
.align 5
.globl BranchException
.ent BranchException 0
.align 3
BranchException:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 24, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end BranchException
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunloop.as */
