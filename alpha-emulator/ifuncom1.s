/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuncom1.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* The most commonly used instructions, part 1.  */
.align 5
.globl DoPush
.ent DoPush 0
/* Halfword operand from stack instruction - DoPush */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPushFP
	.globl DoPushSP
	.globl DoPushLP
	.globl DoPushIM
.align 3
DoPush:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPushSP"
#endif
.align 3
DoPushSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoPush	# [0di]
	.byte 0x90
	.asciiz "DoPushLP"
#endif
.align 3
DoPushLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoPush	# [1]
	.byte 0x84
	.asciiz "DoPushFP"
#endif
.align 3
DoPushFP:	# Entry point for FP relative
.align 3
beginDoPush:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        addq	$12, 8, $12 	# Push the new value [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        ldl	$1, 4($16)	# Get the tag/data [1]
        ldl	$2, 0($16)	#  [1]
        stl	$2, 0($12)	# Store the data word [1]
.align 3
G13228:
/* TagType. */
        and	$1, 63, $1 	# make it CDR NEXT [1-]
        stl	$1, 4($12)	# Store the TAG - this *DOES* dual issue! [0di]
.end DoPush
/* End of Halfword operand from stack instruction - DoPush */
.align 5
.globl nextInstruction
.ent nextInstruction 0
.align 3
nextInstruction:
.align 3
CACHEVALID:
        ldq	$18, CACHELINE_INSTRUCTION($13)	# Grab the instruction/operand while stalled [1]
        lda	$16, 0($10)	# Assume FP mode [0di]
        ldq	$2, CACHELINE_PCDATA($13)	# Get the PC to check cache hit. [1-]
        lda	$19, -8($12)	# SP-pop mode constant [0di]
.align 3
CONTINUECURRENTINSTRUCTION:
        ldq	$3, CACHELINE_CODE($13)	# Instruction handler [1-]
        lda	$20, -2040($12)	# SP mode constant [0di]
        stq	$12, PROCESSORSTATE_RESTARTSP($14)	# Need this in case we take a trap [1-]
        extbl	$18, 5, $4 	# Get the mode bits [0di]
        subq	$2, $9, $2 	# check for HIT. [1]
        ldq	$21, 0($12)	# Load TOS in free di slot [0di]
        extbl	$18, 4, $17 	# Extract (8-bit, unsigned) operand [1-]
        bne	$2, TAKEICACHEMISS	# PC didn't match, take a cache miss [0di]
        cmovlbs	$4, $11, $16 	# LP or Immediate mode [1-]
#ifdef TRACING
/* Update the instruction count. */
        ldq	$4, PROCESSORSTATE_INSTRUCTION_COUNT($14)	#  [1]
        subq	$4, 1, $4 	# Decrement the instruction count. [3]
        bne	$4, G13282	# J. if not reached stop point. [1]
        bis	$31, $31, $31 	# put a breakpoint here to catch stops [0]
.align 3
G13282:
        stq	$4, PROCESSORSTATE_INSTRUCTION_COUNT($14)	#  [1-]
/* Trace instructions if requested. */
        ldq	$4, PROCESSORSTATE_TRACE_HOOK($14)	#  [1]
        beq	$4, G13287	# J. if not tracing. [3]
/* Record an instruction trace entry */
        ldl	$5, TRACEDATA_RECORDING_P($4)	#  [0di]
        ldq	$6, TRACEDATA_START_PC($4)	#  [1]
        bne	$5, G13283	# Jump if recording is on [2di]
        cmpeq	$6, $9, $6 	# Turn recording on if at the start PC [1-]
        stl	$6, TRACEDATA_RECORDING_P($4)	#  [0di]
        beq	$6, G13287	# Jump if not at the start PC [1]
.align 3
G13283:
        ldq	$5, TRACEDATA_CURRENT_ENTRY($4)	# Get address of next trace record  [1-]
        ldq	$6, PROCESSORSTATE_INSTRUCTION_COUNT($14)	#  [1]
        stq	$9, TRACERECORD_EPC($5)	# Save current PC [2]
        stq	$6, TRACERECORD_COUNTER($5)	# Save instruction count [1]
        ldq	$6, 0($12)	#  [1]
/* Convert stack cache address to VMA */
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $8, $8 	# stack cache base relative offset [2di]
        srl	$8, 3, $8 	# convert byte address to word address [1]
        addq	$8, $7, $7 	# reconstruct VMA [2]
        stq	$6, TRACERECORD_TOS($5)	# Save current value of TOS [1-]
        stq	$7, TRACERECORD_SP($5)	# Save current SP [1]
        ldl	$6, CACHELINE_OPERAND($13)	#  [1]
        ldq	$7, CACHELINE_CODE($13)	#  [1]
        stl	$6, TRACERECORD_OPERAND($5)	# Save current instruction's operand [1]
        stq	$7, TRACERECORD_INSTRUCTION($5)	# Save pointer to current instruction code [1]
        ldq	$7, PROCESSORSTATE_CONTROL($14)	#  [1]
        ldq	$8, CACHELINE_INSTRUCTION($13)	#  [1]
        stl	$31, TRACERECORD_CATCH_BLOCK_P($5)	# We don't yet record catch blocks [1]
        stq	$7, TRACERECORD_CATCH_BLOCK_0($5)	# Save control register [1]
        ldq	$6, PROCESSORSTATE_TVI($14)	#  [1]
        stq	$8, TRACERECORD_INSTRUCTION_DATA($5)	# Save full word instruction operand [1]
        stl	$6, TRACERECORD_TRAP_P($5)	# Save trap indiciator [1]
        beq	$6, G13284	# Jump if didn't trap [1]
        ldq	$6, 16($10)	#  [1]
        stq	$31, PROCESSORSTATE_TVI($14)	# Zero flag to avoid false trap entries [1]
        ldq	$7, 24($10)	#  [1]
        stq	$6, TRACERECORD_TRAP_DATA_0($5)	# Save trap vector index [1]
        ldq	$8, 32($10)	#  [1]
        stq	$7, TRACERECORD_TRAP_DATA_1($5)	# Save fault PC [1]
        ldq	$22, 40($10)	#  [1]
        stq	$8, TRACERECORD_TRAP_DATA_2($5)	# Save two additional arguments [1]
        stq	$22, TRACERECORD_TRAP_DATA_3($5)	#  [1]
.align 3
G13284:
        addq	$5, TRACERECORDSIZE, $5 	# Bump to next trace record [1-]
        ldq	$6, TRACEDATA_RECORDS_START($4)	# Get pointer to start of trace records [0di]
        stq	$5, TRACEDATA_CURRENT_ENTRY($4)	# Set record pointer to keep printer happy [1]
        ldq	$7, TRACEDATA_RECORDS_END($4)	# Get pointer to end of trace record [1]
        ldq	$8, TRACEDATA_PRINTER($4)	# Function to print trace if non-zero [1]
        cmple	$7, $5, $7 	# Non-zero iff we're about to wrap the circular buffer [2di]
        cmovne	$7, $6, $5 	# Update next record pointer iff we wrapped [2]
        cmoveq	$7, $31, $8 	# Don't print if we didn't wrap [1]
        beq	$8, G13285	# Jump if we don't need to print [2]
        stq	$13, PROCESSORSTATE_CP($14)	#  [1]
        stq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        stq	$12, PROCESSORSTATE_SP($14)	#  [1]
        stq	$10, PROCESSORSTATE_FP($14)	#  [1]
        stq	$11, PROCESSORSTATE_LP($14)	#  [1]
        stq	$16, PROCESSORSTATE_ASRF2($14)	#  [1]
        stq	$17, PROCESSORSTATE_ASRF3($14)	#  [1]
        stq	$18, PROCESSORSTATE_ASRF4($14)	#  [1]
        stq	$19, PROCESSORSTATE_ASRF5($14)	#  [1]
        stq	$20, PROCESSORSTATE_ASRF6($14)	#  [1]
        stq	$21, PROCESSORSTATE_ASRF7($14)	#  [1]
        stq	$4, PROCESSORSTATE_ASRF8($14)	#  [1]
        stq	$5, PROCESSORSTATE_ASRF9($14)	#  [1]
        stq	$3, PROCESSORSTATE_LONG_PAD1($14)	#  [1]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        bis	$8, $31, $27 	# [0di]
        jsr	$26, ($8), 0	# [1-]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        ldq	$16, PROCESSORSTATE_ASRF2($14)	#  [1]
        ldq	$17, PROCESSORSTATE_ASRF3($14)	#  [1]
        ldq	$18, PROCESSORSTATE_ASRF4($14)	#  [1]
        ldq	$19, PROCESSORSTATE_ASRF5($14)	#  [1]
        ldq	$20, PROCESSORSTATE_ASRF6($14)	#  [1]
        ldq	$21, PROCESSORSTATE_ASRF7($14)	#  [1]
        ldq	$4, PROCESSORSTATE_ASRF8($14)	#  [1]
        ldq	$5, PROCESSORSTATE_ASRF9($14)	#  [1]
        ldq	$3, PROCESSORSTATE_LONG_PAD1($14)	#  [1]
        ldq	$13, PROCESSORSTATE_CP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        ldq	$12, PROCESSORSTATE_SP($14)	#  [1]
        ldq	$10, PROCESSORSTATE_FP($14)	#  [1]
        ldq	$11, PROCESSORSTATE_LP($14)	#  [1]
        bis	$31, $31, $7 	# Claim we didn't wrap [0di]
.align 3
G13285:
        stq	$5, TRACEDATA_CURRENT_ENTRY($4)	# Save next record pointer [1-]
        beq	$7, G13286	# Jump if we didn't wrap [1]
        stl	$7, TRACEDATA_WRAP_P($4)	# Set flag indicating that we wrapped [1]
.align 3
G13286:
        ldq	$5, TRACEDATA_STOP_PC($4)	#  [1]
        cmpeq	$5, $9, $5 	# Non-zero if at PC where we should stop tracing [3]
        cmpeq	$5, 0, $5 	# Non-zero if not at the PC [2]
        stl	$5, TRACEDATA_RECORDING_P($4)	# Update recording flag [0di]
.align 3
G13287:
#endif
#ifdef STATISTICS
        ldq	$4, CACHELINE_CODE($13)	# The instruction. [1]
        ldq	$5, PROCESSORSTATE_STATISTICS($14)	# The usage statistics array [1]
        lda	$22, 8191	#  [1-]
        srl	$4, 4, $6 	# [1]
        and	$6, $22, $6 	# Extract the address [2]
        s4addq	$6, $5, $7 	# Compute the index to the usage data for this instn. [1]
        ldl	$8, 0($7)	# Get current usage data [2]
        addq	$8, 1, $8 	# Increment [3]
        stl	$8, 0($7)	# Set current usage data [1-]
#endif
#ifdef CACHEMETERING
        ldl	$5, PROCESSORSTATE_METERCOUNT($14)	# The number of remaining tokens. [1]
        ldq	$4, PROCESSORSTATE_METERDATABUFF($14)	# The cache miss meter buffer. [1]
        ldl	$7, PROCESSORSTATE_METERPOS($14)	# Position for new data. [1]
        subq	$5, 1, $5 	# record a cache hit [1-]
        bne	$5, G13288	# [1]
        ldl	$8, PROCESSORSTATE_METERMASK($14)	#  [1-]
        s4addq	$7, $4, $4 	# position of the current data item [0di]
        ldl	$22, PROCESSORSTATE_METERVALUE($14)	#  [1-]
        addq	$7, 1, $7 	# [0di]
        and	$7, $8, $7 	# [2]
        ldl	$8, PROCESSORSTATE_METERMAX($14)	#  [1]
        subq	$22, $8, $6 	# [3]
        cmovgt	$6, $22, $8 	# [1]
        stl	$8, PROCESSORSTATE_METERMAX($14)	#  [1-]
        stl	$22, 0($4)	# store the datapoint [1]
        stl	$7, PROCESSORSTATE_METERPOS($14)	# Position for new data. [1]
        stl	$31, PROCESSORSTATE_METERVALUE($14)	#  [1]
        ldl	$5, PROCESSORSTATE_METERFREQ($14)	#  [1]
.align 3
G13288:
        stl	$5, PROCESSORSTATE_METERCOUNT($14)	#  [1]
#endif
#ifdef DEBUGGING
        beq	$3, HALTMACHINE	# Just in case... [1]
#endif
        jmp	$31, ($3), 16358	# Jump to the handler [1]
/* Here to advance the PC and begin a new instruction.  Most */
/* instructions come here when they have finished.  Instructions */
/* that explicitly update the PC (and CP) go to interpretInstruction. */
.align 3
NEXTINSTRUCTION:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	# Load the next PC from the cache [1]
        ldq	$13, CACHELINE_NEXTCP($13)	# Advance cache position [1]
        br	$31, CACHEVALID	# [1]
.align 3
TAKEICACHEMISS:
	br	$31, ICACHEMISS
.end nextInstruction
.align 5
.globl DoPushImmediateHandler
.ent DoPushImmediateHandler 0
.align 3
DoPushImmediateHandler:
#ifdef TRACING
        br	$31, DoPushIM	# [1]
	.byte 0x82
	.asciiz "DoPushIM"
#endif
.align 5
.align 3
DoPushIM:	# Entry point for IMMEDIATE mode
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeFixnum, $4 	# [1-]
        stl	$17, 8($12)	# Push it with CDR-NEXT onto the stack [0di]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.end DoPushImmediateHandler
.align 5
.globl DoBranchTrue
.ent DoBranchTrue 0
/* Halfword 10 bit immediate instruction - DoBranchTrue */
	.globl DoBranchTrueFP
	.globl DoBranchTrueSP
	.globl DoBranchTrueLP
	.globl DoBranchTrueIM
.align 3
DoBranchTrue:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrue"
#endif
.align 3
DoBranchTrueIM:
.align 3
DoBranchTrueSP:
.align 3
DoBranchTrueLP:
.align 3
DoBranchTrueFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, DoBrPopElsePop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrPopElsePop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrue
/* End of Halfword operand from stack instruction - DoBranchTrue */
.align 5
.globl DoBranchFalse
.ent DoBranchFalse 0
/* Halfword 10 bit immediate instruction - DoBranchFalse */
	.globl DoBranchFalseFP
	.globl DoBranchFalseSP
	.globl DoBranchFalseLP
	.globl DoBranchFalseIM
.align 3
DoBranchFalse:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalse"
#endif
.align 3
DoBranchFalseIM:
.align 3
DoBranchFalseSP:
.align 3
DoBranchFalseLP:
.align 3
DoBranchFalseFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, DoBrnPopElsePop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrnPopElsePop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalse
/* End of Halfword operand from stack instruction - DoBranchFalse */
.align 5
.globl DoReturnSingle
.ent DoReturnSingle 0
/* Halfword 10 bit immediate instruction - DoReturnSingle */
	.globl DoReturnSingleFP
	.globl DoReturnSingleSP
	.globl DoReturnSingleLP
	.globl DoReturnSingleIM
.align 3
DoReturnSingle:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoReturnSingle"
#endif
.align 3
DoReturnSingleIM:
.align 3
DoReturnSingleSP:
.align 3
DoReturnSingleLP:
.align 3
DoReturnSingleFP:
/* arg1 has operand preloaded. */
/* Fetch value based on immediate, interleaved with compute disposition dispatch */
        ldl	$20, PROCESSORSTATE_CONTROL($14)	#  [1]
        sll	$21, 26, $18 	# Clear cdr [0di]
        ldah	$3, 12	#  [1]
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        srl	$18, 26, $18 	# Clear cdr [1-]
        ldq	$2, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        and	$3, $20, $3 	# mask disposition bits [1-]
        srl	$3, 18, $3 	# shift disposition bits into place [1]
        ldq	$21, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
/* arg2 is 8 bits of "kludge operand" 0=TOS 40=NIL 41=T */
        cmovgt	$17, $1, $18 	# [0di]
        subq	$3, 2, $19 	# arg4 -2=effect -1=value 0=return 1=multiple [1]
        cmovlbs	$17, $2, $18 	# [1]
.align 3
RETURNCOMMONTAIL:
/* Restore machine state from frame header. */
        ldl	$3, 0($10)	#  [1-]
        ldah	$1, 1792	#  [0di]
        ldl	$5, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        and	$20, $1, $1 	# Mask [0di]
        ldl	$2, 4($10)	#  [1-]
        bis	$13, $31, $7 	# [0di]
        bne	$1, RETURNSINGLECLEANUP	# Need to cleanup frame first [1-]
        extll	$3, 0, $3 	# [0di]
        ldl	$4, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        extll	$5, 0, $5 	# [0di]
#ifdef IVERIFY
/* check for instruction verification suite end-of-test */
        subl	$2, TypeNIL, $6 	# check for end of run [1]
        beq	$6, G13313	# [1]
#endif
        ldl	$6, 8($10)	# Get saved control register [1]
/* TagType. */
        and	$2, 63, $2 	# [0di]
/* Restore the PC. */
        beq	$19, G13315	# [1-]
        sll	$5, 1, $9 	# Assume even PC [0di]
        and	$4, 1, $1 	# [1]
        ldq	$7, PROCESSORSTATE_CONTINUATIONCP($14)	#  [0di]
        addq	$9, $1, $9 	# [1-]
.align 3
G13315:
/* Restore the saved continuation */
        stl	$2, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        srl	$20, 9, $1 	# Get the caller frame size into place [0di]
        stl	$3, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        subq	$10, 8, $12 	# Restore the stack pointer. [0di]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1-]
        and	$1, 255, $1 	# Mask just the caller frame size. [0di]
        s8addq	$1, 0, $1 	# *8 [1]
        ldah	$2, 2048	#  [1]
        and	$2, $20, $2 	# [1]
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	# Get the preempt-pending bit [0di]
        bis	$2, $6, $6 	# Sticky trace pending bit. [1-]
        ldq	$4, PROCESSORSTATE_PLEASE_STOP($14)	# Get the trap/suspend bits [0di]
        subq	$10, $1, $10 	# Restore the frame pointer. [1-]
        stl	$6, PROCESSORSTATE_CONTROL($14)	# Restore the control register [0di]
        and	$6, 255, $1 	# extract the argument size [1-]
        and	$3, 1, $3 	# [1]
        bis	$4, $3, $3 	# [1]
        stq	$3, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [0di]
        s8addq	$1, $10, $11 	# Restore the local pointer. [1-]
.align 3
G13316:
        cmpult	$10, $21, $21 	# ARG6 = stack-cache underflow [1]
/* arg4 -2=effect -1=value 0=return 1=multiple */
        beq	$19, RETURNSINGLERETURN	# [0di]
        blbc	$19, RETURNSINGLEEFFECT	# [1]
        stq	$18, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1-]
        bgt	$19, RETURNSINGLEMULTIPLE	# [0di]
.align 3
RETURNSINGLEEFFECT:
.align 3
RETURNSINGLEDONE:
        bne	$21, RETURNSINGLEUNDERFLOW	# [1]
        beq	$7, INTERPRETINSTRUCTIONFORBRANCH	# No prediction, validate cache [1]
        fetch	0($7)	#  [1-]
        bis	$7, $31, $13 	# [0di]
        br	$31, INTERPRETINSTRUCTION	# [1-]
.align 3
RETURNSINGLEMULTIPLE:
        bis	$31, TypeFixnum, $8 	# Multiple-value group [1-]
        sll	$8, 32, $8 	# [1]
        addq	$12, 8, $12 	# [1]
        bis	$8, 1, $8 	# [1]
        stq	$8, 0($12)	# Push Fixnum [1-]
        br	$31, RETURNSINGLEDONE	# [1]
.align 3
RETURNSINGLERETURN:
        bne	$17, RETURNSINGLEDONE	# [1]
        stq	$18, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, RETURNSINGLEDONE	# [0di]
.align 3
RETURNSINGLECLEANUP:
	br	$31, HANDLEFRAMECLEANUP
.align 3
RETURNSINGLEUNDERFLOW:
	br	$31, StackCacheUnderflowCheck
.end DoReturnSingle
/* End of Halfword operand from stack instruction - DoReturnSingle */
.globl callindirectprefetch
.globl startcallagain
.align 5
.globl callindirect
.ent callindirect 0
/* Fullword instruction - callindirect */
#ifdef TRACING
	.byte 0x80
	.asciiz "callindirect"
#endif
.align 3
callindirect:
.align 3
callindirectprefetch:
        extll	$18, 0, $17 	# Get operand [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        bis	$31, $31, $18 	# No extra arg [0di]
/* Memory Read Internal */
G13333:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13335	# [1-]
G13334:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13337	# [1-]
G13344:
        subq	$20, TypeCompiledFunction, $5 	# [0di]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, STARTCALLAGAIN	# [1]
        bis	$31, TypeEvenPC, $20 	# [1-]
        ldl	$7, PROCESSORSTATE_CONTINUATION+4($14)	#  [0di]
        addq	$12, 16, $12 	# prepare to push continuation/control register [1-]
        ldl	$3, PROCESSORSTATE_CONTROL($14)	#  [0di]
        bis	$31, TypeFixnum+0xC0, $6 	# [1-]
        ldl	$8, PROCESSORSTATE_CONTINUATION($14)	#  [0di]
        ldah	$5, 64	#  [1-]
        bis	$7, 192, $7 	# Set CDR code 3 [1]
        stl	$8, -8($12)	# push continuation [1-]
        stl	$7, -4($12)	# write the stack cache [1]
        bis	$3, $5, $8 	# Set call started bit in CR [1-]
        lda	$5, 256	#  [1]
        stl	$3, 0($12)	# Push control register [1-]
        stl	$6, 4($12)	# write the stack cache [1]
        bic	$8, $5, $8 	# Clear the extra arg bit [1-]
        stl	$8, PROCESSORSTATE_CONTROL($14)	# Save control with new state [0di]
/* End of push-frame */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$21, PROCESSORSTATE_CONTINUATION($14)	#  [1]
        stl	$20, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1]
        bne	$18, callindirectextra	# [1]
        br	$31, CACHEVALID	# [1]
.align 3
callindirectextra:
        ldl	$1, PROCESSORSTATE_CONTROL($14)	#  [1]
        lda	$2, 256	#  [0di]
        and	$18, 63, $3 	# set CDR-NEXT [1]
        stl	$19, 8($12)	# Push the extra arg. [0di]
        stl	$3, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$1, $2, $1 	# Set the extra arg bit [1]
        stl	$1, PROCESSORSTATE_CONTROL($14)	# Save control with new state [0di]
        br	$31, CACHEVALID	# [1]
.align 3
G13337:
        blbc	$7, G13336	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13333	# [1-]
.align 3
G13336:
.align 3
G13335:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13344	# [1]
.end callindirect
/* End of Fullword instruction - callindirect */
.align 5
.globl DoFinishCallN
.ent DoFinishCallN 0
/* Halfword 10 bit immediate instruction - DoFinishCallN */
	.globl DoFinishCallNFP
	.globl DoFinishCallNSP
	.globl DoFinishCallNLP
	.globl DoFinishCallNIM
.align 3
DoFinishCallN:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoFinishCallN"
#endif
.align 3
DoFinishCallNIM:
.align 3
DoFinishCallNSP:
.align 3
DoFinishCallNLP:
.align 3
DoFinishCallNFP:
/* arg1 has operand preloaded. */
/* arg2 contains the 8 bit N+1 */
        extbl	$18, 5, $16 	# arg1 contains the disposition (two bits) [1-]
        s8addq	$17, $31, $17 	# convert N to words (stacked words that is) [1]
.align 3
FINISHCALLMERGE:
        srl	$18, 7, $18 	# [1]
        ldl	$6, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [0di]
        lda	$3, 128	#  [1-]
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [0di]
        s8addq	$3, $12, $3 	# SCA of desired end of cache [1-]
        s8addq	$6, $4, $4 	# SCA of current end of cache [2]
        cmple	$3, $4, $6 	# [1]
        beq	$6, G13353	# We're done if new SCA is within bounds [1]
        and	$18, 8, $18 	# 0 if not apply, 8 if apply [1-]
        ldl	$1, PROCESSORSTATE_CONTROL($14)	# Get the control register [0di]
/* Compute the new LP */
        lda	$11, 8($12)	# Assume not Apply case. [1-]
        subq	$11, $18, $11 	# For apply, iLP==iSP [1]
/* Compute the new FP */
        srl	$1, 5, $3 	# extra arg bit<<3 [1]
        subq	$12, $17, $2 	# [1]
        and	$3, 8, $3 	# 8 if extra arg, 0 otherwise. [1]
        subq	$2, $3, $2 	# This! is the new frame pointer! [1]
/* compute arg size */
        subq	$11, $2, $4 	# [1]
        srl	$4, 3, $4 	# arg size in words. [1]
/* compute caller frame size. */
        subq	$2, $10, $5 	# [1]
        srl	$5, 3, $5 	# caller frame size in words. [1]
/* Now hack the control register! */
        sll	$16, 18, $7 	# Get value disposition into place [1]
        ldq	$6, PROCESSORSTATE_FCCRMASK($14)	# cr.caller-frame-size [0di]
        sll	$5, 9, $5 	# Shift caller frame size into place [1-]
        bis	$7, $4, $7 	# Add arg size to new bits. [1]
        sll	$18, 14, $4 	# Apply bit in place [1]
        bis	$5, $7, $7 	# Add frame size to new bits [1]
        bis	$4, $7, $7 	# All new bits assembled! [1]
/* Set the return continuation. */
        ldq	$5, CACHELINE_NEXTPCDATA($13)	# Next instruction hw format [0di]
        and	$1, $6, $1 	# Mask off unwanted bits [1-]
        ldl	$4, PROCESSORSTATE_CONTINUATION($14)	# Get the new PC tag/data [0di]
        bis	$1, $7, $1 	# Add argsize, apply, disposition, caller FS [1-]
        ldl	$3, PROCESSORSTATE_CONTINUATION+4($14)	#  [0di]
/* Update the PC */
/* Convert PC to a real continuation. */
        and	$5, 1, $6 	# [1-]
        srl	$5, 1, $7 	# convert PC to a real word address. [1]
        lda	$6, TypeEvenPC($6)	#  [1]
        extll	$4, 0, $4 	# [1]
/* Convert real continuation to PC. */
        and	$3, 1, $9 	# [1]
        addq	$4, $9, $9 	# [1]
        addq	$4, $9, $9 	# [1]
        stl	$7, PROCESSORSTATE_CONTINUATION($14)	#  [0di]
        stl	$6, PROCESSORSTATE_CONTINUATION+4($14)	# Set return address [1]
/* Update CP */
        ldah	$7, 4096	#  [0di]
        ldq	$5, CACHELINE_NEXTCP($13)	#  [1-]
        and	$7, $1, $7 	# [0di]
        srl	$7, 1, $7 	# Shift into trace pending place [1]
        stq	$5, PROCESSORSTATE_CONTINUATIONCP($14)	#  [0di]
        bis	$1, $7, $1 	# Set the cr.trace pending if appropriate. [2-]
        stl	$1, PROCESSORSTATE_CONTROL($14)	# Set the control register [0di]
        bis	$2, $31, $10 	# Install the new frame pointer [1-]
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
/* Check for stack overflow */
        srl	$1, 30, $1 	# Isolate trap mode [1-]
        ldl	$3, PROCESSORSTATE_CSLIMIT($14)	# Limit for emulator mode [0di]
        ldl	$4, PROCESSORSTATE_CSEXTRALIMIT($14)	# Limit for extra stack and higher modes [1]
        cmovne	$1, $4, $3 	# Get the right limit for the current trap mode [3]
        extll	$3, 0, $3 	# Might have been sign extended [2]
/* Convert stack cache address to VMA */
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $4, $4 	# stack cache base relative offset [2di]
        srl	$4, 3, $4 	# convert byte address to word address [1]
        addq	$4, $1, $1 	# reconstruct VMA [2]
        cmplt	$1, $3, $4 	# Check for overflow [1]
        beq	$4, STACKOVERFLOW	# Jump if overflow [1]
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [1]
/* Begin execution at the computed address */
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.align 3
G13353:
        bis	$31, 0, $17 	# [1-]
        br	$31, StackCacheOverflowHandler	# [0di]
.end DoFinishCallN
/* End of Halfword operand from stack instruction - DoFinishCallN */
.align 5
.globl DoEntryRestNotAccepted
.ent DoEntryRestNotAccepted 0
/* Field Extraction instruction - DoEntryRestNotAccepted */
	.globl DoEntryRestNotAcceptedFP
	.globl DoEntryRestNotAcceptedSP
	.globl DoEntryRestNotAcceptedLP
	.globl DoEntryRestNotAcceptedIM
.align 3
DoEntryRestNotAccepted:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xB0
	.asciiz "DoEntryRestNotAccepted"
#endif
.align 3
DoEntryRestNotAcceptedIM:
.align 3
DoEntryRestNotAcceptedSP:
.align 3
DoEntryRestNotAcceptedLP:
.align 3
DoEntryRestNotAcceptedFP:
        ldl	$20, PROCESSORSTATE_CONTROL($14)	# The control register [1]
        srl	$18, 18, $19 	# Pull down the number of optionals [0di]
        extbl	$18, 5, $16 	# Extract the 'ptr' field while we are waiting [1]
        and	$19, 255, $19 	# [1]
/* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
        srl	$20, 27, $2 	# Get the cr.trace-pending bit [1]
        and	$20, 255, $1 	# The supplied args [1]
        blbs	$2, TRACETRAP	# [1-]
        srl	$20, 17, $3 	# [0di]
        ldl	$4, 4($12)	# Get the tag of the stack top. [1-]
.align 3
G13364:
        blbs	$3, G13362	# J. if apply args [1-]
G13363:
        subq	$1, $17, $2 	# t2=supplied-minimum [0di]
        blt	$2, RETRYERNATOOFEW	# B. if too few args. [1]
        subq	$19, $1, $16 	# maximum-supplied [0di]
        blt	$16, RETRYERNATOOMANY	# B. if too many args. [1]
/* Compute entry position and advance PC/CP accordingly. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	# get the next PC [0di]
        sll	$2, 1, $3 	# Adjust index to halfword [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        beq	$2, INTERPRETINSTRUCTION	# J. if index zero, no adjustment. [1-]
        addq	$9, $3, $9 	# Compute the new address [1di]
        bic	$9, 1, $9 	# Make it an DTP-EVEN-PC [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [0di]
.align 3
APPLYSUPPRNA:
        subq	$19, $1, $16 	# [1-]
        ble	$16, RETRYERNATOOMANY	# B. if too many args. [1]
        br	$31, PullApplyArgs	# [1]
.align 3
RETRYERNATOOMANY:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 78, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
RETRYERNATOOFEW:
        bis	$31, 0, $20 	# [1]
        bis	$31, 77, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13362:
        and	$4, 63, $4 	# [1]
        subq	$4, TypeNIL, $4 	# [1]
        bne	$4, APPLYSUPPRNA	# J. if apply args supplied not nil. [1]
        and	$3, 1, $3 	# keep just the apply bit! [0di]
        sll	$3, 17, $3 	# reposition the apply bit [1]
        subq	$12, 8, $12 	# Pop off the null applied arg. [1]
        bic	$20, $3, $20 	# Blast the apply arg bit away [1]
        stl	$20, PROCESSORSTATE_CONTROL($14)	# Reset the stored cr bit [0di]
        br	$31, G13363	# [1]
.end DoEntryRestNotAccepted
/* End of Halfword operand from stack instruction - DoEntryRestNotAccepted */
.align 5
.globl VerifyGenericArity
.ent VerifyGenericArity 0
.align 3
VerifyGenericArity:
        ldah	$24, 2	#  [1-]
        and	$24, $17, $24 	# [1]
        beq	$24, G13373	# not applying [1]
        subq	$31, $20, $16 	# 4 - argsize [0di]
        br	$31, PullApplyArgs	# [1-]
.align 3
G13373:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 77, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end VerifyGenericArity
.align 5
.globl PullApplyArgs
.ent PullApplyArgs 1
.align 3
PullApplyArgs:
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$2, 0($12)	#  [1]
        ldl	$1, 4($12)	#  [1]
        extll	$2, 0, $2 	# [2-]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$4, TypeList, $5 	# [1]
.align 3
G13402:
        beq	$5, G13376	# [1]
/* Here if argument TypeList */
        subq	$2, $20, $5 	# Stack cache offset [1]
        cmpult	$5, $21, $6 	# In range? [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        beq	$6, G13374	# J. if not in cache [1-]
        s8addq	$5, $4, $4 	# reconstruct SCA [2di]
        bis	$31, $31, $7 	# [1]
        lda	$5, 128	#  [1]
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1-]
        addq	$5, $16, $5 	# Account for what we're about to push [0di]
        s8addq	$5, $12, $5 	# SCA of desired end of cache [1]
        s8addq	$21, $6, $6 	# SCA of current end of cache [2]
        cmple	$5, $6, $23 	# [1]
        beq	$23, G13383	# We're done if new SCA is within bounds [1]
        subq	$12, 8, $12 	# Pop Stack. [1-]
        br	$31, G13382	# [0di]
.align 3
G13377:
        ldl	$22, 0($4)	#  [1]
        ldl	$8, 4($4)	#  [1]
        extll	$22, 0, $22 	# [2-]
        addq	$7, 1, $7 	# [1]
        addq	$4, 8, $4 	# [1]
        and	$8, 192, $5 	# Extract CDR code. [1]
        bne	$5, G13385	# [1]
/* Here if argument 0 */
        and	$8, 63, $5 	# set CDR-NEXT [1]
        stl	$22, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        cmpeq	$7, $16, $5 	# [1]
        beq	$5, G13377	# [1]
        br	$31, G13378	# [1]
.align 3
G13385:
        cmpeq	$5, 64, $6 	# [1-]
.align 3
G13397:
        beq	$6, G13386	# [1]
/* Here if argument 64 */
        and	$8, 63, $5 	# set CDR-NEXT [0di]
        stl	$22, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
.align 3
G13380:
        ldl	$5, PROCESSORSTATE_CONTROL($14)	#  [1-]
        and	$5, 255, $6 	# Get current arg size. [3]
        bic	$5, 255, $5 	# [1]
        addq	$6, $7, $6 	# [1]
        addq	$6, $5, $5 	# Update the arg size [1]
        ldah	$6, 2	#  [1]
        bic	$5, $6, $5 	# turn off cr.apply [1]
        stl	$5, PROCESSORSTATE_CONTROL($14)	#  [0di]
        s8addq	$7, $11, $11 	# [1-]
        br	$31, INTERPRETINSTRUCTION	# [0di]
.align 3
G13386:
        cmpeq	$5, 128, $6 	# [1-]
.align 3
G13398:
        beq	$6, G13387	# [1]
/* Here if argument 128 */
        and	$8, 63, $5 	# set CDR-NEXT [0di]
        stl	$22, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        ldl	$24, 0($4)	#  [0di]
        ldl	$23, 4($4)	#  [1]
        extll	$24, 0, $24 	# [2di]
        and	$23, 63, $5 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeList, $6 	# [1]
.align 3
G13393:
        beq	$6, G13389	# [1]
/* Here if argument TypeList */
        subq	$24, $20, $5 	# Stack cache offset [0di]
        cmpult	$5, $21, $6 	# In range? [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        beq	$6, G13379	# J. if not in cache [1-]
        s8addq	$5, $4, $4 	# reconstruct SCA [2di]
        br	$31, G13382	# [1-]
.align 3
G13389:
        cmpeq	$5, TypeNIL, $6 	# [1-]
.align 3
G13394:
        beq	$6, G13390	# [1]
/* Here if argument TypeNIL */
        br	$31, G13380	# [1]
.align 3
G13390:
/* Here for all other cases */
.align 3
G13379:
        and	$23, 63, $5 	# set CDR-NEXT [1-]
        stl	$24, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, G13381	# [1-]
.align 3
G13388:
.align 3
G13387:
/* Here for all other cases */
        subq	$7, 1, $7 	# [1-]
        subq	$4, 8, $4 	# [1]
        br	$31, G13378	# [1-]
.align 3
G13384:
G13382:
        cmpeq	$7, $16, $5 	# [1-]
        beq	$5, G13377	# [1]
.align 3
G13378:
/* Here if count=n, or bad cdr */
/* Convert stack cache address to VMA */
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$4, $5, $5 	# stack cache base relative offset [3]
        srl	$5, 3, $5 	# convert byte address to word address [1]
        addq	$5, $20, $22 	# reconstruct VMA [2]
        bis	$31, TypeList, $5 	# [1]
        stl	$22, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
.align 3
G13381:
        ldl	$5, PROCESSORSTATE_CONTROL($14)	#  [1-]
        and	$5, 255, $6 	# Get current arg size. [3]
        bic	$5, 255, $5 	# [1]
        addq	$6, $7, $6 	# [1]
        addq	$6, $5, $5 	# Update the arg size [1]
        stl	$5, PROCESSORSTATE_CONTROL($14)	#  [0di]
        s8addq	$7, $11, $11 	# [1-]
        subq	$16, $7, $16 	# [1]
        ble	$16, INTERPRETINSTRUCTION	# [1]
	br	$31, PullApplyArgsSlowly
.align 3
G13376:
        cmpeq	$4, TypeNIL, $5 	# [1-]
.align 3
G13403:
        beq	$5, G13399	# [1]
/* Here if argument TypeNIL */
        ldl	$6, PROCESSORSTATE_CONTROL($14)	# Get the control register [0di]
        ldah	$7, 2	#  [1-]
        subq	$12, 8, $12 	# Discard that silly nil [1]
        bic	$6, $7, $6 	# Blast away the apply arg bit. [1]
        stl	$6, PROCESSORSTATE_CONTROL($14)	#  [0di]
        br	$31, INTERPRETINSTRUCTION	# [1]
.align 3
G13399:
/* Here for all other cases */
        bis	$31, $16, $16 	# Pull apply args trap needs nargs in ARG1 [1-]
	br	$31, PULLAPPLYARGSTRAP
.align 3
G13374:
        bis	$31, $16, $16 	# [1]
	br	$31, PullApplyArgsSlowly
.align 3
G13375:
.align 3
G13383:
        bis	$31, $16, $17 	# [1]
        br	$31, StackCacheOverflowHandler	# [0di]
.end PullApplyArgs
.align 5
.globl valuecell
.ent valuecell 0
/* Fullword instruction - valuecell */
#ifdef TRACING
	.byte 0x80
	.asciiz "valuecell"
#endif
.align 3
valuecell:
        extll	$18, 0, $17 	# Get address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G13404:
        addq	$17, $14, $7 	# [1di]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13406	# [0di]
G13405:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13408	# [1di]
G13415:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        and	$20, 63, $3 	# set CDR-NEXT [1-]
        stl	$21, 8($12)	# Push the result [0di]
        stl	$3, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
G13408:
        blbc	$7, G13407	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13404	# [1-]
.align 3
G13407:
.align 3
G13406:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13415	# [1]
.end valuecell
/* End of Fullword instruction - valuecell */
.align 5
.globl pushconstantvalue
.ent pushconstantvalue 0
/* Fullword instruction - pushconstantvalue */
#ifdef TRACING
	.byte 0x80
	.asciiz "pushconstantvalue"
#endif
.align 3
pushconstantvalue:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$18, 8($12)	#  [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.end pushconstantvalue
/* End of Fullword instruction - pushconstantvalue */
.align 5
.globl DoZerop
.ent DoZerop 0
/* Halfword operand from stack instruction - DoZerop */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoZeropFP
	.globl DoZeropSP
	.globl DoZeropLP
	.globl DoZeropIM
.align 3
DoZerop:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoZeropSP"
#endif
.align 3
DoZeropSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoZerop	# [0di]
	.byte 0x90
	.asciiz "DoZeropLP"
#endif
.align 3
DoZeropLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoZerop	# [1]
	.byte 0x84
	.asciiz "DoZeropFP"
#endif
.align 3
DoZeropFP:	# Entry point for FP relative
.align 3
beginDoZerop:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldl	$1, 4($16)	#  [1]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1]
        ldl	$2, 0($16)	#  [1]
        lds	$f1, 0($16)	#  [1]
        and	$1, 63, $4 	# Strip off any CDR code bits. [0di]
        cmpeq	$4, TypeFixnum, $5 	# [1]
.align 3
G13421:
        beq	$5, G13417	# [1]
/* Here if argument TypeFixnum */
        bis	$6, $31, $9 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmoveq	$2, $25, $24 	# T if predicate succeeds [0di]
        stq	$24, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
G13417:
        cmpeq	$4, TypeSingleFloat, $5 	# [1-]
.align 3
G13422:
        beq	$5, G13418	# [1]
/* Here if argument TypeSingleFloat */
        bis	$6, $31, $9 	# [0di]
        stq	$25, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        fbeq	$f1, CACHEVALID	# [0di]
        stq	$24, 0($12)	# Didn't branch, answer is NIL [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G13418:
/* Here for all other cases */
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, UNARYNUMERICEXCEPTION
.align 3
G13416:
#ifdef TRACING
        br	$31, DoZeropIM	# [1-]
	.byte 0x82
	.asciiz "DoZeropIM"
#endif
.align 5
.align 3
DoZeropIM:	# Entry point for IMMEDIATE mode
        ldq	$2, PROCESSORSTATE_TADDRESS($14)	#  [1]
        addq	$12, 8, $12 	# [0di]
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        cmoveq	$17, $2, $1 	# [0di]
        stq	$1, 0($12)	# yes Virginia, we dual issue with above yahoo [1-]
        br	$31, CACHEVALID	# [1]
.end DoZerop
/* End of Halfword operand from stack instruction - DoZerop */
.align 5
.globl DoSetSpToAddress
.ent DoSetSpToAddress 0
/* Halfword operand from stack instruction - DoSetSpToAddress */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetSpToAddressFP
	.globl DoSetSpToAddressSP
	.globl DoSetSpToAddressLP
	.globl DoSetSpToAddressIM
.align 3
DoSetSpToAddress:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetSpToAddressSP"
#endif
.align 3
DoSetSpToAddressSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetSpToAddress	# [0di]
	.byte 0x90
	.asciiz "DoSetSpToAddressLP"
#endif
.align 3
DoSetSpToAddressLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetSpToAddress	# [1]
	.byte 0x84
	.asciiz "DoSetSpToAddressFP"
#endif
.align 3
DoSetSpToAddressFP:	# Entry point for FP relative
.align 3
beginDoSetSpToAddress:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, $16, $12 	# Set iSP=address of operand [0di]
        br	$31, CACHEVALID	# [1-]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetSpToAddressIM"
#endif
DoSetSpToAddressIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetSpToAddress.
.end DoSetSpToAddress
/* End of Halfword operand from stack instruction - DoSetSpToAddress */
.align 5
.globl DoEq
.ent DoEq 0
/* Halfword operand from stack instruction - DoEq */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoEqFP
	.globl DoEqSP
	.globl DoEqLP
	.globl DoEqIM
.align 3
DoEq:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoEqSP"
#endif
.align 3
DoEqSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoEq	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoEq	# [0di]
	.byte 0x90
	.asciiz "DoEqLP"
#endif
.align 3
DoEqLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoEq	# [1]
	.byte 0x84
	.asciiz "DoEqFP"
#endif
.align 3
DoEqFP:	# Entry point for FP relative
.align 3
beginDoEq:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        srl	$18, 12, $18 	# [1-]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        ldq	$16, 0($16)	# load op2 [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        and	$18, 1, $18 	# 1 if no-pop, 0 if pop [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        xor	$21, $16, $3 	# compare tag and data [1-]
        sll	$3, 26, $3 	# shift off the cdr code [1]
        s8addq	$18, $12, $12 	# Either a stack-push or a stack-write [1]
        cmoveq	$3, $25, $24 	# pick up T or NIL [1]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.end DoEq
/* End of Halfword operand from stack instruction - DoEq */
.align 5
.globl DoAref1
.ent DoAref1 0
/* Halfword operand from stack instruction - DoAref1 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAref1FP
	.globl DoAref1SP
	.globl DoAref1LP
	.globl DoAref1IM
.align 3
DoAref1:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAref1SP"
#endif
.align 3
DoAref1SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, headDoAref1	# [0di]
        bis	$21, $31, $16 	# SP-pop mode, TOS->arg1 [1-]
        ldq	$21, 0($19)	# Reload TOS [1]
        bis	$19, $31, $12 	# Adjust SP [1-]
        br	$31, beginDoAref1	# [0di]
#ifdef TRACING
        br	$31, headDoAref1	# [1]
	.byte 0x90
	.asciiz "DoAref1LP"
#endif
.align 3
DoAref1LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAref1	# [1]
	.byte 0x84
	.asciiz "DoAref1FP"
#endif
.align 3
DoAref1FP:	# Entry point for FP relative
.align 3
headDoAref1:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAref1:
/* arg1 has the operand, not sign extended if immediate. */
        extll	$21, 4, $18 	# [1-]
        extll	$21, 0, $19 	# Get the array tag/data [1]
        addl	$16, 0, $17 	# (sign-extended, for fast bounds check) Index Data [1]
        lda	$8, AutoArrayRegMask	#  [1]
        and	$19, $8, $8 	# [1]
        srl	$16, 32, $16 	# Index Tag [1]
        lda	$7, PROCESSORSTATE_AC0ARRAY($14)	#  [1]
        addq	$7, $8, $7 	# This is the address if the array register block. [1]
        subq	$16, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, AREF1ILLEGAL	# [1]
.align 3
AREF1MERGE:
        beq	$19, Aref1Regset	# [1]
        ldq	$8, ARRAYCACHE_ARRAY($7)	# Cached array object. [0di]
        subq	$18, TypeArray, $1 	# [1-]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, REALLYAREF1EXC	# [1]
        cmpeq	$19, $8, $8 	# t8==1 iff cached array is ours. [0di]
        beq	$8, Aref1Regset	# Go and setup the array register. [1]
#ifdef SLOWARRAYS
        br	$31, Aref1Regset	# [1]
#endif
        ldq	$21, ARRAYCACHE_ARWORD($7)	#  [1]
        ldq	$22, ARRAYCACHE_LOCAT($7)	# high order bits all zero [1]
        ldq	$3, ARRAYCACHE_LENGTH($7)	# high order bits all zero [1]
        sll	$21, 42, $5 	# [1di]
        ldq	$4, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        srl	$5, 42, $5 	# [1di]
        cmpult	$17, $3, $2 	# [1]
        subq	$4, $5, $6 	# [1]
        bne	$6, Aref1Regset	# J. if event count ticked. [1]
        beq	$2, AREF1BOUNDS	# [1]
        srl	$21, ArrayRegisterBytePackingPos, $20 	# [1-]
        srl	$21, ArrayRegisterByteOffsetPos, $19 	# [1]
        srl	$21, ArrayRegisterElementTypePos, $8 	# [1]
        and	$19, ArrayRegisterByteOffsetMask, $19 	# [1]
        and	$20, ArrayRegisterBytePackingMask, $20 	# [1]
        and	$8, ArrayRegisterElementTypeMask, $21 	# [1]
.align 3
AREF1RESTART:
        bne	$20, G13431	# [1-]
        addq	$22, $17, $1 	# [0di]
.align 3
G13432:
/* Memory Read Internal */
G13439:
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $5 	# [0di]
        ldl	$3, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$5, $31, $22 	# [0di]
        ldq_u	$18, 0($5)	#  [1-]
        subq	$1, $2, $2 	# Stack cache offset [1di]
        ldq	$6, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$2, $3, $3 	# In range? [0di]
        ldl	$22, 0($22)	#  [1-]
        extbl	$18, $5, $18 	# [0di]
        bne	$3, G13441	# [1-]
G13440:
        lda	$5, 240	#  [0di]
        srl	$6, $18, $6 	# [1]
        srl	$5, $18, $5 	# [1]
        extll	$22, 0, $22 	# [1]
        blbs	$6, G13443	# [0di]
G13450:
        bne	$20, G13433	# [1]
.align 3
G13434:
        bis	$31, $31, $31 	# [0]
        subq	$21, 2, $1 	# [1]
        ble	$1, G13435	# [1]
/* TagType. */
        and	$18, 63, $18 	# [0di]
.align 3
G13436:
        stl	$18, 4($12)	#  [1-]
        cmpeq	$20, 0, $5 	# [0di]
        beq	$5, CASE_OTHERS_7	# [1]
.align 3
CASE_0_1:
        bis	$31, $31, $31 	# [0]
        beq	$1, G13437	# [0di]
        stl	$22, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_2_2:
/* AREF1-8B */
        bis	$31, $31, $31 	# [0]
        and	$17, 3, $5 	# [1]
        extbl	$22, $5, $6 	# [1]
        beq	$1, G13437	# [0di]
        stl	$6, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_3_3:
/* AREF1-4B */
        bis	$31, $31, $31 	# [0]
        and	$17, 7, $5 	# byte-index [1]
        sll	$5, 2, $5 	# byte-position [1]
        srl	$22, $5, $6 	# byte in position [2]
        and	$6, 15, $6 	# byte masked [2]
        beq	$1, G13437	# [0di]
        stl	$6, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_5_4:
/* AREF1-1B */
        bis	$31, $31, $31 	# [0]
        and	$17, 31, $5 	# byte-index [1]
        bis	$31, $31, $31 	# [0]
        srl	$22, $5, $6 	# byte in position [1]
        and	$6, 1, $6 	# byte masked [2]
        beq	$1, G13437	# [0di]
        stl	$6, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_1_5:
/* AREF1-16B */
        and	$17, 1, $5 	# [1-]
        addq	$5, $5, $5 	# Bletch, it's a byte ref [1]
        extwl	$22, $5, $6 	# [1]
        beq	$1, G13437	# [0di]
        stl	$6, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_OTHERS_7:
        bis	$31, $31, $31 	# [0]
        cmpeq	$20, 2, $5 	# [1]
        cmpeq	$20, 3, $6 	# [1]
        bne	$5, CASE_2_2	# [0di]
        cmpeq	$20, 5, $5 	# [1]
        bne	$6, CASE_3_3	# [0di]
        cmpeq	$20, 1, $6 	# [1]
        bne	$5, CASE_5_4	# [0di]
        bne	$6, CASE_1_5	# [1]
.align 3
CASE_4_6:
/* AREF1-2B */
        bis	$31, $31, $31 	# [0]
        and	$17, 15, $5 	# byte-index [1]
        sll	$5, 1, $5 	# byte-position [1]
        srl	$22, $5, $6 	# byte in position [2]
        and	$6, 3, $6 	# byte masked [2]
        beq	$1, G13437	# [0di]
        stl	$6, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13431:
        addq	$19, $17, $17 	# [1-]
        srl	$17, $20, $1 	# Convert byte index to word index [1]
        addq	$1, $22, $1 	# Address of word containing byte [2]
        br	$31, G13432	# [0di]
.align 3
G13433:
        subq	$18, TypeFixnum, $1 	# [1-]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, G13438	# [1]
        br	$31, G13434	# [1]
.align 3
G13435:
        bis	$31, TypeCharacter, $18 	# [1-]
        blbs	$21, G13436	# [0di]
        bis	$31, TypeFixnum, $18 	# [1-]
        beq	$21, G13436	# [0di]
        ldq	$2, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        ldq	$3, PROCESSORSTATE_TADDRESS($14)	#  [1]
        br	$31, G13436	# [1]
.align 3
G13437:
        cmovne	$6, $3, $2 	# [2-]
        stq	$2, 0($12)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13438:
        bis	$31, $1, $20 	# [1-]
        bis	$31, 25, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
        br	$31, DoAref1IM	# [1-]
	.byte 0x82
	.asciiz "DoAref1IM"
#endif
.align 5
.align 3
DoAref1IM:	# Entry point for IMMEDIATE mode
        lda	$8, AutoArrayRegMask	#  [1-]
        ldl	$19, 0($12)	# Get the array tag/data [0di]
        ldl	$18, 4($12)	#  [1]
        extll	$19, 0, $19 	# [2di]
        lda	$7, PROCESSORSTATE_AC0ARRAY($14)	#  [1]
        and	$19, $8, $8 	# [1]
        addq	$7, $8, $7 	# This is the address of the array register block. [1]
        br	$31, AREF1MERGE	# [0di]
.align 3
G13441:
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$2, $3, $2 	# reconstruct SCA [3]
        ldl	$22, 0($2)	#  [2]
        ldl	$18, 4($2)	# Read from stack cache [1]
        br	$31, G13440	# [1]
.align 3
G13443:
        blbc	$5, G13442	# [1]
        extll	$22, 0, $1 	# Do the indirect thing [0di]
        br	$31, G13439	# [1-]
.align 3
G13442:
        ldq	$6, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$18, 63, $5 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$5, $6, $5 	# Adjust for a longword load [2di]
        ldl	$6, 0($5)	# Get the memory action [2]
.align 3
G13447:
        and	$6, MemoryActionTransform, $5 	# [3]
        beq	$5, G13446	# [1]
        bic	$18, 63, $18 	# [1-]
        bis	$18, TypeExternalValueCellPointer, $18 	# [1]
        br	$31, G13450	# [1-]
#ifndef MINIMA
G13446:
#endif
#ifdef MINIMA
.align 3
G13446:
        and	$6, MemoryActionBinding, $5 	# [1-]
        ldq	$3, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$5, G13445	# [1-]
        sll	$1, 1, $2 	# [0di]
        ldq	$5, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$2, $3, $2 	# Hash index [1di]
        bis	$31, 1, $3 	# [1]
        sll	$3, IvoryMemoryData, $3 	# [1]
        addl	$2, $5, $2 	# [1]
        extll	$2, 0, $2 	# Clear sign-extension [1]
        s4addq	$2, $3, $3 	# [2]
        ldl	$2, 0($3)	# Fetch the key [2]
        ldl	$22, 4($3)	# Fetch value [1]
        subl	$1, $2, $5 	# Compare [2di]
        bne	$5, G13449	# Trap on miss [1]
        extll	$22, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G13439	# This is another memory read tailcall. [1-]
.align 3
G13449:
	br	$31, DBCACHEMISSTRAP
#endif
G13445:
/* Perform memory action */
        bis	$31, $6, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoAref1
/* End of Halfword operand from stack instruction - DoAref1 */
.align 5
.globl DoTypeMember
.ent DoTypeMember 0
/* Halfword 10 bit immediate instruction - DoTypeMember */
	.globl DoTypeMemberFP
	.globl DoTypeMemberSP
	.globl DoTypeMemberLP
	.globl DoTypeMemberIM
.align 3
DoTypeMember:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoTypeMember"
#endif
.align 3
DoTypeMemberIM:
.align 3
DoTypeMemberSP:
.align 3
DoTypeMemberLP:
.align 3
DoTypeMemberFP:
/* arg1 has operand preloaded. */
        srl	$18, 6, $6 	# Position the opcode [1]
        ldq	$4, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        ldl	$19, 4($12)	# get op1's tag [1]
        bis	$31, 1, $1 	# [0di]
        ldq	$5, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        srl	$18, 12, $7 	# Get pop-bit while stalled [0di]
        and	$6, 60, $16 	# Get field-number*4 from the opcode [1]
/* TagType. */
        and	$19, 63, $19 	# Strip off CDR code. [1]
        sll	$1, $19, $1 	# T1 is type type code bit position. [1]
        and	$7, 1, $7 	# Pop bit [1]
        sll	$17, $16, $2 	# t2 is the mask. [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        s8addq	$7, $12, $12 	# [0di]
        and	$2, $1, $3 	# t3 is the result. [1]
.align 3
G13459:
        cmovne	$3, $4, $5 	# [1]
        stq	$5, 0($12)	#  [0di]
        br	$31, CACHEVALID	# [1]
.end DoTypeMember
/* End of Halfword operand from stack instruction - DoTypeMember */
.align 5
.globl DoPointerPlus
.ent DoPointerPlus 0
/* Halfword operand from stack instruction - DoPointerPlus */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPointerPlusFP
	.globl DoPointerPlusSP
	.globl DoPointerPlusLP
	.globl DoPointerPlusIM
.align 3
DoPointerPlus:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPointerPlusSP"
#endif
.align 3
DoPointerPlusSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoPointerPlus	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoPointerPlus	# [0di]
	.byte 0x90
	.asciiz "DoPointerPlusLP"
#endif
.align 3
DoPointerPlusLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoPointerPlus	# [1]
	.byte 0x84
	.asciiz "DoPointerPlusFP"
#endif
.align 3
DoPointerPlusFP:	# Entry point for FP relative
.align 3
beginDoPointerPlus:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        ldl	$2, 0($16)	# Get the data of op2 [1]
        addl	$21, $2, $3 	# (%32-bit-plus (data arg1) (data arg2)) [3]
        stl	$3, 0($12)	# Put result back on the stack [0di]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
        br	$31, DoPointerPlusIM	# [1]
	.byte 0x82
	.asciiz "DoPointerPlusIM"
#endif
.align 5
.align 3
DoPointerPlusIM:	# Entry point for IMMEDIATE mode
        sll	$17, 56, $2 	# [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        sra	$2, 56, $2 	# [1di]
.align 3
G13460:
        addl	$21, $2, $3 	# (%32-bit-plus (data arg1) (data arg2)) [2]
        stl	$3, 0($12)	# Put result back on the stack [0di]
        br	$31, CACHEVALID	# [1]
.end DoPointerPlus
/* End of Halfword operand from stack instruction - DoPointerPlus */
.align 5
.globl DoLdb
.ent DoLdb 0
/* Field Extraction instruction - DoLdb */
	.globl DoLdbFP
	.globl DoLdbSP
	.globl DoLdbLP
	.globl DoLdbIM
.align 3
DoLdb:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoLdb"
#endif
.align 3
DoLdbIM:
.align 3
DoLdbSP:
.align 3
DoLdbLP:
.align 3
DoLdbFP:
        srl	$18, 37, $16 	# Shift the 'size-1' bits into place [1-]
        and	$17, 31, $17 	# mask out the unwanted bits in arg2 [1]
        and	$16, 31, $16 	# mask out the unwanted bits in arg1 [1]
/* arg1 has size-1, arg2 has position. */
        extll	$21, 4, $18 	# [1]
        extll	$21, 0, $19 	# get ARG1 tag/data [1]
/* TagType. */
        and	$18, 63, $8 	# [1]
        subq	$8, TypeFixnum, $22 	# [1]
        sll	$19, $17, $3 	# Shift ARG1 left to get new high bits [1]
        bne	$22, LDBEXCEPTION	# Not a fixnum [1-]
        lda	$7, -2	#  [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        extll	$3, 4, $6 	# Get new low bits [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        sll	$7, $16, $7 	# Unmask [0di]
        bis	$3, $6, $3 	# Glue two parts of shifted operand together [1]
        stl	$8, 4($12)	# T8 is TypeFixnum from above [0di]
        bic	$3, $7, $3 	# T3= masked value. [1-]
        stl	$3, 0($12)	#  [0di]
        br	$31, CACHEVALID	# [1]
.end DoLdb
/* End of Halfword operand from stack instruction - DoLdb */
.align 5
.globl DoSetSpToAddressSaveTos
.ent DoSetSpToAddressSaveTos 0
/* Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetSpToAddressSaveTosFP
	.globl DoSetSpToAddressSaveTosSP
	.globl DoSetSpToAddressSaveTosLP
	.globl DoSetSpToAddressSaveTosIM
.align 3
DoSetSpToAddressSaveTos:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetSpToAddressSaveTosSP"
#endif
.align 3
DoSetSpToAddressSaveTosSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoSetSpToAddressSaveTos	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoSetSpToAddressSaveTos	# [0di]
	.byte 0x90
	.asciiz "DoSetSpToAddressSaveTosLP"
#endif
.align 3
DoSetSpToAddressSaveTosLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetSpToAddressSaveTos	# [1]
	.byte 0x84
	.asciiz "DoSetSpToAddressSaveTosFP"
#endif
.align 3
DoSetSpToAddressSaveTosFP:	# Entry point for FP relative
.align 3
beginDoSetSpToAddressSaveTos:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$16, $31, $12 	# Set the stack top as specified. [0di]
        stq	$21, 0($16)	# Restore the TOS. [1-]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetSpToAddressSaveTosIM"
#endif
DoSetSpToAddressSaveTosIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetSpToAddressSaveTos.
.end DoSetSpToAddressSaveTos
/* End of Halfword operand from stack instruction - DoSetSpToAddressSaveTos */
.align 5
.globl DoPop
.ent DoPop 0
/* Halfword operand from stack instruction - DoPop */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPopFP
	.globl DoPopSP
	.globl DoPopLP
	.globl DoPopIM
.align 3
DoPop:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPopSP"
#endif
.align 3
DoPopSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoPop	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoPop	# [0di]
	.byte 0x90
	.asciiz "DoPopLP"
#endif
.align 3
DoPopLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoPop	# [1]
	.byte 0x84
	.asciiz "DoPopFP"
#endif
.align 3
DoPopFP:	# Entry point for FP relative
.align 3
beginDoPop:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [0di]
        stq	$21, 0($16)	# Store all 40 bits on stack [1-]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoPopIM"
#endif
DoPopIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoPop.
.end DoPop
/* End of Halfword operand from stack instruction - DoPop */
.align 5
.globl DoMovem
.ent DoMovem 0
/* Halfword operand from stack instruction - DoMovem */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMovemFP
	.globl DoMovemSP
	.globl DoMovemLP
	.globl DoMovemIM
.align 3
DoMovem:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMovemSP"
#endif
.align 3
DoMovemSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoMovem	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoMovem	# [0di]
	.byte 0x90
	.asciiz "DoMovemLP"
#endif
.align 3
DoMovemLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMovem	# [1]
	.byte 0x84
	.asciiz "DoMovemFP"
#endif
.align 3
DoMovemFP:	# Entry point for FP relative
.align 3
beginDoMovem:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$21, 0($16)	# Store all 40 bits of TOS on stack [1]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoMovemIM"
#endif
DoMovemIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoMovem.
.end DoMovem
/* End of Halfword operand from stack instruction - DoMovem */
.align 5
.globl DoPushAddress
.ent DoPushAddress 0
/* Halfword operand from stack instruction - DoPushAddress */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPushAddressFP
	.globl DoPushAddressSP
	.globl DoPushAddressLP
	.globl DoPushAddressIM
.align 3
DoPushAddress:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPushAddressSP"
#endif
.align 3
DoPushAddressSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoPushAddress	# [0di]
	.byte 0x90
	.asciiz "DoPushAddressLP"
#endif
.align 3
DoPushAddressLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoPushAddress	# [1]
	.byte 0x84
	.asciiz "DoPushAddressFP"
#endif
.align 3
DoPushAddressFP:	# Entry point for FP relative
.align 3
beginDoPushAddress:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
/* Convert stack cache address to VMA */
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$16, $2, $2 	# stack cache base relative offset [2di]
        srl	$2, 3, $2 	# convert byte address to word address [1]
        addq	$2, $1, $1 	# reconstruct VMA [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeLocative, $3 	# [1-]
        stl	$1, 8($12)	#  [0di]
        stl	$3, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoPushAddressIM"
#endif
DoPushAddressIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoPushAddress.
.end DoPushAddress
/* End of Halfword operand from stack instruction - DoPushAddress */
.align 5
.globl DoMemoryRead
.ent DoMemoryRead 0
/* Halfword 10 bit immediate instruction - DoMemoryRead */
	.globl DoMemoryReadFP
	.globl DoMemoryReadSP
	.globl DoMemoryReadLP
	.globl DoMemoryReadIM
.align 3
DoMemoryRead:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoMemoryRead"
#endif
.align 3
DoMemoryReadIM:
.align 3
DoMemoryReadSP:
.align 3
DoMemoryReadLP:
.align 3
DoMemoryReadFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        srl	$18, 10, $1 	# Low bit clear if memory-read, set if memory-read-address [1]
        and	$16, 32, $2 	# T2 = fixnum check [1]
        and	$16, 16, $3 	# T3 = reset CDR code [1]
        srl	$16, 6, $18 	# arg3 = cycle type [1]
        extll	$21, 4, $16 	# [1]
        extll	$21, 0, $17 	# Get tag/data [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G13477:
        addq	$17, $14, $7 	# [1di]
        s4addq	$18, $31, $8 	# Cycle-number -> table offset [1]
        ldq_u	$20, 0($7)	#  [1di]
        s4addq	$8, $14, $8 	# [1-]
        s4addq	$7, $31, $21 	# [1]
        subq	$17, $24, $5 	# Stack cache offset [1]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($8)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13479	# [0di]
G13478:
        srl	$8, $20, $8 	# [2-]
        blbs	$8, G13481	# [2]
G13488:
        beq	$2, MRDATAOK	# J. if no check for fixnum. [1]
        subq	$20, TypeFixnum, $5 	# [0di]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, MRNOTFIXNUM	# [1]
.align 3
MRDATAOK:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        cmovlbs	$1, $16, $20 	# Get original tag if memory-read-address [0di]
        beq	$3, MRCDRUNCH	# J. if no reset CDR code [1-]
/* TagType. */
        and	$20, 63, $20 	# [1di]
.align 3
MRCDRUNCH:
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovlbs	$1, $17, $21 	# Get forwarded address if memory-read-address [0di]
        stl	$21, 0($12)	#  [1-]
        stl	$20, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
MRNOTFIXNUM:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 5, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13481:
.align 3
G13479:
	bsr	$0, MemoryReadGeneralDECODE
        br	$31, G13488	# [1-]
.end DoMemoryRead
/* End of Halfword operand from stack instruction - DoMemoryRead */
.align 5
.globl DoBranch
.ent DoBranch 0
/* Halfword 10 bit immediate instruction - DoBranch */
	.globl DoBranchFP
	.globl DoBranchSP
	.globl DoBranchLP
	.globl DoBranchIM
.align 3
DoBranch:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranch"
#endif
.align 3
DoBranchIM:
.align 3
DoBranchSP:
.align 3
DoBranchLP:
.align 3
DoBranchFP:
        sra	$18, 48, $16 	# [1-]
/* arg1 has signed operand preloaded. */
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        addq	$9, $16, $9 	# Update the PC in halfwords [2-]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [1di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranch
/* End of Halfword operand from stack instruction - DoBranch */
.align 5
.globl DoGenericDispatch
.ent DoGenericDispatch 0
/* Halfword operand from stack instruction - DoGenericDispatch */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoGenericDispatchFP
	.globl DoGenericDispatchSP
	.globl DoGenericDispatchLP
	.globl DoGenericDispatchIM
.align 3
DoGenericDispatch:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoGenericDispatchSP"
#endif
.align 3
DoGenericDispatchSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoGenericDispatch	# [0di]
	.byte 0x90
	.asciiz "DoGenericDispatchLP"
#endif
.align 3
DoGenericDispatchLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoGenericDispatch	# [1]
	.byte 0x84
	.asciiz "DoGenericDispatchFP"
#endif
.align 3
DoGenericDispatchFP:	# Entry point for FP relative
.align 3
beginDoGenericDispatch:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$17, PROCESSORSTATE_CONTROL($14)	#  [1]
        ldl	$16, 20($10)	# get generic tag and data [1]
        ldl	$1, 16($10)	#  [1]
        and	$17, 255, $20 	# get number of arguments [1-]
        ldl	$18, 28($10)	# get instance tag and data [0di]
        ldl	$19, 24($10)	#  [1]
        subq	$20, 4, $20 	# done if 2 or more arguments (plus 2 extra words) [0di]
        blt	$20, VerifyGenericArity	# [1]
        extll	$1, 0, $1 	# [0di]
        extll	$19, 0, $19 	# [2]
	bsr	$0, LookupHandler
        subq	$4, TypeEvenPC, $3 	# [1]
        and	$3, 62, $3 	# Strip CDR code, low bits [1]
        bne	$3, G13490	# [1]
        and	$6, 63, $3 	# Strip CDR code [1]
        subq	$3, TypeNIL, $3 	# [1]
        beq	$3, G13489	# [1]
        stl	$7, 16($10)	#  [1]
        stl	$6, 20($10)	# write the stack cache [1]
.align 3
G13489:
/* Convert real continuation to PC. */
        and	$4, 1, $9 	# [1-]
        addq	$22, $9, $9 	# [1]
        addq	$22, $9, $9 	# [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [0di]
.align 3
G13490:
/* Convert stack cache address to VMA */
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $2, $2 	# stack cache base relative offset [2-]
        srl	$2, 3, $2 	# convert byte address to word address [1]
        addq	$2, $3, $3 	# reconstruct VMA [2]
        bis	$31, $3, $20 	# [1]
        bis	$31, 37, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
	.byte 0x82
	.asciiz "DoGenericDispatchIM"
#endif
DoGenericDispatchIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoGenericDispatch.
.end DoGenericDispatch
/* End of Halfword operand from stack instruction - DoGenericDispatch */
.align 5
.globl LookupHandler
.ent LookupHandler 0
.align 3
LookupHandler:
        lda	$30, -8($30)	#  [1]
	.frame $30, 8, $0
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        subq	$18, TypeInstance, $5 	# [0di]
        and	$5, 60, $5 	# Strip CDR code, low bits [1]
        bne	$5, G13494	# [1]
        bis	$19, $31, $17 	# Don't clobber instance if it's forwarded [1-]
/* Memory Read Internal */
G13495:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13497	# [0di]
G13496:
        lda	$7, 64	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13499	# [1-]
G13504:
.align 3
G13493:
        bis	$21, $31, $17 	# [1-]
/* Memory Read Internal */
G13505:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13507	# [0di]
G13506:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13509	# [1-]
G13516:
        bis	$21, $31, $2 	# [1di]
        subq	$20, TypeFixnum, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G13491	# [1]
        addq	$17, 1, $17 	# [0di]
/* Memory Read Internal */
G13517:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13519	# [1-]
G13518:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13521	# [0di]
G13528:
        bis	$21, $31, $3 	# [2-]
        subq	$20, TypeLocative, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G13492	# [1]
        and	$2, $1, $17 	# [1-]
        sll	$17, 1, $5 	# [1]
        addq	$17, $5, $19 	# (* (logand mask data) 3) [2]
/* TagType. */
        and	$16, 63, $16 	# [1]
.align 3
G13530:
        addq	$3, $19, $17 	# [1]
        addq	$19, 3, $19 	# [1]
/* Read key */
/* Memory Read Internal */
G13531:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13533	# [1-]
G13532:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13535	# [1-]
G13542:
/* TagType. */
        and	$20, 63, $20 	# [0di]
        cmpeq	$20, TypeNIL, $5 	# [1]
        bne	$5, G13529	# [1]
        cmpeq	$16, $20, $5 	# [1]
        beq	$5, G13530	# [1]
        subl	$1, $21, $5 	# [1]
        bne	$5, G13530	# [1]
.align 3
G13529:
/* Read method */
        addq	$17, 1, $17 	# [1-]
/* Memory Read Internal */
G13543:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13545	# [0di]
G13544:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13547	# [1-]
G13554:
        bis	$20, $31, $4 	# [0di]
        bis	$21, $31, $18 	# [1]
/* Read parameter */
        addq	$17, 1, $17 	# [1]
/* Memory Read Internal */
G13555:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13557	# [1-]
G13556:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13559	# [0di]
G13566:
        bis	$20, $31, $6 	# [1-]
        bis	$21, $31, $7 	# [1]
        bis	$18, $31, $22 	# [1]
        lda	$30, 8($30)	#  [1]
        ret	$31, ($0), 1	# [1-]
.align 3
G13559:
        blbc	$7, G13558	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13555	# [2-]
.align 3
G13558:
.align 3
G13557:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13566	# [1]
.align 3
G13547:
        blbc	$7, G13546	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13543	# [1-]
.align 3
G13546:
.align 3
G13545:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13554	# [1]
.align 3
G13535:
        blbc	$7, G13534	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13531	# [1-]
.align 3
G13534:
.align 3
G13533:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13542	# [1]
.align 3
G13521:
        blbc	$7, G13520	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13517	# [1-]
.align 3
G13520:
.align 3
G13519:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13528	# [1]
.align 3
G13509:
        blbc	$7, G13508	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13505	# [1-]
.align 3
G13508:
.align 3
G13507:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13516	# [1]
.align 3
G13499:
        blbc	$7, G13498	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13495	# [1-]
.align 3
G13498:
.align 3
G13497:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadHeaderDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13504	# [1]
.align 3
G13494:
/* not an instance, flavor description comes from magic vector */
        ldq	$17, PROCESSORSTATE_TRAPVECBASE($14)	#  [1]
/* TagType. */
        and	$18, 63, $5 	# [0di]
        lda	$17, 2560($17)	#  [3]
        addq	$5, $17, $17 	# [1]
/* Memory Read Internal */
G13567:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13569	# [1-]
G13568:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13571	# [0di]
        br	$31, G13493	# [1]
.align 3
G13491:
        bis	$31, $17, $20 	# [1-]
        bis	$31, 34, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13492:
        bis	$31, $17, $20 	# [1]
        bis	$31, 35, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13571:
        blbc	$7, G13570	# [1-]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13567	# [1-]
.align 3
G13570:
.align 3
G13569:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13493	# [1]
.end LookupHandler
.align 5
.globl DoSetTag
.ent DoSetTag 0
/* Halfword operand from stack instruction - DoSetTag */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetTagFP
	.globl DoSetTagSP
	.globl DoSetTagLP
	.globl DoSetTagIM
.align 3
DoSetTag:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetTagSP"
#endif
.align 3
DoSetTagSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetTag	# [0di]
	.byte 0x90
	.asciiz "DoSetTagLP"
#endif
.align 3
DoSetTagLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetTag	# [1]
	.byte 0x84
	.asciiz "DoSetTagFP"
#endif
.align 3
DoSetTagFP:	# Entry point for FP relative
.align 3
beginDoSetTag:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, 4($16)	# Get tag/data of op2 [2]
        ldl	$17, 0($16)	#  [1]
        subq	$1, TypeFixnum, $3 	# [2di]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, SETTAGEXC	# [1]
#ifdef TRACING
        br	$31, DoSetTagIM	# [1]
	.byte 0x82
	.asciiz "DoSetTagIM"
#endif
.align 5
.align 3
DoSetTagIM:	# Entry point for IMMEDIATE mode
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$17, 4($12)	# Set TAG of op1 [1]
        br	$31, CACHEVALID	# [1]
.align 3
SETTAGEXC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoSetTag
/* End of Halfword operand from stack instruction - DoSetTag */
.align 5
.globl DoCar
.ent DoCar 0
/* Halfword operand from stack instruction - DoCar */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoCarFP
	.globl DoCarSP
	.globl DoCarLP
	.globl DoCarIM
.align 3
DoCar:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoCarSP"
#endif
.align 3
DoCarSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoCar	# [0di]
	.byte 0x90
	.asciiz "DoCarLP"
#endif
.align 3
DoCarLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoCar	# [1]
	.byte 0x84
	.asciiz "DoCarFP"
#endif
.align 3
DoCarFP:	# Entry point for FP relative
.align 3
beginDoCar:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$20, 4($16)	# Get the operand from the stack. [1]
        ldl	$21, 0($16)	#  [1]
	bsr	$0, CarInternal
        and	$20, 63, $5 	# set CDR-NEXT [2di]
        stl	$21, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoCarIM"
#endif
DoCarIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoCar.
.end DoCar
/* End of Halfword operand from stack instruction - DoCar */
.align 5
.globl CarInternal
.ent CarInternal 11
.align 3
CarInternal:
        lda	$30, -8($30)	#  [1-]
	.frame $30, 8, $0
        extll	$21, $31, $17 	# [1]
        and	$20, 63, $5 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeList, $6 	# [1]
.align 3
G13598:
        beq	$6, G13581	# [1]
/* Here if argument TypeList */
G13578:
/* Memory Read Internal */
G13582:
        addq	$17, $14, $7 	# [0di]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13584	# [0di]
G13583:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13586	# [1-]
G13593:
.align 3
G13580:
.align 3
G13579:
        lda	$30, 8($30)	#  [1-]
        ret	$31, ($0), 1	# [0di]
.align 3
G13581:
        cmpeq	$5, TypeNIL, $6 	# [1-]
.align 3
G13599:
        bne	$6, G13580	# [1]
.align 3
G13594:
        cmpeq	$5, TypeLocative, $6 	# [1]
.align 3
G13600:
        bne	$6, G13578	# [1]
.align 3
G13595:
/* Here for all other cases */
        bis	$31, $20, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LISTEXCEPTION
.align 3
G13586:
        blbc	$7, G13585	# [1-]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13582	# [1-]
.align 3
G13585:
.align 3
G13584:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13593	# [1]
.end CarInternal
.align 5
.globl DoCdr
.ent DoCdr 0
/* Halfword operand from stack instruction - DoCdr */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoCdrFP
	.globl DoCdrSP
	.globl DoCdrLP
	.globl DoCdrIM
.align 3
DoCdr:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoCdrSP"
#endif
.align 3
DoCdrSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoCdr	# [0di]
	.byte 0x90
	.asciiz "DoCdrLP"
#endif
.align 3
DoCdrLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoCdr	# [1]
	.byte 0x84
	.asciiz "DoCdrFP"
#endif
.align 3
DoCdrFP:	# Entry point for FP relative
.align 3
beginDoCdr:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$20, 4($16)	# Get the operand from the stack. [1]
        ldl	$21, 0($16)	#  [1]
	bsr	$0, CdrInternal
        and	$20, 63, $5 	# set CDR-NEXT [2di]
        stl	$21, 8($12)	#  [1-]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoCdrIM"
#endif
DoCdrIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoCdr.
.end DoCdr
/* End of Halfword operand from stack instruction - DoCdr */
.align 5
.globl CdrInternal
.ent CdrInternal 11
.align 3
CdrInternal:
        lda	$30, -8($30)	#  [1-]
	.frame $30, 8, $0
        extll	$21, 0, $17 	# [1]
        and	$20, 63, $5 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeList, $6 	# [1]
.align 3
G13636:
        beq	$6, G13604	# [1]
/* Here if argument TypeList */
/* Memory Read Internal */
G13605:
        addq	$17, $14, $7 	# [0di]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_CDR_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13607	# [0di]
G13606:
        lda	$7, 192	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13609	# [1di]
G13614:
        and	$20, 192, $5 	# Extract CDR code. [1-]
        bne	$5, G13616	# [1]
/* Here if argument 0 */
        addq	$17, 1, $21 	# Address of next position is CDR [1-]
        bis	$31, TypeList, $20 	# [1]
.align 3
G13615:
.align 3
G13603:
.align 3
G13602:
        lda	$30, 8($30)	#  [1]
        ret	$31, ($0), 1	# [0di]
.align 3
G13604:
        cmpeq	$5, TypeNIL, $6 	# [1-]
.align 3
G13637:
        bne	$6, G13603	# [1]
.align 3
G13632:
        cmpeq	$5, TypeLocative, $6 	# [1]
.align 3
G13638:
        bne	$6, G13601	# [1]
.align 3
G13633:
/* Here for all other cases */
        bis	$31, $20, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LISTEXCEPTION
.align 3
G13616:
        cmpeq	$5, 128, $6 	# [1]
.align 3
G13639:
        beq	$6, G13617	# [1]
/* Here if argument 128 */
        addq	$17, 1, $17 	# [0di]
.align 3
G13601:
/* Memory Read Internal */
G13618:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13620	# [1-]
G13619:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13622	# [0di]
        br	$31, G13602	# [1]
.align 3
G13617:
        cmpeq	$5, 64, $6 	# [1-]
.align 3
G13640:
        beq	$6, G13629	# [1]
/* Here if argument 64 */
        ldl	$21, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_NILADDRESS+4($14)	#  [1]
        extll	$21, 0, $21 	# [2di]
        br	$31, G13602	# [1-]
.align 3
G13629:
/* Here for all other cases */
        bis	$31, $17, $20 	# [1-]
        bis	$31, 15, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13622:
        blbc	$7, G13621	# [1-]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13618	# [1-]
.align 3
G13621:
.align 3
G13620:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13602	# [1]
.align 3
G13609:
        blbc	$7, G13608	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13605	# [1-]
.align 3
G13608:
.align 3
G13607:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadCdrDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G13614	# [1]
.end CdrInternal
.align 5
.globl DoReadInternalRegister
.ent DoReadInternalRegister 0
/* Halfword 10 bit immediate instruction - DoReadInternalRegister */
	.globl DoReadInternalRegisterFP
	.globl DoReadInternalRegisterSP
	.globl DoReadInternalRegisterLP
	.globl DoReadInternalRegisterIM
.align 3
DoReadInternalRegister:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoReadInternalRegister"
#endif
.align 3
DoReadInternalRegisterIM:
.align 3
DoReadInternalRegisterSP:
.align 3
DoReadInternalRegisterLP:
.align 3
DoReadInternalRegisterFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        ldq	$2, PROCESSORSTATE_INTERNALREGISTERREAD2($14)	#  [0di]
        subl	$16, 512, $3 	# [2-]
        ldq	$1, PROCESSORSTATE_INTERNALREGISTERREAD1($14)	#  [0di]
        bge	$3, G13641	# We're in the 1000's [1-]
        and	$16, 63, $3 	# Keep only six bits [1]
        cmple	$3, 42, $2 	# In range for the low registers? [1]
        s8addq	$3, $1, $3 	# [1]
        beq	$2, ReadRegisterError	# [1-]
        ldq	$3, 0($3)	#  [1di]
        jmp	$31, ($3), 0	# Jump to the handler [3]
.align 3
G13641:
        cmple	$3, 33, $1 	# In range for the high registers? [1-]
        s8addq	$3, $2, $3 	# [1]
        beq	$1, ReadRegisterError	# [1-]
        ldq	$3, 0($3)	#  [1di]
        jmp	$31, ($3), 0	# Jump to the handler [3]
.end DoReadInternalRegister
/* End of Halfword operand from stack instruction - DoReadInternalRegister */
.align 5
.globl DoWriteInternalRegister
.ent DoWriteInternalRegister 0
/* Halfword 10 bit immediate instruction - DoWriteInternalRegister */
	.globl DoWriteInternalRegisterFP
	.globl DoWriteInternalRegisterSP
	.globl DoWriteInternalRegisterLP
	.globl DoWriteInternalRegisterIM
.align 3
DoWriteInternalRegister:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoWriteInternalRegister"
#endif
.align 3
DoWriteInternalRegisterIM:
.align 3
DoWriteInternalRegisterSP:
.align 3
DoWriteInternalRegisterLP:
.align 3
DoWriteInternalRegisterFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        extll	$21, 4, $17 	# [1]
        extll	$21, 0, $18 	# Arg2=tag arg3=data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$2, PROCESSORSTATE_INTERNALREGISTERWRITE2($14)	#  [1-]
        subl	$16, 512, $3 	# [0di]
        ldq	$1, PROCESSORSTATE_INTERNALREGISTERWRITE1($14)	#  [1-]
        bge	$3, G13642	# We're in the 1000's [0di]
        and	$16, 63, $3 	# Keep only six bits [1]
        cmple	$3, 42, $2 	# In range for the low registers? [1]
        s8addq	$3, $1, $3 	# [1]
        beq	$2, WriteRegisterError	# [0di]
        ldq	$3, 0($3)	#  [2-]
        jmp	$31, ($3), 0	# Jump to the handler [3]
.align 3
G13642:
        cmple	$3, 33, $1 	# In range for the high registers? [1-]
        s8addq	$3, $2, $3 	# [1]
        beq	$1, WriteRegisterError	# [1-]
        ldq	$3, 0($3)	#  [1di]
        jmp	$31, ($3), 0	# Jump to the handler [3]
.end DoWriteInternalRegister
/* End of Halfword operand from stack instruction - DoWriteInternalRegister */
.align 5
.globl WriteRegisterBARx
.ent WriteRegisterBARx 0
.align 3
WriteRegisterBARx:
        srl	$16, 7, $2 	# BAR number into T2 [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        sll	$17, 32, $3 	# Make a quadword from tag and data [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        lda	$1, PROCESSORSTATE_BAR0($14)	#  [1-]
        s8addq	$2, $1, $1 	# Now T1 points to the BAR [1]
        bis	$3, $18, $3 	# Construct the combined word [1]
        stq	$3, 0($1)	#  [1di]
        br	$31, CACHEVALID	# [1]
.end WriteRegisterBARx
.align 5
.globl DoBlock3Read
.ent DoBlock3Read 0
/* Halfword 10 bit immediate instruction - DoBlock3Read */
	.globl DoBlock3ReadFP
	.globl DoBlock3ReadSP
	.globl DoBlock3ReadLP
	.globl DoBlock3ReadIM
.align 3
DoBlock3Read:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock3Read"
#endif
.align 3
DoBlock3ReadIM:
.align 3
DoBlock3ReadSP:
.align 3
DoBlock3ReadLP:
.align 3
DoBlock3ReadFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$19, PROCESSORSTATE_BAR3($14)	#  [1]
        br	$31, BlockRead	# [1-]
.end DoBlock3Read
/* End of Halfword operand from stack instruction - DoBlock3Read */
.align 5
.globl DoBlock2Read
.ent DoBlock2Read 0
/* Halfword 10 bit immediate instruction - DoBlock2Read */
	.globl DoBlock2ReadFP
	.globl DoBlock2ReadSP
	.globl DoBlock2ReadLP
	.globl DoBlock2ReadIM
.align 3
DoBlock2Read:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock2Read"
#endif
.align 3
DoBlock2ReadIM:
.align 3
DoBlock2ReadSP:
.align 3
DoBlock2ReadLP:
.align 3
DoBlock2ReadFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$19, PROCESSORSTATE_BAR2($14)	#  [1]
        br	$31, BlockRead	# [1-]
.end DoBlock2Read
/* End of Halfword operand from stack instruction - DoBlock2Read */
.align 5
.globl DoBlock1Read
.ent DoBlock1Read 0
/* Halfword 10 bit immediate instruction - DoBlock1Read */
	.globl DoBlock1ReadFP
	.globl DoBlock1ReadSP
	.globl DoBlock1ReadLP
	.globl DoBlock1ReadIM
.align 3
DoBlock1Read:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock1Read"
#endif
.align 3
DoBlock1ReadIM:
.align 3
DoBlock1ReadSP:
.align 3
DoBlock1ReadLP:
.align 3
DoBlock1ReadFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$19, PROCESSORSTATE_BAR1($14)	#  [1]
.align 3
BlockRead:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$17, 0($19)	# Get the vma [1]
        srl	$16, 6, $18 	# cycle type [0di]
        and	$16, 4, $2 	# =no-incrementp [1]
        and	$16, 16, $3 	# =cdr-code-nextp [1]
        and	$16, 32, $4 	# =fixnum onlyp [1]
        extll	$17, 0, $17 	# [1]
/* Do the read cycle */
/* Memory Read Internal */
G13646:
        addq	$17, $14, $7 	# [2]
        s4addq	$18, $31, $8 	# Cycle-number -> table offset [1]
        ldq_u	$20, 0($7)	#  [1-]
        s4addq	$8, $14, $8 	# [0di]
        s4addq	$7, $31, $21 	# [1]
        subq	$17, $24, $5 	# Stack cache offset [1]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($8)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [0di]
        bne	$6, G13648	# [1-]
G13647:
        srl	$8, $20, $8 	# [1di]
        blbs	$8, G13650	# [2]
G13657:
        bne	$4, G13643	# J. if we have to test for fixnump. [1]
G13644:
        addq	$17, 1, $4 	# Compute Incremented address [1]
.align 3
G13658:
        cmoveq	$2, $4, $17 	# Conditionally update address [1]
        stl	$17, 0($19)	# Store updated vma in BAR [0di]
        and	$20, 63, $2 	# Compute CDR-NEXT [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        cmovne	$3, $2, $20 	# Conditionally Set CDR-NEXT [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        stl	$21, 8($12)	#  [1]
        stl	$20, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G13645:
        bis	$31, $17, $20 	# [1-]
        bis	$31, 23, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Not a fixnum
.align 3
G13650:
.align 3
G13648:
	bsr	$0, MemoryReadGeneralDECODE
        br	$31, G13657	# [1-]
.align 3
G13643:
        subq	$20, TypeFixnum, $5 	# [1-]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G13645	# [1]
        br	$31, G13644	# [1]
.end DoBlock1Read
/* End of Halfword operand from stack instruction - DoBlock1Read */
.align 5
.globl DoBlock2Write
.ent DoBlock2Write 0
/* Halfword operand from stack instruction - DoBlock2Write */
	.globl DoBlock2WriteFP
	.globl DoBlock2WriteSP
	.globl DoBlock2WriteLP
	.globl DoBlock2WriteIM
.align 3
DoBlock2Write:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoBlock2WriteIM"
#endif
.align 3
DoBlock2WriteIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G13675:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoBlock2Write	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock2WriteSP"
#endif
.align 3
DoBlock2WriteSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoBlock2Write	# [0di]
	.byte 0x90
	.asciiz "DoBlock2WriteLP"
#endif
.align 3
DoBlock2WriteLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoBlock2Write	# [1]
	.byte 0x84
	.asciiz "DoBlock2WriteFP"
#endif
.align 3
DoBlock2WriteFP:	# Entry point for FP relative
.align 3
headDoBlock2Write:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoBlock2Write:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$18, PROCESSORSTATE_BAR2($14)	#  [1]
        lda	$17, PROCESSORSTATE_BAR2($14)	#  [0di]
        br	$31, BlockWrite	# [1-]
.end DoBlock2Write
/* End of Halfword operand from stack instruction - DoBlock2Write */
.align 5
.globl DoBlock1Write
.ent DoBlock1Write 0
/* Halfword operand from stack instruction - DoBlock1Write */
	.globl DoBlock1WriteFP
	.globl DoBlock1WriteSP
	.globl DoBlock1WriteLP
	.globl DoBlock1WriteIM
.align 3
DoBlock1Write:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoBlock1WriteIM"
#endif
.align 3
DoBlock1WriteIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G13679:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoBlock1Write	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock1WriteSP"
#endif
.align 3
DoBlock1WriteSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoBlock1Write	# [0di]
	.byte 0x90
	.asciiz "DoBlock1WriteLP"
#endif
.align 3
DoBlock1WriteLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoBlock1Write	# [1]
	.byte 0x84
	.asciiz "DoBlock1WriteFP"
#endif
.align 3
DoBlock1WriteFP:	# Entry point for FP relative
.align 3
headDoBlock1Write:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoBlock1Write:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$18, PROCESSORSTATE_BAR1($14)	#  [1]
        lda	$17, PROCESSORSTATE_BAR1($14)	#  [0di]
.align 3
BlockWrite:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$18, 0, $18 	# Unsigned vma [1-]
        srl	$16, 32, $2 	# Get tag [1]
        extll	$16, 0, $3 	# Get data [1]
        addq	$18, $14, $8 	# [1]
        s4addq	$8, $31, $6 	# [1]
        ldq_u	$5, 0($8)	#  [1di]
        subq	$18, $24, $4 	# Stack cache offset [1-]
        cmpult	$4, $25, $7 	# In range? [1]
        insbl	$2, $8, $4 	# [1]
        mskbl	$5, $8, $5 	# [1]
.align 3
G13678:
        bis	$5, $4, $5 	# [2]
        stq_u	$5, 0($8)	#  [0di]
        stl	$3, 0($6)	#  [1]
        bne	$7, G13677	# J. if in cache [1]
G13676:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        addq	$18, 1, $18 	# Increment the address [1-]
        stl	$18, 0($17)	# Store updated vma in BAR [0di]
        br	$31, CACHEVALID	# [1]
.align 3
G13677:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$18, $24, $4 	# Stack cache offset [0di]
        s8addq	$4, $8, $8 	# reconstruct SCA [3]
        stl	$3, 0($8)	# Store in stack [2]
        stl	$2, 4($8)	# write the stack cache [1]
        br	$31, G13676	# [1]
.end DoBlock1Write
/* End of Halfword operand from stack instruction - DoBlock1Write */
.align 5
.globl DoBranchTrueNoPop
.ent DoBranchTrueNoPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueNoPop */
	.globl DoBranchTrueNoPopFP
	.globl DoBranchTrueNoPopSP
	.globl DoBranchTrueNoPopLP
	.globl DoBranchTrueNoPopIM
.align 3
DoBranchTrueNoPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueNoPop"
#endif
.align 3
DoBranchTrueNoPopIM:
.align 3
DoBranchTrueNoPopSP:
.align 3
DoBranchTrueNoPopLP:
.align 3
DoBranchTrueNoPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, NEXTINSTRUCTION	# [1]
        beq	$16, BranchException	# Can't branch to ourself [1]
        addq	$9, $16, $9 	# Update the PC in halfwords [0di]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [1-]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueNoPop
/* End of Halfword operand from stack instruction - DoBranchTrueNoPop */
.align 5
.globl DoBranchFalseNoPop
.ent DoBranchFalseNoPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseNoPop */
	.globl DoBranchFalseNoPopFP
	.globl DoBranchFalseNoPopSP
	.globl DoBranchFalseNoPopLP
	.globl DoBranchFalseNoPopIM
.align 3
DoBranchFalseNoPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseNoPop"
#endif
.align 3
DoBranchFalseNoPopIM:
.align 3
DoBranchFalseNoPopSP:
.align 3
DoBranchFalseNoPopLP:
.align 3
DoBranchFalseNoPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, NEXTINSTRUCTION	# [1]
        beq	$16, BranchException	# Can't branch to ourself [1]
        addq	$9, $16, $9 	# Update the PC in halfwords [0di]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [1-]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseNoPop
/* End of Halfword operand from stack instruction - DoBranchFalseNoPop */
.globl callgenericprefetch
.align 5
.globl callgeneric
.ent callgeneric 0
/* Fullword instruction - callgeneric */
#ifdef TRACING
	.byte 0x80
	.asciiz "callgeneric"
#endif
.align 3
callgeneric:
.align 3
callgenericprefetch:
        ldq	$3, PROCESSORSTATE_TRAPVECBASE($14)	#  [1]
        bis	$18, $31, $19 	# Get operand [0di]
        bis	$31, TypeGenericFunction, $18 	# [1]
        bis	$31, TypeEvenPC, $20 	# [1]
        lda	$21, 2636($3)	#  [1]
        br	$31, STARTCALLCOMPILEDMERGE	# [0di]
.end callgeneric
/* End of Fullword instruction - callgeneric */
.globl callcompiledevenprefetch
.align 5
.globl callcompiledeven
.ent callcompiledeven 0
/* Fullword instruction - callcompiledeven */
#ifdef TRACING
	.byte 0x80
	.asciiz "callcompiledeven"
#endif
.align 3
callcompiledeven:
.align 3
callcompiledevenprefetch:
        bis	$18, $31, $21 	# Get operand [1-]
        bis	$31, TypeEvenPC, $20 	# [1]
        bis	$31, $31, $18 	# No extra arg [1]
        br	$31, STARTCALLCOMPILEDMERGE	# [0di]
.end callcompiledeven
/* End of Fullword instruction - callcompiledeven */
.align 5
.globl DoStartCall
.ent DoStartCall 0
/* Halfword operand from stack instruction - DoStartCall */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoStartCallFP
	.globl DoStartCallSP
	.globl DoStartCallLP
	.globl DoStartCallIM
.align 3
DoStartCall:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoStartCallSP"
#endif
.align 3
DoStartCallSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoStartCall	# [0di]
	.byte 0x90
	.asciiz "DoStartCallLP"
#endif
.align 3
DoStartCallLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoStartCall	# [1]
	.byte 0x84
	.asciiz "DoStartCallFP"
#endif
.align 3
DoStartCallFP:	# Entry point for FP relative
.align 3
beginDoStartCall:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$20, 4($16)	#  [1]
        ldl	$21, 0($16)	#  [1]
.align 3
STARTCALLAGAIN:
.align 3
G13682:
        ldq	$1, PROCESSORSTATE_TRAPVECBASE($14)	#  [1]
        and	$20, 63, $2 	# Strip off any CDR code bits. [1di]
        cmpeq	$2, TypeCompiledFunction, $3 	# [1]
.align 3
G13731:
        beq	$3, G13688	# [1]
/* Here if argument TypeCompiledFunction */
.align 3
G13683:
        bis	$31, $31, $18 	# No extra argument [1-]
.align 3
G13684:
        bis	$31, TypeEvenPC, $20 	# [1]
.align 3
STARTCALLCOMPILEDMERGE:
        ldl	$7, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        addq	$12, 16, $12 	# prepare to push continuation/control register [0di]
        ldl	$3, PROCESSORSTATE_CONTROL($14)	#  [1-]
        bis	$31, TypeFixnum+0xC0, $6 	# [0di]
        ldl	$8, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        ldah	$5, 64	#  [0di]
        bis	$7, 192, $7 	# Set CDR code 3 [1]
        stl	$8, -8($12)	# push continuation [0di]
        stl	$7, -4($12)	# write the stack cache [1]
        bis	$3, $5, $8 	# Set call started bit in CR [0di]
        lda	$5, 256	#  [1]
        stl	$3, 0($12)	# Push control register [0di]
        stl	$6, 4($12)	# write the stack cache [1]
        bic	$8, $5, $8 	# Clear the extra arg bit [0di]
        stl	$8, PROCESSORSTATE_CONTROL($14)	# Save control with new state [1-]
/* End of push-frame */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$21, PROCESSORSTATE_CONTINUATION($14)	#  [1]
        stl	$20, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1]
        bne	$18, G13685	# [1]
        br	$31, CACHEVALID	# [1]
.align 3
G13685:
        ldl	$1, PROCESSORSTATE_CONTROL($14)	#  [1]
        lda	$2, 256	#  [0di]
        and	$18, 63, $3 	# set CDR-NEXT [1]
        stl	$19, 8($12)	# Push the extra arg. [0di]
        stl	$3, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$1, $2, $1 	# Set the extra arg bit [1]
        stl	$1, PROCESSORSTATE_CONTROL($14)	# Save control with new state [0di]
        br	$31, CACHEVALID	# [1]
.align 3
G13688:
        cmpeq	$2, TypeGenericFunction, $3 	# [1-]
.align 3
G13732:
        beq	$3, G13689	# [1]
/* Here if argument TypeGenericFunction */
        bis	$20, $31, $18 	# [0di]
        extll	$21, 0, $19 	# [1]
        lda	$21, 2636($1)	#  [1]
        br	$31, G13684	# [1-]
.align 3
G13689:
        cmpeq	$2, TypeInstance, $3 	# [1-]
.align 3
G13733:
        beq	$3, G13690	# [1]
/* Here if argument TypeInstance */
        bis	$20, $31, $18 	# [0di]
        extll	$21, 0, $19 	# [1]
        lda	$21, 2638($1)	#  [1]
        br	$31, G13684	# [1-]
.align 3
G13690:
        cmpeq	$2, TypeSymbol, $3 	# [1-]
.align 3
G13734:
        beq	$3, G13691	# [1]
/* Here if argument TypeSymbol */
        extll	$21, 0, $21 	# [0di]
        bis	$31, $31, $18 	# No extra argument [1]
        addq	$21, 2, $17 	# Get to the function cell [1]
        br	$31, STARTCALLINDIRECT	# [1-]
.align 3
G13691:
        cmpeq	$2, TypeLexicalClosure, $3 	# [1-]
.align 3
G13735:
        beq	$3, G13692	# [1]
/* Here if argument TypeLexicalClosure */
        extll	$21, 0, $17 	# [0di]
/* Memory Read Internal */
G13693:
        addq	$17, $14, $7 	# [2]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13695	# [1-]
G13694:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13697	# [1-]
G13704:
        bis	$20, $31, $18 	# [0di]
        bis	$21, $31, $19 	# [1]
        addq	$17, 1, $17 	# [1]
.align 3
STARTCALLINDIRECT:
/* Memory Read Internal */
G13705:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13707	# [1-]
G13706:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13709	# [1-]
G13716:
        subq	$20, TypeCompiledFunction, $5 	# [0di]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G13682	# [1]
        br	$31, G13684	# [1]
.align 3
G13692:
/* Here for all other cases */
.align 3
G13680:
        bis	$20, $31, $18 	# [1-]
        bis	$21, $31, $19 	# [1]
        lda	$3, 2304($1)	#  [1]
/* TagType. */
        and	$20, 63, $20 	# [1]
        addq	$20, $3, $17 	# [1]
/* Memory Read Internal */
G13718:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13720	# [0di]
G13719:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13722	# [1di]
G13729:
        subq	$20, TypeEvenPC, $3 	# [1-]
        and	$3, 63, $3 	# Strip CDR code, low bits [1]
        bne	$3, G13681	# [1]
        br	$31, G13684	# [1]
.align 3
G13687:
.align 3
G13681:
        bis	$31, $1, $20 	# [1-]
        bis	$31, 51, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Bad type for start-call
.align 3
G13722:
        blbc	$7, G13721	# [1-]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13718	# [1-]
.align 3
G13721:
.align 3
G13720:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13729	# [1]
.align 3
G13709:
        blbc	$7, G13708	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13705	# [1-]
.align 3
G13708:
.align 3
G13707:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13716	# [1]
.align 3
G13697:
        blbc	$7, G13696	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13693	# [1-]
.align 3
G13696:
.align 3
G13695:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13704	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoStartCallIM"
#endif
DoStartCallIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoStartCall.
.end DoStartCall
/* End of Halfword operand from stack instruction - DoStartCall */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifuncom1.as */
