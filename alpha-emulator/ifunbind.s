/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunbind.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Binding Instructions. */
.align 5
.globl DoBindLocativeToValue
.ent DoBindLocativeToValue 0
/* Halfword operand from stack instruction - DoBindLocativeToValue */
	.globl DoBindLocativeToValueFP
	.globl DoBindLocativeToValueSP
	.globl DoBindLocativeToValueLP
	.globl DoBindLocativeToValueIM
.align 3
DoBindLocativeToValue:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoBindLocativeToValueIM"
#endif
.align 3
DoBindLocativeToValueIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G15776:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoBindLocativeToValue	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBindLocativeToValueSP"
#endif
.align 3
DoBindLocativeToValueSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoBindLocativeToValue	# [0di]
	.byte 0x90
	.asciiz "DoBindLocativeToValueLP"
#endif
.align 3
DoBindLocativeToValueLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoBindLocativeToValue	# [1]
	.byte 0x84
	.asciiz "DoBindLocativeToValueFP"
#endif
.align 3
DoBindLocativeToValueFP:	# Entry point for FP relative
.align 3
headDoBindLocativeToValue:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoBindLocativeToValue:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$21, 0($12)	# ltag/ldata [1]
        ldl	$20, 4($12)	# ltag/ldata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$21, 0, $21 	# [1]
        ldq	$18, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        srl	$16, 32, $17 	# new tag [0di]
        ldq	$19, PROCESSORSTATE_BINDINGSTACKLIMIT($14)	#  [1-]
        extll	$16, 0, $16 	# new data [0di]
        subq	$20, TypeLocative, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, BINDLOCTOVALIOP	# [1]
#ifdef MINIMA
        srl	$18, 32, $2 	# [0di]
#endif
        extll	$18, 0, $18 	# [1]
        extll	$19, 0, $19 	# [1]
        subq	$18, $19, $1 	# [2]
        bge	$1, BINDLOCTOVALOV	# J. if binding stack overflow [1]
        addq	$18, 1, $3 	# [1-]
#ifdef MINIMA
/* BSP not a locative -> Deep-bound */
        subq	$2, TypeLocative, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, BINDLOCTOVALDEEP	# [1]
#endif
        ldl	$22, PROCESSORSTATE_CONTROL($14)	#  [1-]
        bis	$21, $31, $8 	# [0di]
/* Memory Read Internal */
G15744:
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$8, $14, $6 	# [0di]
        ldl	$5, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$6, $31, $1 	# [0di]
        ldq_u	$2, 0($6)	#  [1-]
        subq	$8, $4, $4 	# Stack cache offset [1di]
        ldq	$7, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$4, $5, $5 	# In range? [0di]
        ldl	$1, 0($1)	#  [1-]
        extbl	$2, $6, $2 	# [0di]
        bne	$5, G15746	# [1-]
G15745:
        lda	$6, 224	#  [0di]
        srl	$7, $2, $7 	# [1]
        srl	$6, $2, $6 	# [1]
        blbs	$7, G15748	# [1-]
G15753:
        srl	$22, 19, $23 	# [0di]
/* TagType. */
        and	$20, 63, $8 	# [1]
        and	$23, 64, $23 	# Extract the CR.cleanup-bindings bit [1]
        bis	$23, $8, $24 	# [1]
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$3, $14, $4 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$4, $31, $7 	# [1-]
        ldq_u	$6, 0($4)	#  [1di]
        subq	$3, $5, $5 	# Stack cache offset [1-]
        cmpult	$5, $8, $8 	# In range? [1]
        insbl	$24, $4, $5 	# [1]
        mskbl	$6, $4, $6 	# [1]
.align 3
G15756:
        bis	$6, $5, $6 	# [2]
        stq_u	$6, 0($4)	#  [0di]
        stl	$21, 0($7)	#  [1]
        bne	$8, G15755	# J. if in cache [1]
G15754:
        addq	$18, 2, $3 	# [1-]
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$3, $14, $4 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$4, $31, $7 	# [1-]
        ldq_u	$6, 0($4)	#  [1di]
        subq	$3, $5, $5 	# Stack cache offset [1-]
        cmpult	$5, $8, $8 	# In range? [1]
        insbl	$2, $4, $5 	# [1]
        mskbl	$6, $4, $6 	# [1]
.align 3
G15759:
        bis	$6, $5, $6 	# [2]
        stq_u	$6, 0($4)	#  [0di]
        stl	$1, 0($7)	#  [1]
        bne	$8, G15758	# J. if in cache [1]
G15757:
        ldah	$1, 512	#  [1-]
/* Memory Read Internal */
G15760:
        ldq	$6, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$21, $14, $8 	# [1-]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$8, $31, $5 	# [1-]
        ldq_u	$4, 0($8)	#  [1di]
        subq	$21, $6, $6 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_BINDWRITE_MASK($14)	#  [0di]
        cmpult	$6, $7, $7 	# In range? [1-]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $8, $4 	# [1-]
        bne	$7, G15762	# [0di]
G15761:
        lda	$8, 224	#  [1-]
        srl	$23, $4, $23 	# [1]
        srl	$8, $4, $8 	# [1]
        blbs	$23, G15764	# [1di]
G15769:
/* Merge cdr-code */
        and	$17, 63, $5 	# [1-]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$21, $14, $6 	# [1-]
        ldl	$23, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$6, $31, $5 	# [1-]
        ldq_u	$8, 0($6)	#  [1di]
        subq	$21, $7, $7 	# Stack cache offset [1-]
        cmpult	$7, $23, $23 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G15772:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$16, 0($5)	#  [1]
        bne	$23, G15771	# J. if in cache [1]
G15770:
        bis	$1, $22, $22 	# Set cr.cleanup-bindings bit [1-]
        stl	$22, PROCESSORSTATE_CONTROL($14)	#  [0di]
        stl	$3, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
BINDLOCTOVALOV:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 19, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
BINDLOCTOVALIOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 18, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
BINDLOCTOVALDEEP:
        ldq	$1, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2di]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        bis	$31, $2, $20 	# [1]
        bis	$31, 72, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15771:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G15773:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$21, $7, $7 	# Stack cache offset [2di]
        s8addq	$7, $6, $6 	# reconstruct SCA [1]
        stl	$16, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, G15770	# [1]
.align 3
G15762:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G15761	# [1]
.align 3
G15764:
        blbc	$8, G15763	# [1]
        extll	$5, 0, $21 	# Do the indirect thing [0di]
        br	$31, G15760	# [1-]
.align 3
G15763:
        ldq	$23, PROCESSORSTATE_BINDWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $8 	# Discard the CDR code [0di]
        stq	$21, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $23, $8 	# Adjust for a longword load [2di]
        ldl	$23, 0($8)	# Get the memory action [2]
G15766:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 3, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15758:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G15774:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$3, $5, $5 	# Stack cache offset [2di]
        s8addq	$5, $4, $4 	# reconstruct SCA [1]
        stl	$1, 0($4)	# Store in stack [2]
        stl	$2, 4($4)	# write the stack cache [1]
        br	$31, G15757	# [1]
.align 3
G15755:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
.align 3
G15775:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$3, $5, $5 	# Stack cache offset [2di]
        s8addq	$5, $4, $4 	# reconstruct SCA [1]
        stl	$21, 0($4)	# Store in stack [2]
        stl	$24, 4($4)	# write the stack cache [1]
        br	$31, G15754	# [1]
.align 3
G15746:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$4, $5, $4 	# reconstruct SCA [3]
        ldl	$1, 0($4)	#  [2]
        ldl	$2, 4($4)	# Read from stack cache [1]
        br	$31, G15745	# [1]
.align 3
G15748:
        blbc	$6, G15747	# [1]
        extll	$1, 0, $8 	# Do the indirect thing [0di]
        br	$31, G15744	# [1-]
.align 3
G15747:
        ldq	$7, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$8, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $7, $6 	# Adjust for a longword load [2di]
        ldl	$7, 0($6)	# Get the memory action [2]
G15750:
/* Perform memory action */
        bis	$31, $7, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoBindLocativeToValue
/* End of Halfword operand from stack instruction - DoBindLocativeToValue */
.align 5
.globl DoBindLocative
.ent DoBindLocative 0
/* Halfword operand from stack instruction - DoBindLocative */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoBindLocativeFP
	.globl DoBindLocativeSP
	.globl DoBindLocativeLP
	.globl DoBindLocativeIM
.align 3
DoBindLocative:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBindLocativeSP"
#endif
.align 3
DoBindLocativeSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoBindLocative	# [0di]
	.byte 0x90
	.asciiz "DoBindLocativeLP"
#endif
.align 3
DoBindLocativeLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoBindLocative	# [1]
	.byte 0x84
	.asciiz "DoBindLocativeFP"
#endif
.align 3
DoBindLocativeFP:	# Entry point for FP relative
.align 3
beginDoBindLocative:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
        ldq	$18, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        srl	$16, 32, $20 	# tag [2di]
        ldq	$19, PROCESSORSTATE_BINDINGSTACKLIMIT($14)	#  [1-]
        extll	$16, 0, $21 	# data [0di]
        subq	$20, TypeLocative, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, BINDLOCIOP	# [1]
#ifdef MINIMA
        srl	$18, 32, $2 	# [0di]
#endif
        extll	$18, 0, $18 	# [1]
        extll	$19, 0, $19 	# [1]
        subq	$18, $19, $1 	# [2]
        bge	$1, BINDLOCOV	# J. if binding stack overflow [1]
        addq	$18, 1, $3 	# [1-]
#ifdef MINIMA
/* BSP not a locative -> Deep-bound */
        subq	$2, TypeLocative, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, BINDLOCDEEP	# [1]
#endif
        ldl	$22, PROCESSORSTATE_CONTROL($14)	#  [1-]
        bis	$21, $31, $8 	# [0di]
/* Memory Read Internal */
G15777:
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$8, $14, $6 	# [0di]
        ldl	$5, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$6, $31, $1 	# [0di]
        ldq_u	$2, 0($6)	#  [1-]
        subq	$8, $4, $4 	# Stack cache offset [1di]
        ldq	$7, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$4, $5, $5 	# In range? [0di]
        ldl	$1, 0($1)	#  [1-]
        extbl	$2, $6, $2 	# [0di]
        bne	$5, G15779	# [1-]
G15778:
        lda	$6, 224	#  [0di]
        srl	$7, $2, $7 	# [1]
        srl	$6, $2, $6 	# [1]
        blbs	$7, G15781	# [1-]
G15786:
        srl	$22, 19, $23 	# [0di]
/* TagType. */
        and	$20, 63, $8 	# [1]
        and	$23, 64, $23 	# Extract the CR.cleanup-bindings bit [1]
        bis	$23, $8, $24 	# [1]
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$3, $14, $4 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$4, $31, $7 	# [1-]
        ldq_u	$6, 0($4)	#  [1di]
        subq	$3, $5, $5 	# Stack cache offset [1-]
        cmpult	$5, $8, $8 	# In range? [1]
        insbl	$24, $4, $5 	# [1]
        mskbl	$6, $4, $6 	# [1]
.align 3
G15789:
        bis	$6, $5, $6 	# [2]
        stq_u	$6, 0($4)	#  [0di]
        stl	$21, 0($7)	#  [1]
        bne	$8, G15788	# J. if in cache [1]
G15787:
        addq	$18, 2, $3 	# [1-]
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        addq	$3, $14, $4 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$4, $31, $7 	# [1-]
        ldq_u	$6, 0($4)	#  [1di]
        subq	$3, $5, $5 	# Stack cache offset [1-]
        cmpult	$5, $8, $8 	# In range? [1]
        insbl	$2, $4, $5 	# [1]
        mskbl	$6, $4, $6 	# [1]
.align 3
G15792:
        bis	$6, $5, $6 	# [2]
        stq_u	$6, 0($4)	#  [0di]
        stl	$1, 0($7)	#  [1]
        bne	$8, G15791	# J. if in cache [1]
G15790:
        ldah	$1, 512	#  [1-]
        bis	$1, $22, $22 	# Set cr.cleanup-bindings bit [1]
        stl	$22, PROCESSORSTATE_CONTROL($14)	#  [1-]
        stl	$3, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
BINDLOCOV:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 19, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
BINDLOCIOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 18, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
BINDLOCDEEP:
        ldq	$1, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2di]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        bis	$31, $2, $20 	# [1]
        bis	$31, 72, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15791:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G15793:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$3, $5, $5 	# Stack cache offset [2di]
        s8addq	$5, $4, $4 	# reconstruct SCA [1]
        stl	$1, 0($4)	# Store in stack [2]
        stl	$2, 4($4)	# write the stack cache [1]
        br	$31, G15790	# [1]
.align 3
G15788:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
.align 3
G15794:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$3, $5, $5 	# Stack cache offset [2di]
        s8addq	$5, $4, $4 	# reconstruct SCA [1]
        stl	$21, 0($4)	# Store in stack [2]
        stl	$24, 4($4)	# write the stack cache [1]
        br	$31, G15787	# [1]
.align 3
G15779:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$4, $5, $4 	# reconstruct SCA [3]
        ldl	$1, 0($4)	#  [2]
        ldl	$2, 4($4)	# Read from stack cache [1]
        br	$31, G15778	# [1]
.align 3
G15781:
        blbc	$6, G15780	# [1]
        extll	$1, 0, $8 	# Do the indirect thing [0di]
        br	$31, G15777	# [1-]
.align 3
G15780:
        ldq	$7, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$8, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $7, $6 	# Adjust for a longword load [2di]
        ldl	$7, 0($6)	# Get the memory action [2]
G15783:
/* Perform memory action */
        bis	$31, $7, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
#ifdef TRACING
	.byte 0x82
	.asciiz "DoBindLocativeIM"
#endif
DoBindLocativeIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoBindLocative.
.end DoBindLocative
/* End of Halfword operand from stack instruction - DoBindLocative */
.align 5
.globl DoUnbindN
.ent DoUnbindN 0
/* Halfword operand from stack instruction - DoUnbindN */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoUnbindNFP
	.globl DoUnbindNSP
	.globl DoUnbindNLP
	.globl DoUnbindNIM
.align 3
DoUnbindN:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoUnbindNIM"
#endif
.align 3
DoUnbindNIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoUnbindN	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoUnbindNSP"
#endif
.align 3
DoUnbindNSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoUnbindN	# [0di]
	.byte 0x90
	.asciiz "DoUnbindNLP"
#endif
.align 3
DoUnbindNLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoUnbindN	# [1]
	.byte 0x84
	.asciiz "DoUnbindNFP"
#endif
.align 3
DoUnbindNFP:	# Entry point for FP relative
.align 3
headDoUnbindN:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoUnbindN:
/* arg1 has the operand, not sign extended if immediate. */
#ifdef MINIMA
        ldq	$18, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
#endif
        srl	$16, 32, $17 	# [2di]
        extll	$16, 0, $16 	# [1]
        subq	$17, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, UNBINDNIOP	# [1]
#ifdef MINIMA
/* BSP not a locative -> Deep-bound */
        srl	$18, 32, $2 	# [1-]
        subq	$2, TypeLocative, $1 	# [2]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, UNBINDNDEEP	# [1]
#endif
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        br	$31, UNBINDNENDLOOP	# [1]
.align 3
UNBINDNTOPLOOP:
        subq	$16, 1, $16 	# [1-]
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [0di]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1]
        extll	$1, 0, $1 	# vma only [2di]
        ldah	$2, 512	#  [1]
        subq	$1, 1, $5 	# [1]
        and	$4, $2, $3 	# [1]
        bic	$4, $2, $4 	# Turn off the bit [1]
        bne	$3, G15795	# [1-]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [0di]
        bis	$31, 0, $20 	# [1-]
        bis	$31, 20, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15795:
/* Memory Read Internal */
G15796:
        addq	$1, $14, $19 	# [1]
        s4addq	$19, $31, $6 	# [1]
        ldq_u	$7, 0($19)	#  [1-]
        subq	$1, $24, $8 	# Stack cache offset [0di]
        ldq	$20, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$8, $25, $18 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $19, $7 	# [1di]
        bne	$18, G15798	# [1-]
G15797:
        lda	$19, 224	#  [0di]
        srl	$20, $7, $20 	# [1]
        srl	$19, $7, $19 	# [1]
        blbs	$20, G15800	# [1-]
G15805:
/* Memory Read Internal */
G15806:
        addq	$5, $14, $19 	# [0di]
        s4addq	$19, $31, $2 	# [1]
        ldq_u	$3, 0($19)	#  [1di]
        subq	$5, $24, $8 	# Stack cache offset [1-]
        ldq	$20, PROCESSORSTATE_BINDREAD_MASK($14)	#  [0di]
        cmpult	$8, $25, $18 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$3, $19, $3 	# [1-]
        bne	$18, G15808	# [0di]
G15807:
        lda	$19, 224	#  [1-]
        srl	$20, $3, $20 	# [1]
        srl	$19, $3, $19 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$20, G15810	# [1-]
G15815:
/* Memory Read Internal */
G15816:
        addq	$2, $14, $21 	# [1di]
        s4addq	$21, $31, $18 	# [1]
        ldq_u	$8, 0($21)	#  [1di]
        subq	$2, $24, $19 	# Stack cache offset [1-]
        cmpult	$19, $25, $20 	# In range? [1]
        ldl	$18, 0($18)	#  [1-]
        extbl	$8, $21, $8 	# [0di]
        bne	$20, G15818	# [1-]
G15817:
        ldq	$19, PROCESSORSTATE_BINDWRITE_MASK($14)	#  [0di]
        lda	$21, 224	#  [1-]
        srl	$19, $8, $19 	# [2]
        srl	$21, $8, $21 	# [1]
        blbs	$19, G15820	# [1di]
G15825:
/* Merge cdr-code */
        and	$7, 63, $18 	# [1-]
        and	$8, 192, $8 	# [1]
        bis	$8, $18, $8 	# [1]
        addq	$2, $14, $19 	# [1]
        s4addq	$19, $31, $18 	# [1]
        ldq_u	$21, 0($19)	#  [1di]
        insbl	$8, $19, $20 	# [1-]
        mskbl	$21, $19, $21 	# [2]
.align 3
G15828:
        bis	$21, $20, $21 	# [2]
        stq_u	$21, 0($19)	#  [0di]
        ldl	$19, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
        subq	$2, $24, $20 	# Stack cache offset [0di]
        cmpult	$20, $19, $19 	# In range? [3]
        stl	$6, 0($18)	#  [0di]
        bne	$19, G15827	# J. if in cache [1]
G15826:
        and	$3, 64, $3 	# Get the old cleanup-bindings bit [0di]
        sll	$3, 19, $3 	# [1]
        subq	$1, 2, $1 	# [1]
        stl	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [1-]
        bis	$4, $3, $4 	# [0di]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
.align 3
UNBINDNENDLOOP:
        bgt	$16, UNBINDNTOPLOOP	# [1]
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [0di]
        and	$3, 2, $4 	# [3]
        cmpeq	$4, 2, $4 	# [1]
        bis	$3, $4, $3 	# [2]
        stl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [0di]
        beq	$3, NEXTINSTRUCTION	# [1]
        stq	$3, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
UNBINDNIOP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef MINIMA
.align 3
UNBINDNDEEP:
        ldq	$1, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2di]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        bis	$31, $2, $20 	# [1]
        bis	$31, 72, $17 	# [1]
	br	$31, ILLEGALOPERAND
#endif
.align 3
G15827:
        ldq	$19, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$20, $19, $19 	# reconstruct SCA [3]
        stl	$6, 0($19)	# Store in stack [2]
        stl	$8, 4($19)	# write the stack cache [1]
        br	$31, G15826	# [1]
.align 3
G15818:
        ldq	$20, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$19, $20, $19 	# reconstruct SCA [3]
        ldl	$18, 0($19)	#  [2]
        ldl	$8, 4($19)	# Read from stack cache [1]
        br	$31, G15817	# [1]
.align 3
G15820:
        blbc	$21, G15819	# [1]
        extll	$18, 0, $2 	# Do the indirect thing [0di]
        br	$31, G15816	# [1-]
.align 3
G15819:
        ldq	$19, PROCESSORSTATE_BINDWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$8, 63, $21 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$21, $19, $21 	# Adjust for a longword load [2di]
        ldl	$19, 0($21)	# Get the memory action [2]
G15822:
/* Perform memory action */
        bis	$31, $19, $16 	# [3]
        bis	$31, 3, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15808:
        ldq	$18, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $18, $8 	# reconstruct SCA [3]
        ldl	$2, 0($8)	#  [2]
        ldl	$3, 4($8)	# Read from stack cache [1]
        br	$31, G15807	# [1]
.align 3
G15810:
        blbc	$19, G15809	# [1]
        extll	$2, 0, $5 	# Do the indirect thing [0di]
        br	$31, G15806	# [1-]
.align 3
G15809:
        ldq	$20, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$3, 63, $19 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$19, $20, $19 	# Adjust for a longword load [2di]
        ldl	$20, 0($19)	# Get the memory action [2]
G15812:
/* Perform memory action */
        bis	$31, $20, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15798:
        ldq	$18, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $18, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G15797	# [1]
.align 3
G15800:
        blbc	$19, G15799	# [1]
        extll	$6, 0, $1 	# Do the indirect thing [0di]
        br	$31, G15796	# [1-]
.align 3
G15799:
        ldq	$20, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $19 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$19, $20, $19 	# Adjust for a longword load [2di]
        ldl	$20, 0($19)	# Get the memory action [2]
G15802:
/* Perform memory action */
        bis	$31, $20, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoUnbindN
/* End of Halfword operand from stack instruction - DoUnbindN */
.align 5
.globl DoRestoreBindingStack
.ent DoRestoreBindingStack 0
/* Halfword operand from stack instruction - DoRestoreBindingStack */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoRestoreBindingStackFP
	.globl DoRestoreBindingStackSP
	.globl DoRestoreBindingStackLP
	.globl DoRestoreBindingStackIM
.align 3
DoRestoreBindingStack:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoRestoreBindingStackIM"
#endif
.align 3
DoRestoreBindingStackIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoRestoreBindingStack	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRestoreBindingStackSP"
#endif
.align 3
DoRestoreBindingStackSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoRestoreBindingStack	# [0di]
	.byte 0x90
	.asciiz "DoRestoreBindingStackLP"
#endif
.align 3
DoRestoreBindingStackLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoRestoreBindingStack	# [1]
	.byte 0x84
	.asciiz "DoRestoreBindingStackFP"
#endif
.align 3
DoRestoreBindingStackFP:	# Entry point for FP relative
.align 3
headDoRestoreBindingStack:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoRestoreBindingStack:
/* arg1 has the operand, not sign extended if immediate. */
#ifdef MINIMA
        ldq	$18, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
#endif
        srl	$16, 32, $17 	# [2di]
        extll	$16, 0, $16 	# [1]
        subq	$17, TypeLocative, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, RESTOREBSIOP	# [1]
#ifdef MINIMA
/* BSP not a locative -> Deep-bound */
        srl	$18, 32, $2 	# [1-]
        subq	$2, TypeLocative, $1 	# [2]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, RESTOREBSDEEP	# [1]
#endif
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        br	$31, RESTOREBSENDLOOP	# [1]
.align 3
RESTOREBSTOPLOOP:
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1]
        extll	$1, 0, $1 	# vma only [2-]
        ldah	$2, 512	#  [1]
        subq	$1, 1, $5 	# [1]
        and	$4, $2, $3 	# [1]
        bic	$4, $2, $4 	# Turn off the bit [1]
        bne	$3, G15829	# [0di]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 20, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15829:
/* Memory Read Internal */
G15830:
        addq	$1, $14, $19 	# [1]
        s4addq	$19, $31, $6 	# [1]
        ldq_u	$7, 0($19)	#  [1-]
        subq	$1, $24, $8 	# Stack cache offset [0di]
        ldq	$20, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$8, $25, $18 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $19, $7 	# [1di]
        bne	$18, G15832	# [1-]
G15831:
        lda	$19, 224	#  [0di]
        srl	$20, $7, $20 	# [1]
        srl	$19, $7, $19 	# [1]
        blbs	$20, G15834	# [1-]
G15839:
/* Memory Read Internal */
G15840:
        addq	$5, $14, $19 	# [0di]
        s4addq	$19, $31, $2 	# [1]
        ldq_u	$3, 0($19)	#  [1di]
        subq	$5, $24, $8 	# Stack cache offset [1-]
        ldq	$20, PROCESSORSTATE_BINDREAD_MASK($14)	#  [0di]
        cmpult	$8, $25, $18 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$3, $19, $3 	# [1-]
        bne	$18, G15842	# [0di]
G15841:
        lda	$19, 224	#  [1-]
        srl	$20, $3, $20 	# [1]
        srl	$19, $3, $19 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$20, G15844	# [1-]
G15849:
/* Memory Read Internal */
G15850:
        addq	$2, $14, $21 	# [1di]
        s4addq	$21, $31, $18 	# [1]
        ldq_u	$8, 0($21)	#  [1di]
        subq	$2, $24, $19 	# Stack cache offset [1-]
        cmpult	$19, $25, $20 	# In range? [1]
        ldl	$18, 0($18)	#  [1-]
        extbl	$8, $21, $8 	# [0di]
        bne	$20, G15852	# [1-]
G15851:
        ldq	$19, PROCESSORSTATE_BINDWRITE_MASK($14)	#  [0di]
        lda	$21, 224	#  [1-]
        srl	$19, $8, $19 	# [2]
        srl	$21, $8, $21 	# [1]
        blbs	$19, G15854	# [1di]
G15859:
/* Merge cdr-code */
        and	$7, 63, $18 	# [1-]
        and	$8, 192, $8 	# [1]
        bis	$8, $18, $8 	# [1]
        addq	$2, $14, $19 	# [1]
        s4addq	$19, $31, $18 	# [1]
        ldq_u	$21, 0($19)	#  [1di]
        insbl	$8, $19, $20 	# [1-]
        mskbl	$21, $19, $21 	# [2]
.align 3
G15862:
        bis	$21, $20, $21 	# [2]
        stq_u	$21, 0($19)	#  [0di]
        ldl	$19, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
        subq	$2, $24, $20 	# Stack cache offset [0di]
        cmpult	$20, $19, $19 	# In range? [3]
        stl	$6, 0($18)	#  [0di]
        bne	$19, G15861	# J. if in cache [1]
G15860:
        and	$3, 64, $3 	# Get the old cleanup-bindings bit [0di]
        sll	$3, 19, $3 	# [1]
        subq	$1, 2, $1 	# [1]
        stl	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [1-]
        bis	$4, $3, $4 	# [0di]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
.align 3
RESTOREBSENDLOOP:
        subl	$1, $16, $19 	# [1-]
        bgt	$19, RESTOREBSTOPLOOP	# [1]
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1-]
        and	$3, 2, $4 	# [3]
        cmpeq	$4, 2, $4 	# [1]
        bis	$3, $4, $3 	# [2]
        stl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1-]
        beq	$3, NEXTINSTRUCTION	# [1]
        stq	$3, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
RESTOREBSIOP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 66, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef MINIMA
.align 3
RESTOREBSDEEP:
        ldq	$1, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2di]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        bis	$31, $2, $20 	# [1]
        bis	$31, 66, $17 	# [1]
	br	$31, ILLEGALOPERAND
#endif
.align 3
G15861:
        ldq	$19, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$20, $19, $19 	# reconstruct SCA [3]
        stl	$6, 0($19)	# Store in stack [2]
        stl	$8, 4($19)	# write the stack cache [1]
        br	$31, G15860	# [1]
.align 3
G15852:
        ldq	$20, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$19, $20, $19 	# reconstruct SCA [3]
        ldl	$18, 0($19)	#  [2]
        ldl	$8, 4($19)	# Read from stack cache [1]
        br	$31, G15851	# [1]
.align 3
G15854:
        blbc	$21, G15853	# [1]
        extll	$18, 0, $2 	# Do the indirect thing [0di]
        br	$31, G15850	# [1-]
.align 3
G15853:
        ldq	$19, PROCESSORSTATE_BINDWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$8, 63, $21 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$21, $19, $21 	# Adjust for a longword load [2di]
        ldl	$19, 0($21)	# Get the memory action [2]
G15856:
/* Perform memory action */
        bis	$31, $19, $16 	# [3]
        bis	$31, 3, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15842:
        ldq	$18, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $18, $8 	# reconstruct SCA [3]
        ldl	$2, 0($8)	#  [2]
        ldl	$3, 4($8)	# Read from stack cache [1]
        br	$31, G15841	# [1]
.align 3
G15844:
        blbc	$19, G15843	# [1]
        extll	$2, 0, $5 	# Do the indirect thing [0di]
        br	$31, G15840	# [1-]
.align 3
G15843:
        ldq	$20, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$3, 63, $19 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$19, $20, $19 	# Adjust for a longword load [2di]
        ldl	$20, 0($19)	# Get the memory action [2]
G15846:
/* Perform memory action */
        bis	$31, $20, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15832:
        ldq	$18, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $18, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G15831	# [1]
.align 3
G15834:
        blbc	$19, G15833	# [1]
        extll	$6, 0, $1 	# Do the indirect thing [0di]
        br	$31, G15830	# [1-]
.align 3
G15833:
        ldq	$20, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $19 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$19, $20, $19 	# Adjust for a longword load [2di]
        ldl	$20, 0($19)	# Get the memory action [2]
G15836:
/* Perform memory action */
        bis	$31, $20, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoRestoreBindingStack
/* End of Halfword operand from stack instruction - DoRestoreBindingStack */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunbind.as */
