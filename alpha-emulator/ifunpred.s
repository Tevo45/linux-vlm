/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunpred.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Predicates. */
.align 5
.globl DoEql
.ent DoEql 0
/* Halfword operand from stack instruction - DoEql */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoEqlFP
	.globl DoEqlSP
	.globl DoEqlLP
	.globl DoEqlIM
.align 3
DoEql:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoEqlSP"
#endif
.align 3
DoEqlSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoEql	# [0di]
	.byte 0x90
	.asciiz "DoEqlLP"
#endif
.align 3
DoEqlLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoEql	# [1]
	.byte 0x84
	.asciiz "DoEqlFP"
#endif
.align 3
DoEqlFP:	# Entry point for FP relative
.align 3
headDoEql:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoEql:
/* arg1 has the operand, not sign extended if immediate. */
        srl	$18, 12, $21 	# [1-]
        ldq	$3, 0($12)	# Load arg1 into t3 [0di]
        lda	$4, -2048	# Low part of EQ-NOT-EQL mask [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldah	$4, 1($4)	# High part of EQ-NOT-EQL mask [1-]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	# Assume result will be T [0di]
        xor	$16, $3, $5 	# [1-]
        sll	$5, 26, $5 	# Shift left to lose CDRCODE. [1]
        and	$21, 1, $21 	# 1 if no-pop, 0 if pop [1]
        beq	$5, EQLDONE	# [1di]
/* They are not EQ, if types different or not numeric return nil */
        srl	$5, 58, $5 	# Get the tag alone [1]
        bis	$24, $31, $25 	# Now assume result will be NIL [1]
        bne	$5, EQLDONE	# Return NIL if tags different [1-]
        srl	$3, 32, $3 	# Get tag, check for numeric [0di]
/* TagType. */
        and	$3, 63, $3 	# [2]
        srl	$4, $3, $4 	# Type is now a bit mask [1]
        blbs	$4, EQLEXC	# If funny numeric type, exception [2]
.align 3
EQLDONE:
        s8addq	$21, $12, $12 	# Either a stack-push or a stack-write [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$25, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
        br	$31, DoEqlIM	# [1]
	.byte 0x82
	.asciiz "DoEqlIM"
#endif
.align 5
.align 3
DoEqlIM:	# Entry point for IMMEDIATE mode
        sll	$17, 56, $17 	# [1-]
        ldl	$4, 4($12)	# t4=tag t3=data [0di]
        ldl	$3, 0($12)	#  [1]
        srl	$18, 12, $21 	# [0di]
        sra	$17, 56, $17 	# Sign extension of arg2 is complete [1]
        extll	$3, 0, $3 	# [2]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
/* TagType. */
        and	$4, 63, $4 	# [0di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        subl	$3, $17, $17 	# [0di]
        xor	$4, TypeFixnum, $4 	# [1]
        and	$21, 1, $21 	# 1 if no-pop, 0 if pop [1]
        bis	$17, $4, $4 	# [1]
        s8addq	$21, $12, $12 	# Either a stack-push or a stack-write [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        cmoveq	$4, $25, $24 	# [1-]
        stq	$24, 0($12)	# Yes Virginia, this does dual issue with above [0di]
        br	$31, CACHEVALID	# [1]
.align 3
EQLEXC:
        bis	$31, 0, $18 	# arg3 = stackp [1-]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.end DoEql
/* End of Halfword operand from stack instruction - DoEql */
.align 5
.globl DoGreaterp
.ent DoGreaterp 0
/* Halfword operand from stack instruction - DoGreaterp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoGreaterpFP
	.globl DoGreaterpSP
	.globl DoGreaterpLP
	.globl DoGreaterpIM
.align 3
DoGreaterp:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoGreaterpSP"
#endif
.align 3
DoGreaterpSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDoGreaterp	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoGreaterp	# [0di]
	.byte 0x90
	.asciiz "DoGreaterpLP"
#endif
.align 3
DoGreaterpLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoGreaterp	# [1]
	.byte 0x84
	.asciiz "DoGreaterpFP"
#endif
.align 3
DoGreaterpFP:	# Entry point for FP relative
.align 3
beginDoGreaterp:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        srl	$18, 12, $7 	# [1-]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        extll	$21, 4, $18 	# Get ARG1 tag [1-]
        ldl	$1, 4($16)	# t1 is tag of arg2 [0di]
        lds	$f1, 0($12)	#  [1]
        and	$7, 1, $7 	# [0di]
        ldl	$17, 0($16)	#  [1-]
        addl	$21, $31, $19 	# [0di]
        lds	$f2, 0($16)	#  [1-]
        and	$18, 63, $5 	# Strip off any CDR code bits. [0di]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G15129:
        beq	$6, G15117	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G15121:
        beq	$3, G15112	# [1]
/* Here if argument TypeFixnum */
        subq	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# Pop/No-pop [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovgt	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G15118:
.align 3
G15117:
        cmpeq	$5, TypeSingleFloat, $6 	# [1-]
.align 3
G15130:
        beq	$6, G15122	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$4, TypeSingleFloat, $3 	# [0di]
.align 3
G15126:
        beq	$3, G15112	# [1]
/* Here if argument TypeSingleFloat */
.align 3
GreaterpMMExcFLTFLT:
        cmptle	$f1, $f2, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        stq	$25, 0($12)	#  [1]
        fbeq	$f3, CACHEVALID	# [3-]
        stq	$24, 0($12)	# Didn't branch, answer is NIL [0di]
        br	$31, CACHEVALID	# [1]
.align 3
G15123:
.align 3
G15122:
/* Here for all other cases */
.align 3
G15112:
        br	$31, GreaterpMMExc	# [1]
.align 3
G15116:
#ifdef TRACING
        br	$31, DoGreaterpIM	# [1]
	.byte 0x82
	.asciiz "DoGreaterpIM"
#endif
.align 5
.align 3
DoGreaterpIM:	# Entry point for IMMEDIATE mode
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$17, 56, $17 	# First half of sign extension [0di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        srl	$18, 12, $7 	# [0di]
        extll	$21, 4, $18 	# [1]
        addl	$21, $31, $19 	# [1]
        sra	$17, 56, $17 	# Second half of sign extension [1]
        and	$7, 1, $7 	# [1]
        and	$18, 63, $3 	# Strip off any CDR code bits. [1]
        cmpeq	$3, TypeFixnum, $4 	# [1]
.align 3
G15135:
        beq	$4, G15132	# [1]
/* Here if argument TypeFixnum */
        subq	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovgt	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G15132:
/* Here for all other cases */
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15131:
.end DoGreaterp
/* End of Halfword operand from stack instruction - DoGreaterp */
.align 5
.globl DoLogtest
.ent DoLogtest 0
/* Halfword operand from stack instruction - DoLogtest */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLogtestFP
	.globl DoLogtestSP
	.globl DoLogtestLP
	.globl DoLogtestIM
.align 3
DoLogtest:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLogtestSP"
#endif
.align 3
DoLogtestSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDoLogtest	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoLogtest	# [0di]
	.byte 0x90
	.asciiz "DoLogtestLP"
#endif
.align 3
DoLogtestLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoLogtest	# [1]
	.byte 0x84
	.asciiz "DoLogtestFP"
#endif
.align 3
DoLogtestFP:	# Entry point for FP relative
.align 3
beginDoLogtest:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        srl	$18, 12, $7 	# [1-]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        extll	$21, 4, $18 	# Get ARG1 tag [1-]
        ldl	$17, 0($16)	#  [0di]
        lds	$f1, 0($12)	#  [1]
        and	$7, 1, $7 	# [0di]
        ldl	$1, 4($16)	# t1 is tag of arg2 [1-]
        extll	$21, 0, $19 	# [0di]
        extll	$17, 0, $17 	# [1]
        lds	$f2, 0($16)	#  [0di]
        and	$18, 63, $5 	# Strip off any CDR code bits. [1-]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G15148:
        beq	$6, G15141	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G15145:
        beq	$3, G15138	# [1]
/* Here if argument TypeFixnum */
        and	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# Pop/No-pop [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovne	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G15142:
.align 3
G15141:
/* Here for all other cases */
.align 3
G15137:
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G15139	# [1-]
.align 3
G15138:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15139:
.align 3
G15140:
#ifdef TRACING
        br	$31, DoLogtestIM	# [1-]
	.byte 0x82
	.asciiz "DoLogtestIM"
#endif
.align 5
.align 3
DoLogtestIM:	# Entry point for IMMEDIATE mode
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$17, 56, $17 	# First half of sign extension [0di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        srl	$18, 12, $7 	# [0di]
        extll	$21, 4, $18 	# [1]
        addl	$21, $31, $19 	# [1]
        sra	$17, 56, $17 	# Second half of sign extension [1]
        and	$7, 1, $7 	# [1]
        and	$18, 63, $3 	# Strip off any CDR code bits. [1]
        cmpeq	$3, TypeFixnum, $4 	# [1]
.align 3
G15153:
        beq	$4, G15150	# [1]
/* Here if argument TypeFixnum */
        and	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovne	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G15150:
/* Here for all other cases */
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15149:
.end DoLogtest
/* End of Halfword operand from stack instruction - DoLogtest */
.align 5
.globl EqualNumberMMExc
.ent EqualNumberMMExc 0
.align 3
EqualNumberMMExc:
        and	$18, 63, $5 	# Strip off any CDR code bits. [1]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G15171:
        beq	$6, G15159	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeSingleFloat, $3 	# [0di]
.align 3
G15163:
        beq	$3, G15156	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqs	$f1, $f1 	# [6]
        br	$31, EqualNumberMMExcFLTFLT	# [1]
.align 3
G15160:
.align 3
G15159:
        cmpeq	$5, TypeSingleFloat, $6 	# [1-]
.align 3
G15172:
        beq	$6, G15164	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G15168:
        beq	$3, G15156	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqs	$f2, $f2 	# [6]
        br	$31, EqualNumberMMExcFLTFLT	# [1]
.align 3
G15165:
.align 3
G15164:
/* Here for all other cases */
.align 3
G15155:
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G15157	# [1-]
.align 3
G15156:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15157:
.align 3
G15158:
.end EqualNumberMMExc
.align 5
.globl LesspMMExc
.ent LesspMMExc 0
.align 3
LesspMMExc:
        and	$18, 63, $5 	# Strip off any CDR code bits. [1]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G15190:
        beq	$6, G15178	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeSingleFloat, $3 	# [0di]
.align 3
G15182:
        beq	$3, G15175	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqs	$f1, $f1 	# [6]
        br	$31, LesspMMExcFLTFLT	# [1]
.align 3
G15179:
.align 3
G15178:
        cmpeq	$5, TypeSingleFloat, $6 	# [1-]
.align 3
G15191:
        beq	$6, G15183	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G15187:
        beq	$3, G15175	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqs	$f2, $f2 	# [6]
        br	$31, LesspMMExcFLTFLT	# [1]
.align 3
G15184:
.align 3
G15183:
/* Here for all other cases */
.align 3
G15174:
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G15176	# [1-]
.align 3
G15175:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15176:
.align 3
G15177:
.end LesspMMExc
.align 5
.globl GreaterpMMExc
.ent GreaterpMMExc 0
.align 3
GreaterpMMExc:
        and	$18, 63, $5 	# Strip off any CDR code bits. [1]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G15209:
        beq	$6, G15197	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeSingleFloat, $3 	# [0di]
.align 3
G15201:
        beq	$3, G15194	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqs	$f1, $f1 	# [6]
        br	$31, GreaterpMMExcFLTFLT	# [1]
.align 3
G15198:
.align 3
G15197:
        cmpeq	$5, TypeSingleFloat, $6 	# [1-]
.align 3
G15210:
        beq	$6, G15202	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G15206:
        beq	$3, G15194	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqs	$f2, $f2 	# [6]
        br	$31, GreaterpMMExcFLTFLT	# [1]
.align 3
G15203:
.align 3
G15202:
/* Here for all other cases */
.align 3
G15193:
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G15195	# [1-]
.align 3
G15194:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G15195:
.align 3
G15196:
.end GreaterpMMExc
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunpred.as */
