/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunfcal.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Function calling. */
/* Start call. */
/* Finish call. */
.align 5
.globl DoFinishCallTos
.ent DoFinishCallTos 0
/* Halfword 10 bit immediate instruction - DoFinishCallTos */
	.globl DoFinishCallTosFP
	.globl DoFinishCallTosSP
	.globl DoFinishCallTosLP
	.globl DoFinishCallTosIM
.align 3
DoFinishCallTos:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoFinishCallTos"
#endif
.align 3
DoFinishCallTosIM:
.align 3
DoFinishCallTosSP:
.align 3
DoFinishCallTosLP:
.align 3
DoFinishCallTosFP:
/* arg1 has operand preloaded. */
        extbl	$18, 5, $16 	# arg1 contains the disposition (two bits) [1]
        ldl	$17, 0($12)	# Get the number of args [0di]
        subq	$12, 8, $12 	# Pop stack [1]
        s8addq	$17, 8, $17 	# Add 1 and convert to stacked word address [2]
        br	$31, FINISHCALLMERGE	# [1-]
.end DoFinishCallTos
/* End of Halfword operand from stack instruction - DoFinishCallTos */
/* Function entry. */
.align 5
.globl DoEntryRestAccepted
.ent DoEntryRestAccepted 0
/* Field Extraction instruction - DoEntryRestAccepted */
	.globl DoEntryRestAcceptedFP
	.globl DoEntryRestAcceptedSP
	.globl DoEntryRestAcceptedLP
	.globl DoEntryRestAcceptedIM
.align 3
DoEntryRestAccepted:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xB0
	.asciiz "DoEntryRestAccepted"
#endif
.align 3
DoEntryRestAcceptedIM:
.align 3
DoEntryRestAcceptedSP:
.align 3
DoEntryRestAcceptedLP:
.align 3
DoEntryRestAcceptedFP:
        ldl	$20, PROCESSORSTATE_CONTROL($14)	# The control register [1]
        srl	$18, 18, $19 	# Pull down the number of optionals [0di]
        extbl	$18, 5, $16 	# Extract the 'ptr' field while we are waiting [1]
        and	$19, 255, $19 	# [1]
/* arg1=ptr field, arg2=required, arg3=instn, arg4=optionals arg5=control-register */
        srl	$20, 27, $2 	# Get the cr.trace-pending bit [1]
        and	$20, 255, $1 	# The supplied args [1]
        blbs	$2, TRACETRAP	# [1-]
        srl	$20, 17, $3 	# [0di]
        ldl	$4, 4($12)	# Get the tag of the stack top. [1-]
.align 3
G14092:
        blbs	$3, G14090	# J. if apply args [1-]
G14091:
        subq	$1, $17, $2 	# t2=supplied-minimum [0di]
        blt	$2, RETRYERATOOFEW	# B. if too few args. [1]
        subq	$19, $1, $16 	# maximum-supplied [0di]
        blt	$16, RETRYERAREST	# B. rest args. [1]
/* Compute entry position and advance PC/CP accordingly. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	# get the next PC [0di]
        sll	$2, 1, $3 	# Adjust index to halfword [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        beq	$2, INTERPRETINSTRUCTION	# J. if index zero, no adjustment. [1-]
        addq	$9, $3, $9 	# Compute the new address [1di]
        bic	$9, 1, $9 	# Make it an DTP-EVEN-PC [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [0di]
.align 3
APPLYSUPPRA:
        subq	$19, $1, $16 	# maximum-supplied [1-]
        blt	$16, RETRYERAREST	# B. rest args. [1]
        bgt	$16, PullApplyArgs	# try pulling from applied args. [1]
        ldl	$6, 4($12)	# get tag [0di]
        and	$6, 63, $6 	# [3]
        bis	$6, 64, $6 	# [1]
        stl	$6, 4($12)	# set tag [1-]
        subq	$1, $17, $2 	# t2=supplied-minimum [0di]
        addq	$2, 1, $2 	# [1]
/* Compute entry position and advance PC/CP accordingly. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	# get the next PC [0di]
        sll	$2, 1, $3 	# Adjust index to halfword [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [0di]
        beq	$2, INTERPRETINSTRUCTION	# J. if index zero, no adjustment. [1-]
        addq	$9, $3, $9 	# Compute the new address [1di]
        bic	$9, 1, $9 	# Make it an DTP-EVEN-PC [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [0di]
.align 3
RETRYERATOOFEW:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 77, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
RETRYERAREST:
        ldl	$1, 4($12)	# get tag [1-]
        and	$1, 63, $1 	# [3]
        bis	$1, 64, $1 	# [1]
        stl	$1, 4($12)	# set tag [0di]
        srl	$20, 17, $2 	# [1-]
        ldl	$3, 4($12)	# Get the tag of the stack top. [0di]
.align 3
G14097:
        blbs	$2, G14095	# J. if apply args [2-]
G14096:
        s8addq	$19, $10, $1 	# [0di]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2-]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        bis	$31, TypeList, $1 	# [1]
        stl	$2, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, G14094	# [0di]
.align 3
G14093:
        subq	$12, 8, $1 	# [1-]
        ldl	$3, 4($1)	# get tag [2]
        and	$3, 63, $3 	# [3]
        bis	$3, 128, $3 	# [1]
        stl	$3, 4($1)	# set tag [1-]
        s8addq	$19, $10, $1 	# [0di]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2-]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        bis	$31, TypeList, $1 	# [1]
        stl	$2, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        addq	$11, 8, $11 	# [1]
        addq	$20, 1, $20 	# [1]
        stl	$20, PROCESSORSTATE_CONTROL($14)	#  [0di]
.align 3
G14094:
        subq	$19, $17, $1 	# [1-]
        addq	$1, 1, $1 	# [1]
/* Compute entry position and advance PC/CP accordingly. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	# get the next PC [1-]
        sll	$1, 1, $2 	# Adjust index to halfword [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        beq	$1, INTERPRETINSTRUCTION	# J. if index zero, no adjustment. [0di]
        addq	$9, $2, $9 	# Compute the new address [2-]
        bic	$9, 1, $9 	# Make it an DTP-EVEN-PC [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [1-]
.align 3
G14095:
        and	$3, 63, $3 	# [1-]
        subq	$3, TypeNIL, $3 	# [1]
        bne	$3, G14093	# J. if apply args supplied not nil. [1]
        and	$2, 1, $2 	# keep just the apply bit! [0di]
        sll	$2, 17, $2 	# reposition the apply bit [1]
        subq	$12, 8, $12 	# Pop off the null applied arg. [1]
        bic	$20, $2, $20 	# Blast the apply arg bit away [1]
        stl	$20, PROCESSORSTATE_CONTROL($14)	# Reset the stored cr bit [0di]
        br	$31, G14096	# [1]
.align 3
G14090:
        and	$4, 63, $4 	# [1-]
        subq	$4, TypeNIL, $4 	# [1]
        bne	$4, APPLYSUPPRA	# J. if apply args supplied not nil. [1]
        and	$3, 1, $3 	# keep just the apply bit! [0di]
        sll	$3, 17, $3 	# reposition the apply bit [1]
        subq	$12, 8, $12 	# Pop off the null applied arg. [1]
        bic	$20, $3, $20 	# Blast the apply arg bit away [1]
        stl	$20, PROCESSORSTATE_CONTROL($14)	# Reset the stored cr bit [0di]
        br	$31, G14091	# [1]
.end DoEntryRestAccepted
/* End of Halfword operand from stack instruction - DoEntryRestAccepted */
.align 5
.globl CarCdrInternal
.ent CarCdrInternal 13
.align 3
CarCdrInternal:
        lda	$30, -8($30)	#  [1-]
	.frame $30, 8, $0
        extll	$2, $31, $17 	# [1]
        and	$1, 63, $5 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeList, $6 	# [1]
.align 3
G14145:
        beq	$6, G14102	# [1]
/* Here if argument TypeList */
/* Memory Read Internal */
G14103:
        addq	$17, $14, $7 	# [0di]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G14105	# [0di]
G14104:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G14107	# [1-]
G14114:
        subl	$17, $2, $5 	# [0di]
        bne	$5, G14098	# CAR forwarded, must CDR the hard way [1]
        bis	$20, $31, $1 	# [0di]
        bis	$21, $31, $2 	# [1]
.align 3
G14100:
        and	$20, 192, $5 	# Extract CDR code. [1]
        bne	$5, G14116	# [1]
/* Here if argument 0 */
        addq	$17, 1, $21 	# Address of next position is CDR [1-]
        bis	$31, TypeList, $20 	# [1]
.align 3
G14115:
.align 3
G14101:
.align 3
G14099:
        lda	$30, 8($30)	#  [1]
        ret	$31, ($0), 1	# [0di]
.align 3
G14102:
        cmpeq	$5, TypeNIL, $6 	# [1-]
.align 3
G14146:
        beq	$6, G14132	# [1]
/* Here if argument TypeNIL */
        ldl	$21, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_NILADDRESS+4($14)	#  [1]
        extll	$21, 0, $21 	# [2di]
        br	$31, G14101	# [1-]
.align 3
G14132:
/* Here for all other cases */
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LISTEXCEPTION
.align 3
G14098:
        extll	$2, $31, $17 	# [1]
        bis	$20, $31, $1 	# [1]
        bis	$21, $31, $2 	# [1]
/* Memory Read Internal */
G14134:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_CDR_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G14136	# [0di]
G14135:
        lda	$7, 192	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G14138	# [1di]
G14143:
        br	$31, G14100	# [1]
.align 3
G14138:
        blbc	$7, G14137	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G14134	# [1-]
.align 3
G14137:
.align 3
G14136:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadCdrDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G14143	# [1]
.align 3
G14116:
        cmpeq	$5, 128, $6 	# [1-]
.align 3
G14147:
        beq	$6, G14117	# [1]
/* Here if argument 128 */
        addq	$17, 1, $17 	# [0di]
/* Memory Read Internal */
G14118:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G14120	# [1-]
G14119:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G14122	# [0di]
        br	$31, G14099	# [1]
.align 3
G14117:
        cmpeq	$5, 64, $6 	# [1-]
.align 3
G14148:
        beq	$6, G14129	# [1]
/* Here if argument 64 */
        ldl	$21, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_NILADDRESS+4($14)	#  [1]
        extll	$21, 0, $21 	# [2di]
        br	$31, G14099	# [1-]
.align 3
G14129:
/* Here for all other cases */
        bis	$31, $17, $20 	# [1-]
        bis	$31, 15, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14122:
        blbc	$7, G14121	# [1-]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G14118	# [1-]
.align 3
G14121:
.align 3
G14120:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G14099	# [1]
.align 3
G14107:
        blbc	$7, G14106	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G14103	# [1-]
.align 3
G14106:
.align 3
G14105:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G14114	# [1]
.end CarCdrInternal
.align 12
        and	$31, $31, $31 	# [1]
.align 12
.align 5
.globl PullApplyArgsSlowly
.ent PullApplyArgsSlowly 0
.align 3
PullApplyArgsSlowly:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$19, 0($12)	# Get the rest arg [1]
        ldl	$18, 4($12)	#  [1]
        extll	$19, 0, $19 	# [2-]
        extll	$19, $31, $2 	# [2]
        and	$18, 63, $3 	# Strip off any CDR code bits. [1]
        cmpeq	$3, TypeList, $4 	# [1]
.align 3
G14196:
        beq	$4, G14153	# [1]
/* Here if argument TypeList */
/* Memory Read Internal */
G14154:
        addq	$2, $14, $5 	# [0di]
        s4addq	$5, $31, $21 	# [1]
        ldq_u	$20, 0($5)	#  [1di]
        subq	$2, $24, $3 	# Stack cache offset [1-]
        ldq	$6, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$3, $25, $4 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $5, $20 	# [1-]
        bne	$4, G14156	# [0di]
G14155:
        lda	$5, 240	#  [1-]
        srl	$6, $20, $6 	# [1]
        srl	$5, $20, $5 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$6, G14158	# [1-]
G14165:
        subl	$2, $19, $3 	# [0di]
        bne	$3, G14149	# CAR forwarded, must CDR the hard way [1]
        bis	$20, $31, $18 	# [0di]
        bis	$21, $31, $19 	# [1]
.align 3
G14151:
        and	$20, 192, $3 	# Extract CDR code. [1]
        bne	$3, G14167	# [1]
/* Here if argument 0 */
        addq	$2, 1, $21 	# Address of next position is CDR [1-]
        bis	$31, TypeList, $20 	# [1]
.align 3
G14166:
.align 3
G14152:
.align 3
G14150:
        stl	$19, 0($12)	# Push the pulled argument [1-]
        stl	$18, 4($12)	# write the stack cache [1]
        and	$20, 63, $1 	# set CDR-NEXT [1-]
        stl	$21, 8($12)	# Push the new rest arg [0di]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        ldl	$17, PROCESSORSTATE_CONTROL($14)	#  [1-]
        and	$17, 255, $2 	# Get current arg size. [3]
        bic	$17, 255, $17 	# [1]
        addq	$2, 1, $2 	# [1]
        addq	$2, $17, $17 	# Update the arg size [1]
        stl	$17, PROCESSORSTATE_CONTROL($14)	#  [0di]
        addq	$11, 8, $11 	# [1-]
        br	$31, INTERPRETINSTRUCTION	# [0di]
.align 3
G14153:
        cmpeq	$3, TypeNIL, $4 	# [1-]
.align 3
G14197:
        beq	$4, G14183	# [1]
/* Here if argument TypeNIL */
        ldl	$21, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_NILADDRESS+4($14)	#  [1]
        extll	$21, 0, $21 	# [2di]
        br	$31, G14152	# [1-]
.align 3
G14183:
/* Here for all other cases */
        bis	$31, $16, $16 	# [1-]
	br	$31, PULLAPPLYARGSTRAP
.align 3
G14149:
        extll	$19, $31, $2 	# [1]
        bis	$20, $31, $18 	# [1]
        bis	$21, $31, $19 	# [1]
/* Memory Read Internal */
G14185:
        addq	$2, $14, $5 	# [1]
        s4addq	$5, $31, $21 	# [1]
        ldq_u	$20, 0($5)	#  [1di]
        subq	$2, $24, $3 	# Stack cache offset [1-]
        ldq	$6, PROCESSORSTATE_CDR_MASK($14)	#  [0di]
        cmpult	$3, $25, $4 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $5, $20 	# [1-]
        bne	$4, G14187	# [0di]
G14186:
        lda	$5, 192	#  [1-]
        srl	$6, $20, $6 	# [1]
        srl	$5, $20, $5 	# [1]
        blbs	$6, G14189	# [1di]
G14194:
        br	$31, G14151	# [1]
.align 3
G14187:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$3, $4, $3 	# reconstruct SCA [3]
        ldl	$21, 0($3)	#  [2]
        ldl	$20, 4($3)	# Read from stack cache [1]
        br	$31, G14186	# [1]
.align 3
G14189:
        blbc	$5, G14188	# [1]
        extll	$21, 0, $2 	# Do the indirect thing [0di]
        br	$31, G14185	# [1-]
.align 3
G14188:
        ldq	$6, PROCESSORSTATE_CDR($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $5 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$5, $6, $5 	# Adjust for a longword load [2di]
        ldl	$6, 0($5)	# Get the memory action [2]
G14191:
/* Perform memory action */
        bis	$31, $6, $16 	# [3]
        bis	$31, 9, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14167:
        cmpeq	$3, 128, $4 	# [1]
.align 3
G14198:
        beq	$4, G14168	# [1]
/* Here if argument 128 */
        addq	$2, 1, $2 	# [0di]
/* Memory Read Internal */
G14169:
        addq	$2, $14, $5 	# [1]
        s4addq	$5, $31, $21 	# [1]
        ldq_u	$20, 0($5)	#  [1-]
        subq	$2, $24, $3 	# Stack cache offset [0di]
        ldq	$6, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$3, $25, $4 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $5, $20 	# [1di]
        bne	$4, G14171	# [1-]
G14170:
        lda	$5, 240	#  [0di]
        srl	$6, $20, $6 	# [1]
        srl	$5, $20, $5 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$6, G14173	# [0di]
        br	$31, G14150	# [1]
.align 3
G14168:
        cmpeq	$3, 64, $4 	# [1-]
.align 3
G14199:
        beq	$4, G14180	# [1]
/* Here if argument 64 */
        ldl	$21, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_NILADDRESS+4($14)	#  [1]
        extll	$21, 0, $21 	# [2di]
        br	$31, G14150	# [1-]
.align 3
G14180:
/* Here for all other cases */
        bis	$31, $2, $20 	# [1-]
        bis	$31, 15, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14171:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$3, $4, $3 	# reconstruct SCA [3]
        ldl	$21, 0($3)	#  [2]
        ldl	$20, 4($3)	# Read from stack cache [1]
        br	$31, G14170	# [1]
.align 3
G14173:
        blbc	$5, G14172	# [1]
        extll	$21, 0, $2 	# Do the indirect thing [0di]
        br	$31, G14169	# [1-]
.align 3
G14172:
        ldq	$6, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $5 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$5, $6, $5 	# Adjust for a longword load [2di]
        ldl	$6, 0($5)	# Get the memory action [2]
.align 3
G14177:
        and	$6, MemoryActionTransform, $5 	# [3]
        beq	$5, G14176	# [1]
        bic	$20, 63, $20 	# [1-]
        bis	$20, TypeExternalValueCellPointer, $20 	# [1]
        br	$31, G14150	# [1-]
#ifndef MINIMA
G14176:
#endif
#ifdef MINIMA
.align 3
G14176:
        and	$6, MemoryActionBinding, $5 	# [1-]
        ldq	$4, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$5, G14175	# [1-]
        sll	$2, 1, $3 	# [0di]
        ldq	$5, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$3, $4, $3 	# Hash index [1di]
        bis	$31, 1, $4 	# [1]
        sll	$4, IvoryMemoryData, $4 	# [1]
        addl	$3, $5, $3 	# [1]
        extll	$3, 0, $3 	# Clear sign-extension [1]
        s4addq	$3, $4, $4 	# [2]
        ldl	$3, 0($4)	# Fetch the key [2]
        ldl	$21, 4($4)	# Fetch value [1]
        subl	$2, $3, $5 	# Compare [2di]
        bne	$5, G14179	# Trap on miss [1]
        extll	$21, 0, $2 	# Extract the pointer, and indirect [0di]
        br	$31, G14169	# This is another memory read tailcall. [1-]
.align 3
G14179:
	br	$31, DBCACHEMISSTRAP
#endif
G14175:
/* Perform memory action */
        bis	$31, $6, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14156:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$3, $4, $3 	# reconstruct SCA [3]
        ldl	$21, 0($3)	#  [2]
        ldl	$20, 4($3)	# Read from stack cache [1]
        br	$31, G14155	# [1]
.align 3
G14158:
        blbc	$5, G14157	# [1]
        extll	$21, 0, $2 	# Do the indirect thing [0di]
        br	$31, G14154	# [1-]
.align 3
G14157:
        ldq	$6, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $5 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$5, $6, $5 	# Adjust for a longword load [2di]
        ldl	$6, 0($5)	# Get the memory action [2]
.align 3
G14162:
        and	$6, MemoryActionTransform, $5 	# [3]
        beq	$5, G14161	# [1]
        bic	$20, 63, $20 	# [1-]
        bis	$20, TypeExternalValueCellPointer, $20 	# [1]
        br	$31, G14165	# [1-]
#ifndef MINIMA
G14161:
#endif
#ifdef MINIMA
.align 3
G14161:
        and	$6, MemoryActionBinding, $5 	# [1-]
        ldq	$4, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$5, G14160	# [1-]
        sll	$2, 1, $3 	# [0di]
        ldq	$5, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$3, $4, $3 	# Hash index [1di]
        bis	$31, 1, $4 	# [1]
        sll	$4, IvoryMemoryData, $4 	# [1]
        addl	$3, $5, $3 	# [1]
        extll	$3, 0, $3 	# Clear sign-extension [1]
        s4addq	$3, $4, $4 	# [2]
        ldl	$3, 0($4)	# Fetch the key [2]
        ldl	$21, 4($4)	# Fetch value [1]
        subl	$2, $3, $5 	# Compare [2di]
        bne	$5, G14164	# Trap on miss [1]
        extll	$21, 0, $2 	# Extract the pointer, and indirect [0di]
        br	$31, G14154	# This is another memory read tailcall. [1-]
.align 3
G14164:
	br	$31, DBCACHEMISSTRAP
#endif
G14160:
/* Perform memory action */
        bis	$31, $6, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end PullApplyArgsSlowly
.align 5
.globl DoLocateLocals
.ent DoLocateLocals 0
/* Halfword operand from stack instruction - DoLocateLocals */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLocateLocalsFP
	.globl DoLocateLocalsSP
	.globl DoLocateLocalsLP
	.globl DoLocateLocalsIM
.align 3
DoLocateLocals:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLocateLocalsSP"
#endif
.align 3
DoLocateLocalsSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoLocateLocals	# [0di]
	.byte 0x90
	.asciiz "DoLocateLocalsLP"
#endif
.align 3
DoLocateLocalsLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoLocateLocals	# [1]
	.byte 0x84
	.asciiz "DoLocateLocalsFP"
#endif
.align 3
DoLocateLocalsFP:	# Entry point for FP relative
.align 3
beginDoLocateLocals:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, PROCESSORSTATE_CONTROL($14)	# The control register [0di]
        bis	$12, $31, $11 	# [1-]
        subq	$11, $10, $3 	# arg size including the fudge 2 [1]
        srl	$3, 3, $3 	# adjust arg size to words [1]
        and	$1, 255, $2 	# argument size [1]
        subq	$2, 2, $2 	# corrected arg size [1]
        bic	$1, 255, $1 	# [1]
        bis	$1, $3, $1 	# replace the arg size [1]
        bis	$31, TypeFixnum, $4 	# [1]
        stl	$2, 8($12)	#  [1-]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        stl	$1, PROCESSORSTATE_CONTROL($14)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoLocateLocalsIM"
#endif
DoLocateLocalsIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoLocateLocals.
.end DoLocateLocals
/* End of Halfword operand from stack instruction - DoLocateLocals */
/* Returning. */
.align 5
.globl DoReturnMultiple
.ent DoReturnMultiple 0
/* Halfword operand from stack instruction - DoReturnMultiple */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoReturnMultipleFP
	.globl DoReturnMultipleSP
	.globl DoReturnMultipleLP
	.globl DoReturnMultipleIM
.align 3
DoReturnMultiple:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoReturnMultipleSP"
#endif
.align 3
DoReturnMultipleSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoReturnMultiple	# [0di]
	.byte 0x90
	.asciiz "DoReturnMultipleLP"
#endif
.align 3
DoReturnMultipleLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoReturnMultiple	# [1]
	.byte 0x84
	.asciiz "DoReturnMultipleFP"
#endif
.align 3
DoReturnMultipleFP:	# Entry point for FP relative
.align 3
beginDoReturnMultiple:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, 4($16)	# Fetch the tag for type-check [2]
        ldl	$16, 0($16)	# Fetch the data [1]
        subq	$1, TypeFixnum, $2 	# [2di]
        and	$2, 63, $2 	# Strip CDR code [1]
        bne	$2, RETURNMULTIPLEIO	# [1]
        extll	$16, 0, $16 	# Discard dtp-fixnum tag word [1-]
.align 3
RETURNMULTIPLETOP:
        ldl	$20, PROCESSORSTATE_CONTROL($14)	#  [1-]
        ldah	$3, 12	#  [0di]
        addq	$12, 8, $2 	# [1]
        sll	$16, 3, $1 	# Value bytes [1]
        and	$3, $20, $3 	# Mask [1]
        srl	$3, 18, $3 	# Shift disposition bits into place. [1]
        subq	$2, $1, $18 	# Compute position of value(s) [1]
        ldq	$21, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        subq	$3, 2, $19 	# arg4 -2=effect -1=value 0=return 1=multiple [1-]
        blt	$19, RETURNMULTIPLESINGLE	# [1]
/* Restore machine state from frame header. */
        ldl	$3, 0($10)	#  [1-]
        ldah	$1, 1792	#  [0di]
        ldl	$5, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        and	$20, $1, $1 	# Mask [0di]
        ldl	$2, 4($10)	#  [1-]
        bis	$13, $31, $7 	# [0di]
        bne	$1, HANDLEFRAMECLEANUP	# Need to cleanup frame first [1-]
        extll	$3, 0, $3 	# [0di]
        ldl	$4, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        extll	$5, 0, $5 	# [0di]
#ifdef IVERIFY
/* check for instruction verification suite end-of-test */
        subl	$2, TypeNIL, $6 	# check for end of run [1]
        beq	$6, G14200	# [1]
#endif
        ldl	$6, 8($10)	# Get saved control register [1]
/* TagType. */
        and	$2, 63, $2 	# [0di]
/* Restore the PC. */
        beq	$19, G14202	# [1-]
        sll	$5, 1, $9 	# Assume even PC [0di]
        and	$4, 1, $1 	# [1]
        ldq	$7, PROCESSORSTATE_CONTINUATIONCP($14)	#  [0di]
        addq	$9, $1, $9 	# [1-]
.align 3
G14202:
/* Restore the saved continuation */
        stl	$2, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        srl	$20, 9, $1 	# Get the caller frame size into place [0di]
        stl	$3, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        subq	$10, 8, $12 	# Restore the stack pointer. [0di]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1-]
        and	$1, 255, $1 	# Mask just the caller frame size. [0di]
        s8addq	$1, 0, $1 	# *8 [1]
        ldah	$2, 2048	#  [1]
        and	$2, $20, $2 	# [1]
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	# Get the preempt-pending bit [0di]
        bis	$2, $6, $6 	# Sticky trace pending bit. [1-]
        ldq	$4, PROCESSORSTATE_PLEASE_STOP($14)	# Get the trap/suspend bits [0di]
        subq	$10, $1, $10 	# Restore the frame pointer. [1-]
        stl	$6, PROCESSORSTATE_CONTROL($14)	# Restore the control register [0di]
        and	$6, 255, $1 	# extract the argument size [1-]
        and	$3, 1, $3 	# [1]
        bis	$4, $3, $3 	# [1]
        stq	$3, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [0di]
        s8addq	$1, $10, $11 	# Restore the local pointer. [1-]
        cmpult	$10, $21, $21 	# ARG6 = stack-cache underflow [1]
        addq	$12, 8, $4 	# Compute destination of copy [1]
        bis	$16, $31, $3 	# Values [1]
        ldq	$1, PROCESSORSTATE_CDRCODEMASK($14)	# mask for CDR codes [1-]
        br	$31, G14203	# [1]
.align 3
G14204:
        subq	$3, 1, $3 	# [1-]
        ldq	$2, 0($18)	# Get a word from source [0di]
        addq	$18, 8, $18 	# advance from position [1]
        bic	$2, $1, $2 	# Strip off CDR code [2]
        stq	$2, 0($4)	# Put word in destination [1-]
        addq	$4, 8, $4 	# advance to position [0di]
G14203:
        bgt	$3, G14204	# [1-]
        s8addq	$16, $12, $12 	# Adjust iSP over returned values [0di]
/* arg4 -2=effect -1=value 0=return 1=multiple */
        beq	$19, RETURNMULTIPLERETURN	# [1-]
.align 3
RETURNMULTIPLEMULTIPLE:
        bis	$31, TypeFixnum, $1 	# [1-]
        stl	$16, 8($12)	# push the MV return count [0di]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
.align 3
RETURNMULTIPLEDONE:
        bne	$21, RETURNMULTIPLEUNDERFLOW	# [1-]
        bis	$7, $31, $17 	# [0di]
        bne	$7, INTERPRETINSTRUCTIONPREDICTED	# [1-]
        bne	$19, INTERPRETINSTRUCTIONFORBRANCH	# [1]
        br	$31, INTERPRETINSTRUCTION	# Return-multiple done [1]
.align 3
RETURNMULTIPLEUNDERFLOW:
	br	$31, StackCacheUnderflowCheck
.align 3
RETURNMULTIPLESINGLE:
        ldq	$18, 0($18)	#  [1]
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$18, 26, $18 	# Clear cdr [2-]
        srl	$18, 26, $18 	# Clear cdr [2]
        cmoveq	$16, $1, $18 	# [1]
        br	$31, RETURNCOMMONTAIL	# [0di]
.align 3
RETURNMULTIPLERETURN:
        bne	$17, RETURNMULTIPLEDONE	# [1]
        bis	$31, TypeFixnum, $1 	# [0di]
        stl	$16, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, RETURNMULTIPLEDONE	# [0di]
#ifdef TRACING
        br	$31, DoReturnMultipleIM	# [1]
	.byte 0x82
	.asciiz "DoReturnMultipleIM"
#endif
.align 5
.align 3
DoReturnMultipleIM:	# Entry point for IMMEDIATE mode
        bis	$17, $31, $16 	# [1-]
        lda	$17, 1	#  [1]
        br	$31, RETURNMULTIPLETOP	# [1-]
.align 3
RETURNMULTIPLEIO:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoReturnMultiple
/* End of Halfword operand from stack instruction - DoReturnMultiple */
.align 5
.globl HANDLEFRAMECLEANUP
.ent HANDLEFRAMECLEANUP 0
.align 3
HANDLEFRAMECLEANUP:
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	# Restore SP to instruction start [1-]
        ldl	$20, PROCESSORSTATE_CONTROL($14)	# Get control register [1]
.align 3
G14207:
        ldah	$1, 1024	#  [1-]
        ldl	$4, PROCESSORSTATE_CATCHBLOCK($14)	#  [0di]
        extll	$4, 0, $4 	# [3]
        and	$1, $20, $2 	# [1]
        beq	$2, G14206	# J. if cr.cleanup-catch is 0 [1]
/* Convert VMA to stack cache address */
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$4, $2, $2 	# stack cache base relative offset [2di]
        s8addq	$2, $3, $3 	# reconstruct SCA [1]
        ldl	$6, 16($3)	#  [2]
        ldl	$5, 20($3)	#  [1]
        extll	$6, 0, $6 	# [2di]
        ldl	$2, 8($3)	#  [1-]
        ldl	$1, 12($3)	#  [1]
        extll	$2, 0, $2 	# [2-]
        and	$1, 64, $25 	# [1]
        bne	$25, HANDLEUNWINDPROTECT	# J. if catch block is UWP variety. [1]
        ldah	$3, 1024	#  [0di]
        and	$5, 64, $2 	# Extract the catchcleanup bit [1]
        sll	$2, 20, $2 	# Shift into place for CR [1]
        bic	$20, $3, $3 	# [1]
        bis	$3, $2, $20 	# [1]
        stl	$20, PROCESSORSTATE_CONTROL($14)	#  [1-]
/* TagType. */
        and	$5, 63, $5 	# [0di]
        sll	$5, 32, $5 	# [1]
        bis	$6, $5, $6 	# [2]
        stq	$6, PROCESSORSTATE_CATCHBLOCK($14)	#  [1-]
        br	$31, G14207	# [1]
.align 3
G14206:
        ldah	$1, 512	#  [1-]
        and	$1, $20, $2 	# [1]
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        beq	$2, G14205	# J. if cr.cleanup-bindings is 0. [0di]
#ifdef MINIMA
/* BSP not a locative -> Deep-bound */
        srl	$1, 32, $4 	# [3-]
        subq	$4, TypeLocative, $3 	# [2]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, DBUNWINDFRAMETRAP	# [1]
#endif
.align 3
G14208:
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1]
        extll	$1, 0, $1 	# vma only [2-]
        ldah	$2, 512	#  [1]
        subq	$1, 1, $5 	# [1]
        and	$4, $2, $3 	# [1]
        bic	$4, $2, $4 	# Turn off the bit [1]
        bne	$3, G14209	# [0di]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 20, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14209:
/* Memory Read Internal */
G14210:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $23 	# [0di]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$23, $31, $6 	# [0di]
        ldq_u	$7, 0($23)	#  [1-]
        subq	$1, $8, $8 	# Stack cache offset [1di]
        ldq	$24, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$8, $22, $22 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $23, $7 	# [0di]
        bne	$22, G14212	# [1-]
G14211:
        lda	$23, 224	#  [0di]
        srl	$24, $7, $24 	# [1]
        srl	$23, $7, $23 	# [1]
        blbs	$24, G14214	# [1-]
G14219:
/* Memory Read Internal */
G14220:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$5, $14, $23 	# [1-]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $2 	# [1-]
        ldq_u	$3, 0($23)	#  [1di]
        subq	$5, $8, $8 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_BINDREAD_MASK($14)	#  [0di]
        cmpult	$8, $22, $22 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$3, $23, $3 	# [1-]
        bne	$22, G14222	# [0di]
G14221:
        lda	$23, 224	#  [1-]
        srl	$24, $3, $24 	# [1]
        srl	$23, $3, $23 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$24, G14224	# [1-]
G14229:
/* Memory Read Internal */
G14230:
        ldq	$23, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$2, $14, $25 	# [1-]
        ldl	$24, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$25, $31, $22 	# [1-]
        ldq_u	$8, 0($25)	#  [1di]
        subq	$2, $23, $23 	# Stack cache offset [1-]
        cmpult	$23, $24, $24 	# In range? [1]
        ldl	$22, 0($22)	#  [1-]
        extbl	$8, $25, $8 	# [0di]
        bne	$24, G14232	# [1-]
G14231:
        ldq	$23, PROCESSORSTATE_BINDWRITE_MASK($14)	#  [0di]
        lda	$25, 224	#  [1-]
        srl	$23, $8, $23 	# [2]
        srl	$25, $8, $25 	# [1]
        blbs	$23, G14234	# [1di]
G14239:
/* Merge cdr-code */
        and	$7, 63, $22 	# [1-]
        and	$8, 192, $8 	# [1]
        bis	$8, $22, $8 	# [1]
        addq	$2, $14, $23 	# [1]
        s4addq	$23, $31, $22 	# [1]
        ldq_u	$25, 0($23)	#  [1di]
        insbl	$8, $23, $24 	# [1-]
        mskbl	$25, $23, $25 	# [2]
.align 3
G14242:
        bis	$25, $24, $25 	# [2]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        stq_u	$25, 0($23)	#  [1]
        ldl	$23, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
        subq	$2, $24, $24 	# Stack cache offset [1-]
        cmpult	$24, $23, $23 	# In range? [2]
        stl	$6, 0($22)	#  [1-]
        bne	$23, G14241	# J. if in cache [1]
G14240:
        and	$3, 64, $3 	# Get the old cleanup-bindings bit [1-]
        sll	$3, 19, $3 	# [1]
        subq	$1, 2, $1 	# [1]
        stl	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [0di]
        bis	$4, $3, $4 	# [1-]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_CONTROL($14)	#  [1]
        ldah	$1, 512	#  [0di]
        and	$1, $20, $2 	# [3]
        bne	$2, G14208	# J. if cr.cleanup-bindings is 0. [1]
        ldl	$2, PROCESSORSTATE_INTERRUPTREG($14)	#  [1]
        and	$2, 2, $3 	# [3]
        cmpeq	$3, 2, $3 	# [1]
        bis	$2, $3, $2 	# [2]
        stl	$2, PROCESSORSTATE_INTERRUPTREG($14)	#  [1-]
        beq	$2, G14243	# [1]
        stq	$2, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
.align 3
G14243:
.align 3
G14205:
        ldah	$3, 256	#  [1-]
        and	$3, $20, $2 	# [1]
        beq	$2, INTERPRETINSTRUCTION	# [1]
        bis	$31, $31, $20 	# [0di]
        bis	$31, 79, $17 	# [1]
	br	$31, ILLEGALOPERAND
        br	$31, INTERPRETINSTRUCTION	# Retry the instruction [0di]
.align 3
G14241:
        ldq	$23, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$24, $23, $23 	# reconstruct SCA [3]
        stl	$6, 0($23)	# Store in stack [2]
        stl	$8, 4($23)	# write the stack cache [1]
        br	$31, G14240	# [1]
.align 3
G14232:
        ldq	$24, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$23, $24, $23 	# reconstruct SCA [3]
        ldl	$22, 0($23)	#  [2]
        ldl	$8, 4($23)	# Read from stack cache [1]
        br	$31, G14231	# [1]
.align 3
G14234:
        blbc	$25, G14233	# [1]
        extll	$22, 0, $2 	# Do the indirect thing [0di]
        br	$31, G14230	# [1-]
.align 3
G14233:
        ldq	$23, PROCESSORSTATE_BINDWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$8, 63, $25 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$25, $23, $25 	# Adjust for a longword load [2di]
        ldl	$23, 0($25)	# Get the memory action [2]
G14236:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 3, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14222:
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $22, $8 	# reconstruct SCA [3]
        ldl	$2, 0($8)	#  [2]
        ldl	$3, 4($8)	# Read from stack cache [1]
        br	$31, G14221	# [1]
.align 3
G14224:
        blbc	$23, G14223	# [1]
        extll	$2, 0, $5 	# Do the indirect thing [0di]
        br	$31, G14220	# [1-]
.align 3
G14223:
        ldq	$24, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$3, 63, $23 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
G14226:
/* Perform memory action */
        bis	$31, $24, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14212:
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $22, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G14211	# [1]
.align 3
G14214:
        blbc	$23, G14213	# [1]
        extll	$6, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14210	# [1-]
.align 3
G14213:
        ldq	$24, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
G14216:
/* Perform memory action */
        bis	$31, $24, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end HANDLEFRAMECLEANUP
.align 5
.globl StackCacheUnderflowCheck
.ent StackCacheUnderflowCheck 0
.align 3
StackCacheUnderflowCheck:
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# Preserve through instruction's original SP [1]
        subq	$1, $10, $3 	# Number of words*8 to fill iff positive [2-]
        ble	$3, INTERPRETINSTRUCTIONFORBRANCH	# [1]
        sra	$3, 3, $3 	# Convert to a word count [1]
        addq	$4, 8, $4 	# Account for the inclusive limit [1]
        ble	$3, INTERPRETINSTRUCTIONFORBRANCH	# in case only low three bits nonzero [1-]
	bsr	$0, StackCacheUnderflow
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end StackCacheUnderflowCheck
.align 5
.globl StackCacheUnderflow
.ent StackCacheUnderflow 0
.align 3
StackCacheUnderflow:
        s8addq	$3, $1, $2 	# Compute target address for shift [1-]
        subq	$4, $1, $5 	# Compute number of elements to preserve [1]
        sra	$5, 3, $5 	# Convert to word count [1]
/* Shove everything up */
        s8addq	$5, $1, $1 	# Adjust to end of source block [2]
        s8addq	$5, $2, $2 	# Adjust to end of target block [1]
        br	$31, G14244	# [0di]
.align 3
G14245:
        subq	$1, 8, $1 	# advance from position [1-]
        subq	$5, 1, $5 	# [1]
        ldq	$7, 0($1)	# Get a word from source [1-]
        subq	$2, 8, $2 	# advance to position [0di]
        stq	$7, 0($2)	# Put word in destination [2]
G14244:
        bgt	$5, G14245	# [1]
/* Adjust stack cache relative registers */
        s8addq	$3, $10, $10 	# [1-]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	#  [0di]
        s8addq	$3, $12, $12 	# [1-]
        s8addq	$3, $11, $11 	# [1]
        s8addq	$3, $4, $4 	# [1]
/* Fill freshly opened slots of stack cache from memory */
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        stq	$4, PROCESSORSTATE_RESTARTSP($14)	#  [1]
        subq	$1, $3, $1 	# Compute new base address of stack cache [1-]
        ldq	$4, PROCESSORSTATE_STACKCACHETOPVMA($14)	# Top of cache [0di]
        stq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$4, $3, $4 	# Adjust top of cache [2di]
        stq	$4, PROCESSORSTATE_STACKCACHETOPVMA($14)	#  [1-]
        addq	$1, $14, $7 	# [0di]
        s4addq	$7, $31, $5 	# [1]
        fetch	0($7)	#  [1di]
        ldq_u	$4, 0($7)	#  [1]
        fetch	0($5)	#  [1]
        ldl	$5, 0($5)	#  [1]
        extbl	$4, $7, $4 	# [1di]
        br	$31, G14246	# [1-]
.align 3
G14247:
        addq	$1, $14, $7 	# [1-]
        s4addq	$7, $31, $5 	# [1]
        ldq_u	$4, 0($7)	#  [1-]
        ldl	$5, 0($5)	#  [1]
        extbl	$4, $7, $4 	# [2-]
        subq	$3, 1, $3 	# [1]
        addq	$1, 1, $1 	# advance vma position [1]
        stl	$5, 0($2)	#  [0di]
        stl	$4, 4($2)	# write the stack cache [1]
        addq	$2, 8, $2 	# advance sca position [0di]
G14246:
        bgt	$3, G14247	# [1-]
#ifdef TRACING
/* Trace instructions if requested. */
        ldq	$4, PROCESSORSTATE_TRACE_HOOK($14)	#  [0di]
        beq	$4, G14252	# J. if not tracing. [3]
/* Record an instruction trace entry */
        ldl	$5, TRACEDATA_RECORDING_P($4)	#  [0di]
        ldq	$1, TRACEDATA_START_PC($4)	#  [1]
        bne	$5, G14248	# Jump if recording is on [2di]
        cmpeq	$1, $9, $1 	# Turn recording on if at the start PC [1-]
        stl	$1, TRACEDATA_RECORDING_P($4)	#  [0di]
        beq	$1, G14252	# Jump if not at the start PC [1]
.align 3
G14248:
        ldq	$5, TRACEDATA_CURRENT_ENTRY($4)	# Get address of next trace record  [1-]
        ldq	$1, PROCESSORSTATE_INSTRUCTION_COUNT($14)	#  [1]
        stq	$9, TRACERECORD_EPC($5)	# Save current PC [2]
        stq	$1, TRACERECORD_COUNTER($5)	# Save instruction count [1]
        ldq	$1, 0($12)	#  [1]
/* Convert stack cache address to VMA */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $3, $3 	# stack cache base relative offset [2di]
        srl	$3, 3, $3 	# convert byte address to word address [1]
        addq	$3, $2, $2 	# reconstruct VMA [2]
        stq	$1, TRACERECORD_TOS($5)	# Save current value of TOS [1-]
        stq	$2, TRACERECORD_SP($5)	# Save current SP [1]
        ldl	$1, CACHELINE_OPERAND($13)	#  [1]
        ldq	$2, CACHELINE_CODE($13)	#  [1]
        stl	$1, TRACERECORD_OPERAND($5)	# Save current instruction's operand [1]
        stq	$2, TRACERECORD_INSTRUCTION($5)	# Save pointer to current instruction code [1]
        ldq	$2, PROCESSORSTATE_CONTROL($14)	#  [1]
        ldq	$3, CACHELINE_INSTRUCTION($13)	#  [1]
        stl	$31, TRACERECORD_CATCH_BLOCK_P($5)	# We don't yet record catch blocks [1]
        stq	$2, TRACERECORD_CATCH_BLOCK_0($5)	# Save control register [1]
        ldq	$1, PROCESSORSTATE_TVI($14)	#  [1]
        stq	$3, TRACERECORD_INSTRUCTION_DATA($5)	# Save full word instruction operand [1]
        stl	$1, TRACERECORD_TRAP_P($5)	# Save trap indiciator [1]
        beq	$1, G14249	# Jump if didn't trap [1]
        ldq	$1, 16($10)	#  [1]
        stq	$31, PROCESSORSTATE_TVI($14)	# Zero flag to avoid false trap entries [1]
        ldq	$2, 24($10)	#  [1]
        stq	$1, TRACERECORD_TRAP_DATA_0($5)	# Save trap vector index [1]
        ldq	$3, 32($10)	#  [1]
        stq	$2, TRACERECORD_TRAP_DATA_1($5)	# Save fault PC [1]
        ldq	$6, 40($10)	#  [1]
        stq	$3, TRACERECORD_TRAP_DATA_2($5)	# Save two additional arguments [1]
        stq	$6, TRACERECORD_TRAP_DATA_3($5)	#  [1]
.align 3
G14249:
        addq	$5, TRACERECORDSIZE, $5 	# Bump to next trace record [1-]
        ldq	$1, TRACEDATA_RECORDS_START($4)	# Get pointer to start of trace records [0di]
        stq	$5, TRACEDATA_CURRENT_ENTRY($4)	# Set record pointer to keep printer happy [1]
        ldq	$2, TRACEDATA_RECORDS_END($4)	# Get pointer to end of trace record [1]
        ldq	$3, TRACEDATA_PRINTER($4)	# Function to print trace if non-zero [1]
        cmple	$2, $5, $2 	# Non-zero iff we're about to wrap the circular buffer [2di]
        cmovne	$2, $1, $5 	# Update next record pointer iff we wrapped [2]
        cmoveq	$2, $31, $3 	# Don't print if we didn't wrap [1]
        beq	$3, G14250	# Jump if we don't need to print [2]
        stq	$13, PROCESSORSTATE_CP($14)	#  [1]
        stq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        stq	$12, PROCESSORSTATE_SP($14)	#  [1]
        stq	$10, PROCESSORSTATE_FP($14)	#  [1]
        stq	$11, PROCESSORSTATE_LP($14)	#  [1]
        stq	$16, PROCESSORSTATE_ASRF2($14)	#  [1]
        stq	$17, PROCESSORSTATE_ASRF3($14)	#  [1]
        stq	$18, PROCESSORSTATE_ASRF4($14)	#  [1]
        stq	$19, PROCESSORSTATE_ASRF5($14)	#  [1]
        stq	$20, PROCESSORSTATE_ASRF6($14)	#  [1]
        stq	$21, PROCESSORSTATE_ASRF7($14)	#  [1]
        stq	$4, PROCESSORSTATE_ASRF8($14)	#  [1]
        stq	$5, PROCESSORSTATE_ASRF9($14)	#  [1]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        bis	$3, $31, $27 	# [1-]
        jsr	$26, ($3), 0	# [0di]
        ldq	$9, PROCESSORSTATE_ASRR9($14)	#  [1]
        ldq	$10, PROCESSORSTATE_ASRR10($14)	#  [1]
        ldq	$11, PROCESSORSTATE_ASRR11($14)	#  [1]
        ldq	$12, PROCESSORSTATE_ASRR12($14)	#  [1]
        ldq	$13, PROCESSORSTATE_ASRR13($14)	#  [1]
        ldq	$15, PROCESSORSTATE_ASRR15($14)	#  [1]
        ldq	$27, PROCESSORSTATE_ASRR27($14)	#  [1]
        ldq	$29, PROCESSORSTATE_ASRR29($14)	#  [1]
        ldq	$16, PROCESSORSTATE_ASRF2($14)	#  [1]
        ldq	$17, PROCESSORSTATE_ASRF3($14)	#  [1]
        ldq	$18, PROCESSORSTATE_ASRF4($14)	#  [1]
        ldq	$19, PROCESSORSTATE_ASRF5($14)	#  [1]
        ldq	$20, PROCESSORSTATE_ASRF6($14)	#  [1]
        ldq	$21, PROCESSORSTATE_ASRF7($14)	#  [1]
        ldq	$4, PROCESSORSTATE_ASRF8($14)	#  [1]
        ldq	$5, PROCESSORSTATE_ASRF9($14)	#  [1]
        ldq	$13, PROCESSORSTATE_CP($14)	#  [1]
        ldq	$9, PROCESSORSTATE_EPC($14)	#  [1]
        ldq	$12, PROCESSORSTATE_SP($14)	#  [1]
        ldq	$10, PROCESSORSTATE_FP($14)	#  [1]
        ldq	$11, PROCESSORSTATE_LP($14)	#  [1]
        bis	$31, $31, $2 	# Claim we didn't wrap [0di]
.align 3
G14250:
        stq	$5, TRACEDATA_CURRENT_ENTRY($4)	# Save next record pointer [1-]
        beq	$2, G14251	# Jump if we didn't wrap [1]
        stl	$2, TRACEDATA_WRAP_P($4)	# Set flag indicating that we wrapped [1]
.align 3
G14251:
        ldq	$5, TRACEDATA_STOP_PC($4)	#  [1]
        cmpeq	$5, $9, $5 	# Non-zero if at PC where we should stop tracing [3]
        cmpeq	$5, 0, $5 	# Non-zero if not at the PC [2]
        stl	$5, TRACEDATA_RECORDING_P($4)	# Update recording flag [0di]
.align 3
G14252:
#endif
        ret	$31, ($0), 1	# [1]
.end StackCacheUnderflow
.align 5
.globl StackCacheOverflowHandler
.ent StackCacheOverflowHandler 2
.align 3
StackCacheOverflowHandler:
/* Stack cache overflow detected */
        lda	$1, 256	#  [3]
        addq	$1, $17, $1 	# Account for what we're about to push [1]
        s8addq	$1, $12, $1 	# SCA of desired end of cache [1]
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1]
        subq	$1, $4, $4 	# New limit*8 [3]
        srl	$4, 3, $4 	# [1]
        stl	$4, PROCESSORSTATE_SCOVLIMIT($14)	# Update stack cache limit [0di]
/* Check that the page underlying the end of the stack cache is accessible */
/* Convert stack cache address to VMA */
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$1, $4, $4 	# stack cache base relative offset [2-]
        srl	$4, 3, $4 	# convert byte address to word address [1]
        addq	$4, $3, $3 	# reconstruct VMA [2]
        ldq	$5, PROCESSORSTATE_VMATTRIBUTETABLE($14)	# Per-page attributes table [0di]
        srl	$3, MemoryPageAddressShift, $4 	# Index into the attributes table [1-]
        addq	$4, $5, $5 	# Address of the page's attributes [2]
        ldq_u	$4, 0($5)	# Get the quadword with the page's attributes [2]
        stq	$3, PROCESSORSTATE_VMA($14)	# Stash the VMA [1]
        extbl	$4, $5, $4 	# Extract the page's attributes [2-]
        beq	$4, PAGENOTRESIDENT	# Non-existent page [2]
        and	$4, VMAttributeAccessFault, $5 	# [1-]
        bne	$5, PAGEFAULTREQUESTHANDLER	# Access fault [1]
        and	$4, VMAttributeWriteFault, $5 	# [1]
        bne	$5, PAGEWRITEFAULT	# Write fault [1]
/* Check if we must dump the cache */
        ldl	$4, PROCESSORSTATE_SCOVLIMIT($14)	# New stack cache limit (words) [1-]
        ldq	$5, PROCESSORSTATE_STACKCACHESIZE($14)	# Absolute size of the cache (words) [1]
        cmple	$4, $5, $5 	# [3]
        bne	$5, INTERPRETINSTRUCTION	# We're done if new limit is less than absolute limit [1]
/* Dump the stack cache to make room */
        lda	$1, 896	#  [1-]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Stack cache base VMA [0di]
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1]
        stl	$1, PROCESSORSTATE_SCOVDUMPCOUNT($14)	# Will be destructively modified [1]
        addq	$2, $14, $5 	# Starting address of tags [1-]
        s4addq	$5, $31, $2 	# Starting address of data [1]
/* Dump the data */
        fetch	0($3)	#  [1-]
        fetch_m	0($2)	#  [1]
        br	$31, G14253	# [1]
.align 3
G14254:
        ldl	$4, 0($3)	# Get data word [1]
        subq	$1, 1, $1 	# [0di]
        addq	$3, 8, $3 	# Advance SCA position [1]
        stl	$4, 0($2)	# Save data word [0di]
        addq	$2, 4, $2 	# Advance VMA position [1-]
G14253:
        bgt	$1, G14254	# [0di]
/* Dump the tags */
        ldl	$1, PROCESSORSTATE_SCOVDUMPCOUNT($14)	# Restore the count [1]
        bis	$31, $5, $2 	# Restore tag VMA [0di]
        sll	$1, 3, $4 	# [3]
        subq	$3, $4, $3 	# Restore orginal SCA [2]
        fetch	0($3)	#  [2]
        fetch_m	0($2)	#  [1]
        br	$31, G14255	# [1]
.align 3
G14256:
        subq	$1, 1, $1 	# [1-]
        ldl	$4, 4($3)	# Get tag word [0di]
        addq	$3, 8, $3 	# Advance SCA position [1]
        ldq_u	$5, 0($2)	# Get packed tags word [0di]
        insbl	$4, $2, $4 	# Position the new tag [2-]
        mskbl	$5, $2, $5 	# Remove old tag [1]
        bis	$4, $5, $5 	# Put in new byte [2]
        stq_u	$5, 0($2)	# Save packed tags word [0di]
        addq	$2, 1, $2 	# Advance VMA position [1-]
G14255:
        bgt	$1, G14256	# [0di]
        lda	$1, 896	#  [1]
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Stack cache base VMA [0di]
        ldq	$4, PROCESSORSTATE_STACKCACHETOPVMA($14)	# Top of cache [1]
        ldl	$5, PROCESSORSTATE_SCOVLIMIT($14)	# Cache limit in words [1]
        addq	$2, $1, $2 	# Adjust cache base VMA [1-]
        addq	$4, $1, $4 	# Adjust top of cache [1]
        subq	$5, $1, $5 	# Adjust limit [1]
        stq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Save update [0di]
        stq	$4, PROCESSORSTATE_STACKCACHETOPVMA($14)	#  [1]
        stl	$5, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
/* Move the cache down */
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1]
        s8addq	$1, $3, $2 	# SCA of first word of new base [3]
        br	$31, G14257	# [1-]
.align 3
G14258:
        subq	$1, 1, $1 	# [1-]
        ldq	$5, 0($2)	# Get a word from source [0di]
        addq	$2, 8, $2 	# advance from position [1]
        stq	$5, 0($3)	# Put word in destination [0di]
        addq	$3, 8, $3 	# advance to position [1-]
G14257:
        bgt	$1, G14258	# [0di]
/* Adjust stack cache relative registers */
        lda	$1, 896	#  [1]
        sll	$1, 3, $1 	# Convert to SCA adjustment [1]
        subq	$12, $1, $12 	# [2]
        subq	$10, $1, $10 	# [1]
        subq	$11, $1, $11 	# [1]
        stq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [0di]
        br	$31, INTERPRETINSTRUCTION	# [1]
.end StackCacheOverflowHandler
.align 5
.globl DoReturnKludge
.ent DoReturnKludge 0
/* Halfword operand from stack instruction - DoReturnKludge */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoReturnKludgeFP
	.globl DoReturnKludgeSP
	.globl DoReturnKludgeLP
	.globl DoReturnKludgeIM
.align 3
DoReturnKludge:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoReturnKludgeSP"
#endif
.align 3
DoReturnKludgeSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoReturnKludge	# [0di]
	.byte 0x90
	.asciiz "DoReturnKludgeLP"
#endif
.align 3
DoReturnKludgeLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoReturnKludge	# [1]
	.byte 0x84
	.asciiz "DoReturnKludgeFP"
#endif
.align 3
DoReturnKludgeFP:	# Entry point for FP relative
.align 3
beginDoReturnKludge:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, 4($16)	#  [2]
        ldl	$17, 0($16)	#  [1]
        subq	$1, TypeFixnum, $2 	# [2di]
        and	$2, 63, $2 	# Strip CDR code [1]
        bne	$2, RETURNKLUDGEIO	# [1]
        extll	$17, 0, $17 	# [1-]
#ifdef TRACING
        br	$31, DoReturnKludgeIM	# [0di]
	.byte 0x82
	.asciiz "DoReturnKludgeIM"
#endif
.align 5
.align 3
DoReturnKludgeIM:	# Entry point for IMMEDIATE mode
        ldq	$21, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8subq	$17, 8, $1 	# [1di]
        ldl	$2, PROCESSORSTATE_CONTROL($14)	#  [1-]
        subq	$12, $1, $1 	# t1 is the values block [0di]
/* Restore machine state from frame header. */
        ldl	$5, 0($10)	#  [1-]
        ldah	$3, 1792	#  [0di]
        ldl	$7, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        and	$2, $3, $3 	# Mask [1di]
        ldl	$4, 4($10)	#  [1-]
        bis	$13, $31, $22 	# [0di]
        bne	$3, RETURNKLUDGECLEANUP	# Need to cleanup frame first [1-]
        extll	$5, 0, $5 	# [0di]
        ldl	$6, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        extll	$7, 0, $7 	# [0di]
#ifdef IVERIFY
/* check for instruction verification suite end-of-test */
        subl	$4, TypeNIL, $8 	# check for end of run [1]
        beq	$8, G14259	# [1]
#endif
        ldl	$8, 8($10)	# Get saved control register [1]
/* TagType. */
        and	$4, 63, $4 	# [0di]
/* Restore the PC. */
        sll	$7, 1, $9 	# Assume even PC [1]
        and	$6, 1, $3 	# [1]
        ldq	$22, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1-]
        addq	$9, $3, $9 	# [0di]
.align 3
G14261:
/* Restore the saved continuation */
        stl	$4, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        srl	$2, 9, $3 	# Get the caller frame size into place [0di]
        stl	$5, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        subq	$10, 8, $12 	# Restore the stack pointer. [0di]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1-]
        and	$3, 255, $3 	# Mask just the caller frame size. [0di]
        s8addq	$3, 0, $3 	# *8 [1]
        ldah	$4, 2048	#  [1]
        and	$4, $2, $4 	# [1]
        ldl	$5, PROCESSORSTATE_INTERRUPTREG($14)	# Get the preempt-pending bit [0di]
        bis	$4, $8, $8 	# Sticky trace pending bit. [1-]
        ldq	$6, PROCESSORSTATE_PLEASE_STOP($14)	# Get the trap/suspend bits [0di]
        subq	$10, $3, $10 	# Restore the frame pointer. [1-]
        stl	$8, PROCESSORSTATE_CONTROL($14)	# Restore the control register [0di]
        and	$8, 255, $3 	# extract the argument size [1-]
        and	$5, 1, $5 	# [1]
        bis	$6, $5, $5 	# [1]
        stq	$5, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [0di]
        s8addq	$3, $10, $11 	# Restore the local pointer. [1-]
        cmpult	$10, $21, $21 	# ARG6 = stack-cache underflow [1]
        beq	$17, RKLOOPDONE	# [1-]
.align 3
RKLOOPTOP:
        ldq	$4, 0($1)	# Read a 40 bit word from the values block [1-]
        subq	$17, 1, $17 	# [0di]
        stq	$4, 8($12)	# Push value onto stack cdr codes and all [1-]
        addq	$1, 8, $1 	# [0di]
        addq	$12, 8, $12 	# [1]
        bgt	$17, RKLOOPTOP	# [0di]
.align 3
RKLOOPDONE:
        bne	$21, RETURNKLUDGEUNDERFLOW	# [1]
        beq	$22, INTERPRETINSTRUCTIONFORBRANCH	# No prediction, validate cache [1]
        fetch	0($22)	#  [1-]
        bis	$22, $31, $13 	# [0di]
        br	$31, INTERPRETINSTRUCTION	# [1-]
.align 3
RETURNKLUDGEIO:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
RETURNKLUDGECLEANUP:
	br	$31, HANDLEFRAMECLEANUP
.align 3
RETURNKLUDGEUNDERFLOW:
	br	$31, StackCacheUnderflowCheck
.end DoReturnKludge
/* End of Halfword operand from stack instruction - DoReturnKludge */
.align 5
.globl DoTakeValues
.ent DoTakeValues 0
/* Halfword operand from stack instruction - DoTakeValues */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoTakeValuesFP
	.globl DoTakeValuesSP
	.globl DoTakeValuesLP
	.globl DoTakeValuesIM
.align 3
DoTakeValues:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoTakeValuesIM"
#endif
.align 3
DoTakeValuesIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoTakeValues	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoTakeValuesSP"
#endif
.align 3
DoTakeValuesSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoTakeValues	# [0di]
	.byte 0x90
	.asciiz "DoTakeValuesLP"
#endif
.align 3
DoTakeValuesLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoTakeValues	# [1]
	.byte 0x84
	.asciiz "DoTakeValuesFP"
#endif
.align 3
DoTakeValuesFP:	# Entry point for FP relative
.align 3
headDoTakeValues:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoTakeValues:
/* arg1 has the operand, not sign extended if immediate. */
        ldq	$21, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        extll	$16, 0, $16 	# Number of values expected [2di]
        ldl	$19, 0($12)	# Number of values provided [1-]
        ldl	$18, 4($12)	# Number of values provided [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        subq	$16, $19, $17 	# [2]
        blt	$17, TAKEVALUESLOSE	# J. if too many args supplied [1]
        bgt	$17, TAKEVALUESPAD	# J. if too few values supplied [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
TAKEVALUESLOSE:
        s8addq	$17, $12, $12 	# Remove the unwanted values [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
TAKEVALUESPAD:
        ldl	$4, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [1]
        lda	$1, 128	#  [0di]
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1-]
        addq	$1, $17, $1 	# Account for what we're about to push [0di]
        s8addq	$1, $12, $1 	# SCA of desired end of cache [1]
        s8addq	$4, $2, $2 	# SCA of current end of cache [2]
        cmple	$1, $2, $4 	# [1]
        beq	$4, StackCacheOverflowHandler	# We're done if new SCA is within bounds [1]
.align 3
TAKEVALUESPADLOOP:
        stq	$21, 8($12)	# Push NIL [1]
        addq	$12, 8, $12 	# [0di]
        subq	$17, 1, $17 	# [1]
        bgt	$17, TAKEVALUESPADLOOP	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.end DoTakeValues
/* End of Halfword operand from stack instruction - DoTakeValues */
/* Catch Instructions */
.align 5
.globl DoCatchOpen
.ent DoCatchOpen 0
/* Halfword 10 bit immediate instruction - DoCatchOpen */
	.globl DoCatchOpenFP
	.globl DoCatchOpenSP
	.globl DoCatchOpenLP
	.globl DoCatchOpenIM
.align 3
DoCatchOpen:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoCatchOpen"
#endif
.align 3
DoCatchOpenIM:
.align 3
DoCatchOpenSP:
.align 3
DoCatchOpenLP:
.align 3
DoCatchOpenFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        and	$16, 1, $23 	# t10=1 if unwind-protect, t10=0 if catch [2]
        ldl	$3, PROCESSORSTATE_CATCHBLOCK+4($14)	# tag [1-]
        sll	$23, 38, $23 	# [0di]
        ldl	$4, PROCESSORSTATE_CATCHBLOCK($14)	# data [1-]
        ldq	$2, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
/* Convert stack cache address to VMA */
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$22, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $1, $1 	# stack cache base relative offset [2-]
        srl	$1, 3, $1 	# convert byte address to word address [1]
        addq	$1, $22, $22 	# reconstruct VMA [2]
        bis	$23, $2, $1 	# [1]
        stq	$1, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        ldl	$24, PROCESSORSTATE_CONTROL($14)	#  [1-]
        srl	$24, 20, $2 	# Get old cleanup catch bit [3]
        and	$2, 64, $2 	# [2]
        srl	$24, 1, $1 	# Get old extra arg bit [1]
        and	$1, 128, $1 	# [2]
        bis	$1, $2, $1 	# [1]
/* TagType. */
        and	$3, 63, $2 	# [1]
        bis	$1, $2, $1 	# T1 now has new tag [1]
        stl	$4, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        bne	$23, CATCHOPEN2	# [0di]
        ldl	$2, PROCESSORSTATE_CONTINUATION($14)	#  [1-]
        ldl	$1, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        extll	$2, 0, $2 	# [2-]
/* TagType. */
        and	$1, 63, $1 	# [1]
        and	$16, 192, $3 	# T3 has the disposition bits in place [1]
        bis	$1, $3, $1 	# [1]
        stl	$2, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
.align 3
CATCHOPEN2:
        bis	$31, TypeLocative, $1 	# [1]
        stl	$1, PROCESSORSTATE_CATCHBLOCK+4($14)	# tag [0di]
        stl	$22, PROCESSORSTATE_CATCHBLOCK($14)	# data [1]
        ldah	$1, 1024	#  [0di]
        bis	$1, $24, $1 	# set it [1]
        stl	$1, PROCESSORSTATE_CONTROL($14)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.end DoCatchOpen
/* End of Halfword operand from stack instruction - DoCatchOpen */
.align 5
.globl DoCatchClose
.ent DoCatchClose 0
/* Halfword operand from stack instruction - DoCatchClose */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoCatchCloseFP
	.globl DoCatchCloseSP
	.globl DoCatchCloseLP
	.globl DoCatchCloseIM
.align 3
DoCatchClose:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoCatchCloseSP"
#endif
.align 3
DoCatchCloseSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoCatchClose	# [0di]
	.byte 0x90
	.asciiz "DoCatchCloseLP"
#endif
.align 3
DoCatchCloseLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoCatchClose	# [1]
	.byte 0x84
	.asciiz "DoCatchCloseFP"
#endif
.align 3
DoCatchCloseFP:	# Entry point for FP relative
.align 3
beginDoCatchClose:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$1, PROCESSORSTATE_CATCHBLOCK($14)	# data [0di]
        extll	$1, 0, $1 	# [3]
/* Convert VMA to stack cache address */
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldq	$23, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $3, $3 	# stack cache base relative offset [2di]
        s8addq	$3, $23, $23 	# reconstruct SCA [1]
        ldl	$19, 8($23)	# bstag bsdata [2]
        ldl	$18, 12($23)	#  [1]
        extll	$19, 0, $19 	# [2di]
        ldq	$4, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        ldl	$21, 16($23)	# prtag prdata [1]
        ldl	$20, 20($23)	#  [1]
        extll	$21, 0, $21 	# [2di]
        srl	$4, 32, $3 	# [1]
        subl	$19, $4, $5 	# [1]
        beq	$5, CATCHCLOSELD	# [1]
        subq	$3, TypeLocative, $1 	# [0di]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, CATCHCLOSEDBT	# [1]
.align 3
CATCHCLOSELT:
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1]
        extll	$1, 0, $1 	# vma only [2-]
        ldah	$2, 512	#  [1]
        subq	$1, 1, $5 	# [1]
        and	$4, $2, $3 	# [1]
        bic	$4, $2, $4 	# Turn off the bit [1]
        bne	$3, G14263	# [0di]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 20, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14263:
/* Memory Read Internal */
G14264:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $16 	# [0di]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$16, $31, $6 	# [0di]
        ldq_u	$7, 0($16)	#  [1-]
        subq	$1, $8, $8 	# Stack cache offset [1di]
        ldq	$17, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$8, $22, $22 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $16, $7 	# [0di]
        bne	$22, G14266	# [1-]
G14265:
        lda	$16, 224	#  [0di]
        srl	$17, $7, $17 	# [1]
        srl	$16, $7, $16 	# [1]
        blbs	$17, G14268	# [1-]
G14273:
/* Memory Read Internal */
G14274:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$5, $14, $16 	# [1-]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$16, $31, $2 	# [1-]
        ldq_u	$3, 0($16)	#  [1di]
        subq	$5, $8, $8 	# Stack cache offset [1-]
        ldq	$17, PROCESSORSTATE_BINDREAD_MASK($14)	#  [0di]
        cmpult	$8, $22, $22 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$3, $16, $3 	# [1-]
        bne	$22, G14276	# [0di]
G14275:
        lda	$16, 224	#  [1-]
        srl	$17, $3, $17 	# [1]
        srl	$16, $3, $16 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$17, G14278	# [1-]
G14283:
/* Memory Read Internal */
G14284:
        ldq	$16, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$2, $14, $24 	# [1-]
        ldl	$17, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$24, $31, $22 	# [1-]
        ldq_u	$8, 0($24)	#  [1di]
        subq	$2, $16, $16 	# Stack cache offset [1-]
        cmpult	$16, $17, $17 	# In range? [1]
        ldl	$22, 0($22)	#  [1-]
        extbl	$8, $24, $8 	# [0di]
        bne	$17, G14286	# [1-]
G14285:
        ldq	$16, PROCESSORSTATE_BINDWRITE_MASK($14)	#  [0di]
        lda	$24, 224	#  [1-]
        srl	$16, $8, $16 	# [2]
        srl	$24, $8, $24 	# [1]
        blbs	$16, G14288	# [1di]
G14293:
/* Merge cdr-code */
        and	$7, 63, $22 	# [1-]
        and	$8, 192, $8 	# [1]
        bis	$8, $22, $8 	# [1]
        addq	$2, $14, $16 	# [1]
        s4addq	$16, $31, $22 	# [1]
        ldq_u	$24, 0($16)	#  [1di]
        insbl	$8, $16, $17 	# [1-]
        mskbl	$24, $16, $24 	# [2]
.align 3
G14296:
        bis	$24, $17, $24 	# [2]
        ldq	$17, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        stq_u	$24, 0($16)	#  [1]
        ldl	$16, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
        subq	$2, $17, $17 	# Stack cache offset [1-]
        cmpult	$17, $16, $16 	# In range? [2]
        stl	$6, 0($22)	#  [1-]
        bne	$16, G14295	# J. if in cache [1]
G14294:
        and	$3, 64, $3 	# Get the old cleanup-bindings bit [1-]
        sll	$3, 19, $3 	# [1]
        subq	$1, 2, $1 	# [1]
        stl	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [0di]
        bis	$4, $3, $4 	# [1-]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [0di]
        subl	$19, $1, $5 	# [1-]
        bne	$5, CATCHCLOSELT	# [1]
        ldl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1-]
        and	$3, 2, $4 	# [3]
        cmpeq	$4, 2, $4 	# [1]
        bis	$3, $4, $3 	# [2]
        stl	$3, PROCESSORSTATE_INTERRUPTREG($14)	#  [1-]
        beq	$3, G14297	# [1]
        stq	$3, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
.align 3
G14297:
.align 3
CATCHCLOSELD:
/* TagType. */
        and	$20, 63, $1 	# [1-]
        stl	$1, PROCESSORSTATE_CATCHBLOCK+4($14)	# tag [0di]
        and	$20, 128, $2 	# extra argument bit [1-]
        ldq	$6, PROCESSORSTATE_EXTRAANDCATCH($14)	# mask for two bits [0di]
        sll	$2, 1, $2 	# position in place for control register. [1-]
        stl	$21, PROCESSORSTATE_CATCHBLOCK($14)	# data [0di]
        and	$20, 64, $3 	# cleanup catch bit [1-]
        sll	$3, 20, $3 	# position in place for cr [1]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
        bis	$2, $3, $5 	# coalesce the two bits [1di]
        bic	$4, $6, $4 	# Turn off extra-arg and cleanup-catch [2]
        bis	$4, $5, $4 	# Maybe turn them back on [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
        and	$18, 64, $6 	# uwp bit [0di]
        beq	$6, NEXTINSTRUCTION	# [1]
/* Handle unwind-protect cleanup here */
        ldl	$17, 0($23)	# pctag pcdata [0di]
        ldl	$16, 4($23)	#  [1]
        extll	$17, 0, $17 	# [2di]
        srl	$4, 17, $8 	# Cleanup in progress bit into cdr code pos [1]
        addq	$9, 1, $7 	# Next PC [1]
/* Convert PC to a real continuation. */
        and	$7, 1, $8 	# [1]
        srl	$7, 1, $23 	# convert PC to a real word address. [1]
        lda	$8, TypeEvenPC($8)	#  [1]
/* TagType. */
        and	$8, 63, $7 	# [1]
        and	$8, 64, $8 	# [1]
        ldah	$22, 128	#  [1]
        bis	$8, 128, $8 	# [1]
        bis	$7, $8, $7 	# [1]
        stl	$23, 8($12)	#  [1-]
        stl	$7, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        bis	$4, $22, $4 	# set cr.cleanup-in-progress [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
/* Convert real continuation to PC. */
        and	$16, 1, $9 	# [0di]
        addq	$17, $9, $9 	# [1]
        addq	$17, $9, $9 	# [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [1-]
.align 3
CATCHCLOSEDBT:
	br	$31, DBUNWINDCATCHTRAP
.align 3
G14295:
        ldq	$16, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$17, $16, $16 	# reconstruct SCA [3]
        stl	$6, 0($16)	# Store in stack [2]
        stl	$8, 4($16)	# write the stack cache [1]
        br	$31, G14294	# [1]
.align 3
G14286:
        ldq	$17, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$16, $17, $16 	# reconstruct SCA [3]
        ldl	$22, 0($16)	#  [2]
        ldl	$8, 4($16)	# Read from stack cache [1]
        br	$31, G14285	# [1]
.align 3
G14288:
        blbc	$24, G14287	# [1]
        extll	$22, 0, $2 	# Do the indirect thing [0di]
        br	$31, G14284	# [1-]
.align 3
G14287:
        ldq	$16, PROCESSORSTATE_BINDWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$8, 63, $24 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$24, $16, $24 	# Adjust for a longword load [2di]
        ldl	$16, 0($24)	# Get the memory action [2]
G14290:
/* Perform memory action */
        bis	$31, $16, $16 	# [3]
        bis	$31, 3, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14276:
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $22, $8 	# reconstruct SCA [3]
        ldl	$2, 0($8)	#  [2]
        ldl	$3, 4($8)	# Read from stack cache [1]
        br	$31, G14275	# [1]
.align 3
G14278:
        blbc	$16, G14277	# [1]
        extll	$2, 0, $5 	# Do the indirect thing [0di]
        br	$31, G14274	# [1-]
.align 3
G14277:
        ldq	$17, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$3, 63, $16 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$16, $17, $16 	# Adjust for a longword load [2di]
        ldl	$17, 0($16)	# Get the memory action [2]
G14280:
/* Perform memory action */
        bis	$31, $17, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14266:
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $22, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G14265	# [1]
.align 3
G14268:
        blbc	$16, G14267	# [1]
        extll	$6, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14264	# [1-]
.align 3
G14267:
        ldq	$17, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $16 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$16, $17, $16 	# Adjust for a longword load [2di]
        ldl	$17, 0($16)	# Get the memory action [2]
G14270:
/* Perform memory action */
        bis	$31, $17, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
#ifdef TRACING
	.byte 0x82
	.asciiz "DoCatchCloseIM"
#endif
DoCatchCloseIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoCatchClose.
.end DoCatchClose
/* End of Halfword operand from stack instruction - DoCatchClose */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunfcal.as */
