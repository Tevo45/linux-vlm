/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunarra.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Array operations. */
.align 5
.globl Aref1Regset
.ent Aref1Regset 0
.align 3
Aref1Regset:
        bis	$19, $31, $25 	# [1]
/* Memory Read Internal */
G14810:
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$19, $14, $3 	# [1-]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$3, $31, $21 	# [1-]
        ldq_u	$20, 0($3)	#  [1di]
        subq	$19, $1, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$1, $2, $2 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $3, $20 	# [1-]
        bne	$2, G14812	# [0di]
G14811:
        lda	$3, 64	#  [1-]
        srl	$4, $20, $4 	# [1]
        srl	$3, $20, $3 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$4, G14814	# [1-]
G14819:
/* TagType. */
        and	$20, 63, $1 	# [0di]
        srl	$21, ArrayLongPrefixBitPos, $2 	# [1]
        subq	$1, TypeHeaderI, $1 	# [1]
        bne	$1, AREF1ILLEGAL	# [1]
        blbs	$2, Aref1Exception	# [1]
        stl	$25, ARRAYCACHE_ARRAY($7)	# store the array [1]
        lda	$2, ArrayLengthMask	#  [0di]
        and	$21, $2, $1 	# [1]
        cmpult	$17, $1, $2 	# [1]
        beq	$2, AREF1BOUNDS	# [1]
        stq	$1, ARRAYCACHE_LENGTH($7)	# store the array length [implicit fixnum] [1]
        srl	$21, ArrayRegisterBytePackingPos, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_AREVENTCOUNT($14)	#  [0di]
        sll	$23, ArrayRegisterBytePackingPos, $23 	# [2-]
        addq	$19, 1, $22 	# [1]
        addq	$23, $8, $23 	# Construct the array register word [1]
        stl	$23, ARRAYCACHE_ARWORD($7)	# store the array register word [implicit fixnum] [0di]
        stq	$22, ARRAYCACHE_LOCAT($7)	# store the storage [implicit locative] [1]
        srl	$21, ArrayBytePackingPos, $20 	# get BP into arg5 [0di]
        srl	$21, ArrayElementTypePos, $21 	# get element type into arg6 [1]
        and	$20, ArrayBytePackingMask, $20 	# [1]
        bis	$31, $31, $19 	# [1]
        and	$21, ArrayElementTypeMask, $21 	# [1]
        br	$31, AREF1RESTART	# [1-]
.align 3
G14812:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$21, 0($1)	#  [2]
        ldl	$20, 4($1)	# Read from stack cache [1]
        br	$31, G14811	# [1]
.align 3
G14814:
        blbc	$3, G14813	# [1]
        extll	$21, 0, $19 	# Do the indirect thing [0di]
        br	$31, G14810	# [1-]
.align 3
G14813:
        ldq	$4, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $3 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
G14816:
/* Perform memory action */
        bis	$31, $4, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end Aref1Regset
.align 5
.globl Aref1RecomputeArrayRegister
.ent Aref1RecomputeArrayRegister 0
.align 3
Aref1RecomputeArrayRegister:
        ldl	$5, -8($16)	#  [1-]
        ldl	$4, -4($16)	#  [1]
        extll	$5, 0, $5 	# [2-]
        subq	$4, TypeArray, $6 	# [1]
        and	$6, 62, $6 	# Strip CDR code, low bits [1]
        bne	$6, G14821	# [1]
/* Memory Read Internal */
G14823:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$5, $14, $3 	# [0di]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$3, $31, $6 	# [0di]
        ldq_u	$7, 0($3)	#  [1-]
        subq	$5, $8, $8 	# Stack cache offset [1di]
        ldq	$1, PROCESSORSTATE_HEADER_MASK($14)	#  [1-]
        cmpult	$8, $2, $2 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $3, $7 	# [0di]
        bne	$2, G14825	# [1-]
G14824:
        lda	$3, 64	#  [0di]
        srl	$1, $7, $1 	# [1]
        srl	$3, $7, $3 	# [1]
        extll	$6, 0, $6 	# [1]
        blbs	$1, G14827	# [0di]
G14832:
/* TagType. */
        and	$7, 63, $8 	# [1-]
        srl	$6, ArrayLongPrefixBitPos, $2 	# [1]
        subq	$8, TypeHeaderI, $8 	# [1]
        bne	$8, G14820	# [1]
        blbs	$2, G14822	# [1]
        srl	$6, ArrayBytePackingPos, $1 	# [0di]
        ldq	$4, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        sll	$1, ArrayRegisterBytePackingPos, $1 	# [1di]
        addq	$5, 1, $2 	# [1]
        addq	$1, $4, $1 	# Construct the array register word [1]
        stl	$2, 8($16)	#  [1-]
        lda	$3, ArrayLengthMask	#  [0di]
        and	$6, $3, $3 	# [1]
        stl	$1, 0($16)	#  [0di]
        stl	$3, 16($16)	#  [1]
        br	$31, FASTAREF1RETRY	# [1]
.align 3
G14822:
        stq	$16, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [1]
        stq	$23, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [1]
        stq	$24, PROCESSORSTATE_ASRF3($14)	# Just a place to save these values [1]
        stq	$16, PROCESSORSTATE_ASRF6($14)	# Just a place to save these values [1]
        stq	$17, PROCESSORSTATE_ASRF7($14)	# Just a place to save these values [1]
        stq	$18, PROCESSORSTATE_ASRF8($14)	# Just a place to save these values [1]
        stq	$19, PROCESSORSTATE_ASRF9($14)	# Just a place to save these values [1]
        ldl	$22, -8($16)	#  [1]
        ldl	$17, -4($16)	#  [1]
        extll	$22, 0, $22 	# [2di]
        bis	$5, $31, $16 	# [1]
        bis	$7, $31, $4 	# [1]
        bis	$6, $31, $3 	# [1]
        bis	$31, 1, $2 	# [1]
        addq	$12, 24, $12 	# [1]
	bsr	$0, Setup1DLongArray
        cmpeq	$2, ReturnValueException, $4 	# [1]
        bne	$4, G14821	# [1]
        ldq	$16, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [0di]
        ldq	$23, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [1]
        ldq	$24, PROCESSORSTATE_ASRF3($14)	# Just a place to save these values [1]
        ldq	$16, PROCESSORSTATE_ASRF6($14)	# Just a place to save these values [1]
        ldq	$17, PROCESSORSTATE_ASRF7($14)	# Just a place to save these values [1]
        ldq	$18, PROCESSORSTATE_ASRF8($14)	# Just a place to save these values [1]
        ldq	$19, PROCESSORSTATE_ASRF9($14)	# Just a place to save these values [1]
        ldq	$3, 0($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$2, 0($12)	#  [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$1, 0($12)	#  [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$4, 0($12)	#  [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        subq	$12, 24, $12 	# [1]
        stl	$1, 0($16)	#  [0di]
        stl	$2, 8($16)	#  [1]
        stl	$3, 16($16)	#  [1]
        br	$31, FASTAREF1RETRY	# [1]
.align 3
G14821:
        bis	$31, $4, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 12, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
G14820:
        bis	$31, 0, $20 	# [1]
        bis	$31, 12, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14825:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $2, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G14824	# [1]
.align 3
G14827:
        blbc	$3, G14826	# [1]
        extll	$6, 0, $5 	# Do the indirect thing [0di]
        br	$31, G14823	# [1-]
.align 3
G14826:
        ldq	$1, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $3 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $1, $3 	# Adjust for a longword load [2di]
        ldl	$1, 0($3)	# Get the memory action [2]
G14829:
/* Perform memory action */
        bis	$31, $1, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end Aref1RecomputeArrayRegister
.align 5
.globl Aref1Exception
.ent Aref1Exception 0
.align 3
Aref1Exception:
        stq	$17, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [1-]
        stq	$7, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [1]
        bis	$25, $31, $22 	# [1-]
        bis	$18, $31, $17 	# [1]
        bis	$19, $31, $16 	# [1]
        bis	$20, $31, $4 	# [1]
        bis	$21, $31, $3 	# [1]
        bis	$31, $31, $2 	# [1]
        addq	$12, 24, $12 	# [1]
	bsr	$0, Setup1DLongArray
        ldl	$17, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [0di]
        ldq	$7, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [1]
        ldl	$1, 0($12)	# Length [1]
        ldl	$5, 4($12)	# Length [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
        ldq	$5, 0($12)	# base [1di]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$3, 0($12)	# control [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldl	$22, 0($12)	# The original array [2]
        ldl	$18, 4($12)	# The original array [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$22, 0, $22 	# [1]
        subq	$12, 24, $12 	# [1]
        stq	$1, ARRAYCACHE_LENGTH($7)	#  [1-]
        stl	$3, ARRAYCACHE_ARWORD($7)	#  [1]
        stl	$5, ARRAYCACHE_LOCAT($7)	#  [1]
        stl	$22, ARRAYCACHE_ARRAY($7)	# store the array [1]
        extll	$5, 0, $22 	# [1]
        cmpeq	$2, ReturnValueException, $2 	# [1]
        bne	$2, REALLYAREF1EXC	# [1]
        cmpult	$17, $1, $5 	# [0di]
        beq	$5, AREF1BOUNDS	# [1]
        srl	$3, ArrayBytePackingPos, $20 	# get BP into arg5 [0di]
        srl	$3, ArrayElementTypePos, $21 	# get element type into arg6 [1]
        srl	$3, ArrayRegisterByteOffsetPos, $19 	# [1]
        and	$20, ArrayBytePackingMask, $20 	# [1]
        and	$19, ArrayRegisterByteOffsetMask, $19 	# [1]
        and	$21, ArrayElementTypeMask, $21 	# [1]
        br	$31, AREF1RESTART	# [0di]
.align 3
REALLYAREF1EXC:
        bis	$31, TypeFixnum, $16 	# [1-]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 8, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
AREF1ILLEGAL:
        bis	$31, 0, $20 	# [1]
        bis	$31, 8, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
AREF1BOUNDS:
        stq	$31, ARRAYCACHE_ARRAY($7)	#  [1-]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 74, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end Aref1Exception
.align 5
.globl Aset1Regset
.ent Aset1Regset 0
.align 3
Aset1Regset:
        bis	$19, $31, $25 	# [1]
/* Memory Read Internal */
G14833:
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$19, $14, $3 	# [1-]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$3, $31, $21 	# [1-]
        ldq_u	$20, 0($3)	#  [1di]
        subq	$19, $1, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$1, $2, $2 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $3, $20 	# [1-]
        bne	$2, G14835	# [0di]
G14834:
        lda	$3, 64	#  [1-]
        srl	$4, $20, $4 	# [1]
        srl	$3, $20, $3 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$4, G14837	# [1-]
G14842:
/* TagType. */
        and	$20, 63, $1 	# [0di]
        srl	$21, ArrayLongPrefixBitPos, $2 	# [1]
        subq	$1, TypeHeaderI, $1 	# [1]
        bne	$1, ASET1ILLEGAL	# [1]
        blbs	$2, Aset1Exception	# [1]
        stl	$25, ARRAYCACHE_ARRAY($7)	# store the array [1]
        lda	$2, ArrayLengthMask	#  [0di]
        and	$21, $2, $1 	# [1]
        cmpult	$17, $1, $2 	# [1]
        beq	$2, ASET1BOUNDS	# [1]
        stq	$1, ARRAYCACHE_LENGTH($7)	# store the array length [implicit fixnum] [1]
        srl	$21, ArrayRegisterBytePackingPos, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_AREVENTCOUNT($14)	#  [0di]
        sll	$23, ArrayRegisterBytePackingPos, $23 	# [2-]
        addq	$19, 1, $22 	# [1]
        addq	$23, $8, $23 	# Construct the array register word [1]
        stl	$23, ARRAYCACHE_ARWORD($7)	# store the array register word [implicit fixnum] [0di]
        stq	$22, ARRAYCACHE_LOCAT($7)	# store the storage [implicit locative] [1]
        srl	$21, ArrayBytePackingPos, $20 	# get BP into arg5 [0di]
        srl	$21, ArrayElementTypePos, $21 	# get element type into arg6 [1]
        and	$20, ArrayBytePackingMask, $20 	# [1]
        bis	$31, $31, $19 	# [1]
        and	$21, ArrayElementTypeMask, $21 	# [1]
        br	$31, ASET1RESTART	# [1-]
.align 3
G14835:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$21, 0($1)	#  [2]
        ldl	$20, 4($1)	# Read from stack cache [1]
        br	$31, G14834	# [1]
.align 3
G14837:
        blbc	$3, G14836	# [1]
        extll	$21, 0, $19 	# Do the indirect thing [0di]
        br	$31, G14833	# [1-]
.align 3
G14836:
        ldq	$4, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $3 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
G14839:
/* Perform memory action */
        bis	$31, $4, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end Aset1Regset
.align 5
.globl Aset1RecomputeArrayRegister
.ent Aset1RecomputeArrayRegister 0
.align 3
Aset1RecomputeArrayRegister:
        ldl	$5, -8($16)	#  [1-]
        ldl	$4, -4($16)	#  [1]
        extll	$5, 0, $5 	# [2-]
        subq	$4, TypeArray, $6 	# [1]
        and	$6, 62, $6 	# Strip CDR code, low bits [1]
        bne	$6, G14844	# [1]
/* Memory Read Internal */
G14846:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$5, $14, $3 	# [0di]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$3, $31, $6 	# [0di]
        ldq_u	$7, 0($3)	#  [1-]
        subq	$5, $8, $8 	# Stack cache offset [1di]
        ldq	$1, PROCESSORSTATE_HEADER_MASK($14)	#  [1-]
        cmpult	$8, $2, $2 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $3, $7 	# [0di]
        bne	$2, G14848	# [1-]
G14847:
        lda	$3, 64	#  [0di]
        srl	$1, $7, $1 	# [1]
        srl	$3, $7, $3 	# [1]
        extll	$6, 0, $6 	# [1]
        blbs	$1, G14850	# [0di]
G14855:
/* TagType. */
        and	$7, 63, $8 	# [1-]
        srl	$6, ArrayLongPrefixBitPos, $2 	# [1]
        subq	$8, TypeHeaderI, $8 	# [1]
        bne	$8, G14843	# [1]
        blbs	$2, G14845	# [1]
        srl	$6, ArrayBytePackingPos, $1 	# [0di]
        ldq	$4, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        sll	$1, ArrayRegisterBytePackingPos, $1 	# [1di]
        addq	$5, 1, $2 	# [1]
        addq	$1, $4, $1 	# Construct the array register word [1]
        stl	$2, 8($16)	#  [1-]
        lda	$3, ArrayLengthMask	#  [0di]
        and	$6, $3, $3 	# [1]
        stl	$1, 0($16)	#  [0di]
        stl	$3, 16($16)	#  [1]
        br	$31, FASTASET1RETRY	# [1]
.align 3
G14845:
        stq	$16, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [1]
        stq	$23, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [1]
        stq	$24, PROCESSORSTATE_ASRF3($14)	# Just a place to save these values [1]
        stq	$16, PROCESSORSTATE_ASRF6($14)	# Just a place to save these values [1]
        stq	$17, PROCESSORSTATE_ASRF7($14)	# Just a place to save these values [1]
        stq	$18, PROCESSORSTATE_ASRF8($14)	# Just a place to save these values [1]
        stq	$19, PROCESSORSTATE_ASRF9($14)	# Just a place to save these values [1]
        ldl	$22, -8($16)	#  [1]
        ldl	$17, -4($16)	#  [1]
        extll	$22, 0, $22 	# [2di]
        bis	$5, $31, $16 	# [1]
        bis	$7, $31, $4 	# [1]
        bis	$6, $31, $3 	# [1]
        bis	$31, 1, $2 	# [1]
        addq	$12, 24, $12 	# [1]
	bsr	$0, Setup1DLongArray
        cmpeq	$2, ReturnValueException, $4 	# [1]
        bne	$4, G14844	# [1]
        ldq	$16, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [0di]
        ldq	$23, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [1]
        ldq	$24, PROCESSORSTATE_ASRF3($14)	# Just a place to save these values [1]
        ldq	$16, PROCESSORSTATE_ASRF6($14)	# Just a place to save these values [1]
        ldq	$17, PROCESSORSTATE_ASRF7($14)	# Just a place to save these values [1]
        ldq	$18, PROCESSORSTATE_ASRF8($14)	# Just a place to save these values [1]
        ldq	$19, PROCESSORSTATE_ASRF9($14)	# Just a place to save these values [1]
        ldq	$3, 0($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$2, 0($12)	#  [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$1, 0($12)	#  [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$4, 0($12)	#  [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        subq	$12, 24, $12 	# [1]
        stl	$1, 0($16)	#  [0di]
        stl	$2, 8($16)	#  [1]
        stl	$3, 16($16)	#  [1]
        br	$31, FASTASET1RETRY	# [1]
.align 3
G14844:
        bis	$31, $4, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 3, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 12, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
G14843:
        bis	$31, 0, $20 	# [1]
        bis	$31, 12, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14848:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $2, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G14847	# [1]
.align 3
G14850:
        blbc	$3, G14849	# [1]
        extll	$6, 0, $5 	# Do the indirect thing [0di]
        br	$31, G14846	# [1-]
.align 3
G14849:
        ldq	$1, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $3 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $1, $3 	# Adjust for a longword load [2di]
        ldl	$1, 0($3)	# Get the memory action [2]
G14852:
/* Perform memory action */
        bis	$31, $1, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end Aset1RecomputeArrayRegister
.align 5
.globl Aset1Exception
.ent Aset1Exception 0
.align 3
Aset1Exception:
        stq	$17, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [1-]
        stq	$5, PROCESSORSTATE_ASRF3($14)	# Just a place to save these values [1]
        stq	$6, PROCESSORSTATE_ASRF6($14)	# Just a place to save these values [1]
        stq	$7, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [1]
        bis	$25, $31, $22 	# [1-]
        bis	$18, $31, $17 	# [1]
        bis	$19, $31, $16 	# [1]
        bis	$20, $31, $4 	# [1]
        bis	$21, $31, $3 	# [1]
        bis	$31, $31, $2 	# [1]
        addq	$12, 24, $12 	# [1]
	bsr	$0, Setup1DLongArray
        cmpeq	$2, ReturnValueException, $1 	# [1]
        bne	$1, REALLYASET1EXC	# [1]
        ldl	$17, PROCESSORSTATE_ASRF4($14)	# Just a place to save these values [0di]
        ldq	$5, PROCESSORSTATE_ASRF3($14)	# Just a place to save these values [1]
        ldq	$6, PROCESSORSTATE_ASRF6($14)	# Just a place to save these values [1]
        ldq	$7, PROCESSORSTATE_ASRF5($14)	# Just a place to save these values [1]
        ldl	$1, 0($12)	# Length [1]
        ldl	$2, 4($12)	# Length [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
        ldq	$2, 0($12)	# base [1di]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldq	$3, 0($12)	# control [2]
        subq	$12, 8, $12 	# Pop Stack. [1]
        ldl	$22, 0($12)	# The original array [2]
        ldl	$18, 4($12)	# The original array [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$22, 0, $22 	# [1]
        subq	$12, 24, $12 	# [1]
        stq	$1, ARRAYCACHE_LENGTH($7)	#  [1-]
        stl	$3, ARRAYCACHE_ARWORD($7)	#  [1]
        stl	$2, ARRAYCACHE_LOCAT($7)	#  [1]
        stl	$22, ARRAYCACHE_ARRAY($7)	# store the array [1]
        extll	$2, 0, $22 	# [1]
        cmpult	$17, $1, $2 	# [1]
        beq	$2, ASET1BOUNDS	# [1]
        srl	$3, ArrayBytePackingPos, $20 	# get BP into arg5 [0di]
        srl	$3, ArrayElementTypePos, $21 	# get element type into arg6 [1]
        srl	$3, ArrayRegisterByteOffsetPos, $19 	# [1]
        and	$20, ArrayBytePackingMask, $20 	# [1]
        and	$19, ArrayRegisterByteOffsetMask, $19 	# [1]
        and	$21, ArrayElementTypeMask, $21 	# [1]
        br	$31, ASET1RESTART	# [0di]
.align 3
REALLYASET1EXC:
        bis	$31, TypeFixnum, $16 	# [1-]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 3, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 9, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
ASET1ILLEGAL:
        bis	$31, 0, $20 	# [1]
        bis	$31, 9, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
ASET1BOUNDS:
        stq	$31, ARRAYCACHE_ARRAY($7)	#  [1-]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 74, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end Aset1Exception
.align 5
.globl DoAloc1
.ent DoAloc1 0
/* Halfword operand from stack instruction - DoAloc1 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAloc1FP
	.globl DoAloc1SP
	.globl DoAloc1LP
	.globl DoAloc1IM
.align 3
DoAloc1:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAloc1SP"
#endif
.align 3
DoAloc1SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAloc1	# [0di]
	.byte 0x90
	.asciiz "DoAloc1LP"
#endif
.align 3
DoAloc1LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAloc1	# [1]
	.byte 0x84
	.asciiz "DoAloc1FP"
#endif
.align 3
DoAloc1FP:	# Entry point for FP relative
.align 3
headDoAloc1:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAloc1:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	# Get the array tag/data [1]
        ldl	$18, 4($12)	# Get the array tag/data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        extll	$16, 0, $17 	# Index Data [1]
        srl	$16, 32, $16 	# Index Tag [1]
        subq	$16, TypeFixnum, $1 	# [2]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, ALOC1ILLEGAL	# [1]
.align 3
ALOC1MERGE:
        subq	$18, TypeArray, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, ALOC1EXCEPTION	# [1]
/* Memory Read Internal */
G14856:
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1]
        addq	$19, $14, $3 	# [1-]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$3, $31, $21 	# [1-]
        ldq_u	$20, 0($3)	#  [1di]
        subq	$19, $1, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$1, $2, $2 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $3, $20 	# [1-]
        bne	$2, G14858	# [0di]
G14857:
        lda	$3, 64	#  [1-]
        srl	$4, $20, $4 	# [1]
        srl	$3, $20, $3 	# [1]
        blbs	$4, G14860	# [1di]
G14865:
/* TagType. */
        and	$20, 63, $1 	# [1-]
        srl	$21, ArrayLongPrefixBitPos, $2 	# [1]
        subq	$1, TypeHeaderI, $1 	# [1]
        bne	$1, ALOC1ILLEGAL	# [1]
        blbs	$2, ALOC1EXCEPTION	# [1]
        lda	$2, ArrayLengthMask	#  [1]
        and	$21, $2, $1 	# [1]
        cmpult	$17, $1, $3 	# [1]
        beq	$3, ALOC1ILLEGAL	# [1]
        srl	$21, ArrayElementTypePos, $21 	# get element type into arg6 [0di]
        addq	$19, 1, $19 	# [1]
        addq	$19, $17, $19 	# [1]
        and	$21, ArrayElementTypeMask, $21 	# [1]
        subq	$21, ArrayElementTypeObject, $21 	# [1]
        bne	$21, ALOC1NOTOBJECT	# [1]
        bis	$31, TypeLocative, $1 	# [0di]
        stl	$19, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
ALOC1EXCEPTION:
        bis	$31, TypeFixnum, $16 	# [1-]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 8, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
ALOC1ILLEGAL:
        bis	$31, 0, $20 	# [1]
        bis	$31, 8, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
ALOC1BOUNDS:
        bis	$31, 0, $20 	# [1]
        bis	$31, 74, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
ALOC1NOTOBJECT:
        bis	$31, 0, $20 	# [1]
        bis	$31, 7, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
        br	$31, DoAloc1IM	# [1-]
	.byte 0x82
	.asciiz "DoAloc1IM"
#endif
.align 5
.align 3
DoAloc1IM:	# Entry point for IMMEDIATE mode
        ldl	$19, 0($12)	# Get the array tag/data [1]
        ldl	$18, 4($12)	# Get the array tag/data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        br	$31, ALOC1MERGE	# [1-]
.align 3
G14858:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$21, 0($1)	#  [2]
        ldl	$20, 4($1)	# Read from stack cache [1]
        br	$31, G14857	# [1]
.align 3
G14860:
        blbc	$3, G14859	# [1]
        extll	$21, 0, $19 	# Do the indirect thing [0di]
        br	$31, G14856	# [1-]
.align 3
G14859:
        ldq	$4, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $3 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
G14862:
/* Perform memory action */
        bis	$31, $4, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoAloc1
/* End of Halfword operand from stack instruction - DoAloc1 */
/* Array register operations. */
.align 5
.globl DoSetup1DArray
.ent DoSetup1DArray 0
/* Halfword operand from stack instruction - DoSetup1DArray */
	.globl DoSetup1DArrayFP
	.globl DoSetup1DArraySP
	.globl DoSetup1DArrayLP
	.globl DoSetup1DArrayIM
.align 3
DoSetup1DArray:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoSetup1DArrayIM"
#endif
.align 3
DoSetup1DArrayIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G14879:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoSetup1DArray	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetup1DArraySP"
#endif
.align 3
DoSetup1DArraySP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoSetup1DArray	# [0di]
	.byte 0x90
	.asciiz "DoSetup1DArrayLP"
#endif
.align 3
DoSetup1DArrayLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoSetup1DArray	# [1]
	.byte 0x84
	.asciiz "DoSetup1DArrayFP"
#endif
.align 3
DoSetup1DArrayFP:	# Entry point for FP relative
.align 3
headDoSetup1DArray:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoSetup1DArray:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $17 	# Get the tag [3]
        extll	$16, 0, $16 	# and the data [1]
        bis	$31, 0, $2 	# Indicate not forcing 1d [1]
        bis	$16, $31, $22 	# [1]
        subq	$17, TypeArray, $3 	# [1]
        and	$3, 62, $3 	# Strip CDR code, low bits [1]
        bne	$3, G14867	# [1]
/* Memory Read Internal */
G14869:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$16, $14, $7 	# [1-]
        ldl	$6, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$7, $31, $3 	# [1-]
        ldq_u	$4, 0($7)	#  [1di]
        subq	$16, $5, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $6, $6 	# In range? [1-]
        ldl	$3, 0($3)	#  [0di]
        extbl	$4, $7, $4 	# [1-]
        bne	$6, G14871	# [0di]
G14870:
        lda	$7, 64	#  [1-]
        srl	$8, $4, $8 	# [1]
        srl	$7, $4, $7 	# [1]
        extll	$3, 0, $3 	# [1]
        blbs	$8, G14873	# [1-]
G14878:
/* TagType. */
        and	$4, 63, $5 	# [0di]
        srl	$3, ArrayLongPrefixBitPos, $6 	# [1]
        subq	$5, TypeHeaderI, $5 	# [1]
        bne	$5, G14866	# [1]
        blbs	$6, G14868	# [1]
        and	$17, 63, $5 	# set CDR-NEXT [1-]
        stl	$22, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        srl	$3, ArrayRegisterBytePackingPos, $8 	# [1]
        bis	$31, TypeFixnum, $7 	# [1]
        ldq	$1, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        sll	$8, ArrayRegisterBytePackingPos, $8 	# [0di]
        addq	$16, 1, $5 	# [1]
        addq	$8, $1, $8 	# Construct the array register word [2]
        and	$7, 63, $6 	# set CDR-NEXT [1]
        stl	$8, 8($12)	#  [0di]
        stl	$6, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$31, TypeLocative, $8 	# [1]
        stl	$5, 8($12)	#  [1di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        lda	$6, ArrayLengthMask	#  [1]
        and	$3, $6, $6 	# [1]
        and	$7, 63, $8 	# set CDR-NEXT [1]
        stl	$6, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
G14867:
/* SetTag. */
        sll	$17, 32, $6 	# [1-]
        bis	$22, $6, $6 	# [2]
        bis	$31, $17, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 71, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
G14866:
        bis	$31, 0, $20 	# [1]
        bis	$31, 71, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14868:
	bsr	$0, Setup1DLongArray
        cmpeq	$2, ReturnValueNormal, $1 	# [1]
        bne	$1, NEXTINSTRUCTION	# [1]
        cmpeq	$2, ReturnValueException, $1 	# [1]
        bne	$1, G14867	# [1]
        cmpeq	$2, ReturnValueIllegalOperand, $1 	# [1]
        bne	$1, G14866	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14871:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$3, 0($5)	#  [2]
        ldl	$4, 4($5)	# Read from stack cache [1]
        br	$31, G14870	# [1]
.align 3
G14873:
        blbc	$7, G14872	# [1]
        extll	$3, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14869	# [1-]
.align 3
G14872:
        ldq	$8, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $7 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G14875:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoSetup1DArray
/* End of Halfword operand from stack instruction - DoSetup1DArray */
.align 5
.globl DoSetupForce1DArray
.ent DoSetupForce1DArray 0
/* Halfword operand from stack instruction - DoSetupForce1DArray */
	.globl DoSetupForce1DArrayFP
	.globl DoSetupForce1DArraySP
	.globl DoSetupForce1DArrayLP
	.globl DoSetupForce1DArrayIM
.align 3
DoSetupForce1DArray:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoSetupForce1DArrayIM"
#endif
.align 3
DoSetupForce1DArrayIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G14893:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoSetupForce1DArray	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetupForce1DArraySP"
#endif
.align 3
DoSetupForce1DArraySP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoSetupForce1DArray	# [0di]
	.byte 0x90
	.asciiz "DoSetupForce1DArrayLP"
#endif
.align 3
DoSetupForce1DArrayLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoSetupForce1DArray	# [1]
	.byte 0x84
	.asciiz "DoSetupForce1DArrayFP"
#endif
.align 3
DoSetupForce1DArrayFP:	# Entry point for FP relative
.align 3
headDoSetupForce1DArray:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoSetupForce1DArray:
/* arg1 has the operand, sign extended if immediate. */
        srl	$16, 32, $17 	# Get the tag [3]
        extll	$16, 0, $16 	# and the data [1]
        bis	$31, 1, $2 	# Indicate forcing 1d [1]
        bis	$16, $31, $22 	# [1]
        subq	$17, TypeArray, $3 	# [1]
        and	$3, 62, $3 	# Strip CDR code, low bits [1]
        bne	$3, G14881	# [1]
/* Memory Read Internal */
G14883:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$16, $14, $7 	# [1-]
        ldl	$6, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$7, $31, $3 	# [1-]
        ldq_u	$4, 0($7)	#  [1di]
        subq	$16, $5, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $6, $6 	# In range? [1-]
        ldl	$3, 0($3)	#  [0di]
        extbl	$4, $7, $4 	# [1-]
        bne	$6, G14885	# [0di]
G14884:
        lda	$7, 64	#  [1-]
        srl	$8, $4, $8 	# [1]
        srl	$7, $4, $7 	# [1]
        extll	$3, 0, $3 	# [1]
        blbs	$8, G14887	# [1-]
G14892:
/* TagType. */
        and	$4, 63, $5 	# [0di]
        srl	$3, ArrayLongPrefixBitPos, $6 	# [1]
        subq	$5, TypeHeaderI, $5 	# [1]
        bne	$5, G14880	# [1]
        blbs	$6, G14882	# [1]
        and	$17, 63, $5 	# set CDR-NEXT [1-]
        stl	$22, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        srl	$3, ArrayRegisterBytePackingPos, $8 	# [1]
        bis	$31, TypeFixnum, $7 	# [1]
        ldq	$1, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        sll	$8, ArrayRegisterBytePackingPos, $8 	# [0di]
        addq	$16, 1, $5 	# [1]
        addq	$8, $1, $8 	# Construct the array register word [2]
        and	$7, 63, $6 	# set CDR-NEXT [1]
        stl	$8, 8($12)	#  [0di]
        stl	$6, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$31, TypeLocative, $8 	# [1]
        stl	$5, 8($12)	#  [1di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        lda	$6, ArrayLengthMask	#  [1]
        and	$3, $6, $6 	# [1]
        and	$7, 63, $8 	# set CDR-NEXT [1]
        stl	$6, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
G14881:
/* SetTag. */
        sll	$17, 32, $6 	# [1-]
        bis	$22, $6, $6 	# [2]
        bis	$31, $17, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 71, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
G14880:
        bis	$31, 0, $20 	# [1]
        bis	$31, 71, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14882:
	bsr	$0, Setup1DLongArray
        cmpeq	$2, ReturnValueNormal, $1 	# [1]
        bne	$1, NEXTINSTRUCTION	# [1]
        cmpeq	$2, ReturnValueException, $1 	# [1]
        bne	$1, G14881	# [1]
        cmpeq	$2, ReturnValueIllegalOperand, $1 	# [1]
        bne	$1, G14880	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14885:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$3, 0($5)	#  [2]
        ldl	$4, 4($5)	# Read from stack cache [1]
        br	$31, G14884	# [1]
.align 3
G14887:
        blbc	$7, G14886	# [1]
        extll	$3, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14883	# [1-]
.align 3
G14886:
        ldq	$8, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $7 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G14889:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoSetupForce1DArray
/* End of Halfword operand from stack instruction - DoSetupForce1DArray */
.align 5
.globl Setup1DLongArray
.ent Setup1DLongArray 2
.align 3
Setup1DLongArray:
/* Read data from the header: alength offset indirect lengths&mults */
        lda	$1, 1($16)	# length=array+1 [1]
/* Memory Read Internal */
G14903:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $23 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $19 	# [1-]
        ldq_u	$6, 0($23)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $8, $8 	# In range? [1-]
        ldl	$19, 0($19)	#  [0di]
        extbl	$6, $23, $6 	# [1-]
        bne	$8, G14905	# [0di]
G14904:
        lda	$23, 240	#  [1-]
        srl	$24, $6, $24 	# [1]
        srl	$23, $6, $23 	# [1]
        extll	$19, 0, $19 	# [1]
        blbs	$24, G14907	# [1-]
G14914:
        subq	$6, TypeFixnum, $8 	# [0di]
        and	$8, 63, $8 	# Strip CDR code [1]
        bne	$8, G14894	# [1]
        lda	$1, 1($1)	# Offset is adata+2 [1-]
/* Memory Read Internal */
G14915:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $23 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $18 	# [1-]
        ldq_u	$6, 0($23)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $8, $8 	# In range? [1-]
        ldl	$18, 0($18)	#  [0di]
        extbl	$6, $23, $6 	# [1-]
        bne	$8, G14917	# [0di]
G14916:
        lda	$23, 240	#  [1-]
        srl	$24, $6, $24 	# [1]
        srl	$23, $6, $23 	# [1]
        extll	$18, 0, $18 	# [1]
        blbs	$24, G14919	# [1-]
G14926:
        subq	$6, TypeFixnum, $8 	# [0di]
        and	$8, 63, $8 	# Strip CDR code [1]
        bne	$8, G14894	# [1]
        lda	$1, 1($1)	# Indirect is adata+3 [1-]
/* Memory Read Internal */
G14927:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $23 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $5 	# [1-]
        ldq_u	$6, 0($23)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $8, $8 	# In range? [1-]
        ldl	$5, 0($5)	#  [0di]
        extbl	$6, $23, $6 	# [1-]
        bne	$8, G14929	# [0di]
G14928:
        lda	$23, 240	#  [1-]
        srl	$24, $6, $24 	# [1]
        srl	$23, $6, $23 	# [1]
        extll	$5, 0, $5 	# [1]
        blbs	$24, G14931	# [1-]
G14938:
        and	$6, 63, $23 	# Strip off any CDR code bits. [0di]
        cmpeq	$23, TypeLocative, $24 	# [1]
.align 3
G15003:
        beq	$24, G14940	# [1]
/* Here if argument TypeLocative */
.align 3
G14897:
        and	$17, 63, $23 	# set CDR-NEXT [1-]
        stl	$22, 8($12)	#  [0di]
        stl	$23, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        srl	$3, ArrayBytePackingPos, $8 	# [1]
        bis	$31, TypeFixnum, $7 	# [1]
        ldq	$1, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        sll	$8, ArrayRegisterBytePackingPos, $8 	# [0di]
        addq	$8, $1, $8 	# Construct the array register word [3]
        and	$7, 63, $6 	# set CDR-NEXT [1]
        stl	$8, 8($12)	#  [1-]
        stl	$6, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        bis	$31, TypeLocative, $8 	# [1]
        stl	$5, 8($12)	#  [1-]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        and	$7, 63, $8 	# set CDR-NEXT [1]
        stl	$19, 8($12)	#  [1-]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, G14902	# [0di]
.align 3
G14940:
        cmpeq	$23, TypeFixnum, $24 	# [1-]
.align 3
G15004:
        beq	$24, G14941	# [1]
/* Here if argument TypeFixnum */
        br	$31, G14897	# [1]
.align 3
G14941:
        cmpeq	$23, TypeArray, $24 	# [1-]
.align 3
G15005:
        beq	$24, G14942	# [1]
/* Here if argument TypeArray */
.align 3
G14901:
        and	$3, 7, $1 	# [1-]
        cmpeq	$1, 1, $1 	# [1]
        bis	$1, $2, $1 	# Force true if FORCE [2]
        beq	$1, G14894	# [1]
        srl	$3, ArrayBytePackingPos, $25 	# [1-]
        and	$25, ArrayBytePackingMask, $25 	# [2]
        bis	$18, $31, $2 	# [1]
.align 3
G14896:
/* Memory Read Internal */
G14943:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$5, $14, $23 	# [0di]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$23, $31, $4 	# [0di]
        ldq_u	$6, 0($23)	#  [1-]
        subq	$5, $7, $7 	# Stack cache offset [1di]
        ldq	$24, PROCESSORSTATE_HEADER_MASK($14)	#  [1-]
        cmpult	$7, $8, $8 	# In range? [0di]
        ldl	$4, 0($4)	#  [1-]
        extbl	$6, $23, $6 	# [0di]
        bne	$8, G14945	# [1-]
G14944:
        lda	$23, 64	#  [0di]
        srl	$24, $6, $24 	# [1]
        srl	$23, $6, $23 	# [1]
        extll	$4, 0, $4 	# [1]
        blbs	$24, G14947	# [0di]
G14952:
        srl	$4, ArrayBytePackingPos, $23 	# [2-]
        and	$23, ArrayBytePackingMask, $23 	# [2]
        subq	$25, $23, $16 	# [1]
        srl	$4, ArrayLongPrefixBitPos, $7 	# [1]
        blbs	$7, G14898	# [2]
        addq	$5, 1, $5 	# increment beyond header [0di]
        lda	$8, 32767	#  [1]
        and	$4, $8, $8 	# [1]
        subq	$31, $16, $23 	# [1]
        srl	$8, $23, $23 	# [1]
        sll	$8, $16, $8 	# [1]
        cmovle	$16, $23, $8 	# [1]
        addq	$19, $18, $23 	# [1]
        subq	$23, $8, $7 	# [1]
        cmovle	$7, $23, $8 	# [1]
        bis	$8, $31, $19 	# [2]
.align 3
G14895:
        subq	$19, $2, $19 	# [1]
        and	$17, 63, $23 	# set CDR-NEXT [1]
        stl	$22, 8($12)	#  [1-]
        stl	$23, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        bis	$31, TypeFixnum, $7 	# [1]
        srl	$3, ArrayRegisterBytePackingPos, $8 	# [1]
        ldq	$1, PROCESSORSTATE_AREVENTCOUNT($14)	#  [0di]
        sll	$8, ArrayRegisterBytePackingPos, $8 	# [2-]
        subq	$31, 1, $24 	# -1 [1]
        sll	$24, $25, $24 	# (LSH -1 byte-packing) [1]
        bic	$2, $24, $24 	# [2]
        sll	$24, ArrayRegisterByteOffsetPos, $24 	# [1]
        addq	$8, $1, $8 	# Construct the array register word [1]
        addq	$24, $8, $8 	# Add in the byte offset [1]
        and	$7, 63, $6 	# set CDR-NEXT [1]
        stl	$8, 8($12)	#  [1-]
        stl	$6, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        cmovle	$19, $31, $19 	# [1]
        beq	$19, G14899	# [2]
        subq	$31, $25, $1 	# [0di]
        sll	$2, $1, $1 	# [1]
        srl	$2, $25, $2 	# [1]
        cmovle	$25, $1, $2 	# [1]
        addq	$2, $5, $5 	# [2]
.align 3
G14899:
        bis	$31, TypeLocative, $8 	# [1]
        stl	$5, 8($12)	#  [0di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        and	$7, 63, $8 	# set CDR-NEXT [1]
        stl	$19, 8($12)	#  [1di]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, G14902	# [1-]
.align 3
G14898:
        addq	$5, 1, $1 	# length=array+1 [1-]
/* Memory Read Internal */
G14953:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $23 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $21 	# [1-]
        ldq_u	$4, 0($23)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $8, $8 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$4, $23, $4 	# [1-]
        bne	$8, G14955	# [0di]
G14954:
        lda	$23, 240	#  [1-]
        srl	$24, $4, $24 	# [1]
        srl	$23, $4, $23 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$24, G14957	# [1-]
G14964:
        subq	$4, TypeFixnum, $1 	# [0di]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, G14894	# [1]
        addq	$5, 2, $1 	# offset=array+2 [1]
/* Memory Read Internal */
G14965:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $23 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $20 	# [1-]
        ldq_u	$4, 0($23)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $8, $8 	# In range? [1-]
        ldl	$20, 0($20)	#  [0di]
        extbl	$4, $23, $4 	# [1-]
        bne	$8, G14967	# [0di]
G14966:
        lda	$23, 240	#  [1-]
        srl	$24, $4, $24 	# [1]
        srl	$23, $4, $23 	# [1]
        extll	$20, 0, $20 	# [1]
        blbs	$24, G14969	# [1-]
G14976:
        subq	$4, TypeFixnum, $1 	# [0di]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, G14894	# [1]
        addq	$5, 3, $1 	# next=array+3 [1]
/* Memory Read Internal */
G14977:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $23 	# [1-]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $5 	# [1-]
        ldq_u	$4, 0($23)	#  [1di]
        subq	$1, $7, $7 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $8, $8 	# In range? [1-]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $23, $4 	# [1-]
        bne	$8, G14979	# [0di]
G14978:
        lda	$23, 240	#  [1-]
        srl	$24, $4, $24 	# [1]
        srl	$23, $4, $23 	# [1]
        extll	$5, 0, $5 	# [1]
        blbs	$24, G14981	# [1-]
G14988:
        subq	$31, $16, $8 	# [0di]
        srl	$21, $8, $8 	# [1]
        sll	$21, $16, $23 	# [1]
        cmovle	$16, $8, $23 	# [1]
        addq	$19, $18, $8 	# [1]
        cmovle	$23, $8, $23 	# [1]
        subq	$23, $8, $7 	# [2]
        cmovle	$7, $23, $8 	# [1]
        bis	$8, $31, $19 	# [2]
        and	$4, 63, $8 	# Strip off any CDR code bits. [1]
        cmpeq	$8, TypeLocative, $23 	# [1]
.align 3
G14996:
        beq	$23, G14990	# [1]
/* Here if argument TypeLocative */
        br	$31, G14895	# [1]
.align 3
G14990:
        cmpeq	$8, TypeFixnum, $23 	# [1-]
.align 3
G14997:
        beq	$23, G14991	# [1]
/* Here if argument TypeFixnum */
        br	$31, G14895	# [1]
.align 3
G14991:
        cmpeq	$8, TypeArray, $23 	# [1-]
.align 3
G14998:
        beq	$23, G14992	# [1]
/* Here if argument TypeArray */
.align 3
G14900:
        subq	$31, $16, $7 	# [1-]
        srl	$20, $7, $7 	# [1]
        sll	$20, $16, $18 	# [1]
        cmovle	$16, $7, $18 	# [1]
        addq	$2, $18, $2 	# [2]
        br	$31, G14896	# [0di]
.align 3
G14992:
        cmpeq	$8, TypeString, $23 	# [1-]
.align 3
G14999:
        beq	$23, G14993	# [1]
/* Here if argument TypeString */
        br	$31, G14900	# [1]
.align 3
G14993:
/* Here for all other cases */
        br	$31, G14894	# [1]
.align 3
G14989:
.align 3
G14942:
        cmpeq	$23, TypeString, $24 	# [1-]
.align 3
G15006:
        beq	$24, G15000	# [1]
/* Here if argument TypeString */
        br	$31, G14901	# [1]
.align 3
G15000:
/* Here for all other cases */
        br	$31, G14894	# [1]
.align 3
G14939:
.align 3
G14894:
        bis	$31, ReturnValueException, $2 	# [1-]
        ret	$31, ($0), 1	# [1]
.align 3
G14902:
        bis	$31, ReturnValueNormal, $2 	# [3]
        ret	$31, ($0), 1	# [1]
.align 3
G14979:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$5, 0($7)	#  [2]
        ldl	$4, 4($7)	# Read from stack cache [1]
        br	$31, G14978	# [1]
.align 3
G14981:
        blbc	$23, G14980	# [1]
        extll	$5, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14977	# [1-]
.align 3
G14980:
        ldq	$24, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
.align 3
G14985:
        and	$24, MemoryActionTransform, $23 	# [3]
        beq	$23, G14984	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G14988	# [1-]
#ifndef MINIMA
G14984:
#endif
#ifdef MINIMA
.align 3
G14984:
        and	$24, MemoryActionBinding, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$23, G14983	# [1-]
        sll	$1, 1, $7 	# [0di]
        ldq	$23, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $23, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$5, 4($8)	# Fetch value [1]
        subl	$1, $7, $23 	# Compare [2di]
        bne	$23, G14987	# Trap on miss [1]
        extll	$5, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14977	# This is another memory read tailcall. [1-]
.align 3
G14987:
	br	$31, DBCACHEMISSTRAP
#endif
G14983:
/* Perform memory action */
        bis	$31, $24, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14967:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$20, 0($7)	#  [2]
        ldl	$4, 4($7)	# Read from stack cache [1]
        br	$31, G14966	# [1]
.align 3
G14969:
        blbc	$23, G14968	# [1]
        extll	$20, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14965	# [1-]
.align 3
G14968:
        ldq	$24, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
.align 3
G14973:
        and	$24, MemoryActionTransform, $23 	# [3]
        beq	$23, G14972	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G14976	# [1-]
#ifndef MINIMA
G14972:
#endif
#ifdef MINIMA
.align 3
G14972:
        and	$24, MemoryActionBinding, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$23, G14971	# [1-]
        sll	$1, 1, $7 	# [0di]
        ldq	$23, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $23, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$20, 4($8)	# Fetch value [1]
        subl	$1, $7, $23 	# Compare [2di]
        bne	$23, G14975	# Trap on miss [1]
        extll	$20, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14965	# This is another memory read tailcall. [1-]
.align 3
G14975:
	br	$31, DBCACHEMISSTRAP
#endif
G14971:
/* Perform memory action */
        bis	$31, $24, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14955:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$21, 0($7)	#  [2]
        ldl	$4, 4($7)	# Read from stack cache [1]
        br	$31, G14954	# [1]
.align 3
G14957:
        blbc	$23, G14956	# [1]
        extll	$21, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14953	# [1-]
.align 3
G14956:
        ldq	$24, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
.align 3
G14961:
        and	$24, MemoryActionTransform, $23 	# [3]
        beq	$23, G14960	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G14964	# [1-]
#ifndef MINIMA
G14960:
#endif
#ifdef MINIMA
.align 3
G14960:
        and	$24, MemoryActionBinding, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$23, G14959	# [1-]
        sll	$1, 1, $7 	# [0di]
        ldq	$23, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $23, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$21, 4($8)	# Fetch value [1]
        subl	$1, $7, $23 	# Compare [2di]
        bne	$23, G14963	# Trap on miss [1]
        extll	$21, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14953	# This is another memory read tailcall. [1-]
.align 3
G14963:
	br	$31, DBCACHEMISSTRAP
#endif
G14959:
/* Perform memory action */
        bis	$31, $24, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14945:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$4, 0($7)	#  [2]
        ldl	$6, 4($7)	# Read from stack cache [1]
        br	$31, G14944	# [1]
.align 3
G14947:
        blbc	$23, G14946	# [1]
        extll	$4, 0, $5 	# Do the indirect thing [0di]
        br	$31, G14943	# [1-]
.align 3
G14946:
        ldq	$24, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$6, 63, $23 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
G14949:
/* Perform memory action */
        bis	$31, $24, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14929:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$5, 0($7)	#  [2]
        ldl	$6, 4($7)	# Read from stack cache [1]
        br	$31, G14928	# [1]
.align 3
G14931:
        blbc	$23, G14930	# [1]
        extll	$5, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14927	# [1-]
.align 3
G14930:
        ldq	$24, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$6, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
.align 3
G14935:
        and	$24, MemoryActionTransform, $23 	# [3]
        beq	$23, G14934	# [1]
        bic	$6, 63, $6 	# [1-]
        bis	$6, TypeExternalValueCellPointer, $6 	# [1]
        br	$31, G14938	# [1-]
#ifndef MINIMA
G14934:
#endif
#ifdef MINIMA
.align 3
G14934:
        and	$24, MemoryActionBinding, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$23, G14933	# [1-]
        sll	$1, 1, $7 	# [0di]
        ldq	$23, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $23, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$5, 4($8)	# Fetch value [1]
        subl	$1, $7, $23 	# Compare [2di]
        bne	$23, G14937	# Trap on miss [1]
        extll	$5, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14927	# This is another memory read tailcall. [1-]
.align 3
G14937:
	br	$31, DBCACHEMISSTRAP
#endif
G14933:
/* Perform memory action */
        bis	$31, $24, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14917:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$18, 0($7)	#  [2]
        ldl	$6, 4($7)	# Read from stack cache [1]
        br	$31, G14916	# [1]
.align 3
G14919:
        blbc	$23, G14918	# [1]
        extll	$18, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14915	# [1-]
.align 3
G14918:
        ldq	$24, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$6, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
.align 3
G14923:
        and	$24, MemoryActionTransform, $23 	# [3]
        beq	$23, G14922	# [1]
        bic	$6, 63, $6 	# [1-]
        bis	$6, TypeExternalValueCellPointer, $6 	# [1]
        br	$31, G14926	# [1-]
#ifndef MINIMA
G14922:
#endif
#ifdef MINIMA
.align 3
G14922:
        and	$24, MemoryActionBinding, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$23, G14921	# [1-]
        sll	$1, 1, $7 	# [0di]
        ldq	$23, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $23, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$18, 4($8)	# Fetch value [1]
        subl	$1, $7, $23 	# Compare [2di]
        bne	$23, G14925	# Trap on miss [1]
        extll	$18, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14915	# This is another memory read tailcall. [1-]
.align 3
G14925:
	br	$31, DBCACHEMISSTRAP
#endif
G14921:
/* Perform memory action */
        bis	$31, $24, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14905:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$19, 0($7)	#  [2]
        ldl	$6, 4($7)	# Read from stack cache [1]
        br	$31, G14904	# [1]
.align 3
G14907:
        blbc	$23, G14906	# [1]
        extll	$19, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14903	# [1-]
.align 3
G14906:
        ldq	$24, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$6, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
.align 3
G14911:
        and	$24, MemoryActionTransform, $23 	# [3]
        beq	$23, G14910	# [1]
        bic	$6, 63, $6 	# [1-]
        bis	$6, TypeExternalValueCellPointer, $6 	# [1]
        br	$31, G14914	# [1-]
#ifndef MINIMA
G14910:
#endif
#ifdef MINIMA
.align 3
G14910:
        and	$24, MemoryActionBinding, $23 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$23, G14909	# [1-]
        sll	$1, 1, $7 	# [0di]
        ldq	$23, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $23, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$19, 4($8)	# Fetch value [1]
        subl	$1, $7, $23 	# Compare [2di]
        bne	$23, G14913	# Trap on miss [1]
        extll	$19, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14903	# This is another memory read tailcall. [1-]
.align 3
G14913:
	br	$31, DBCACHEMISSTRAP
#endif
G14909:
/* Perform memory action */
        bis	$31, $24, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end Setup1DLongArray
.align 5
.globl DoFastAset1
.ent DoFastAset1 0
/* Halfword operand from stack instruction - DoFastAset1 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoFastAset1FP
	.globl DoFastAset1SP
	.globl DoFastAset1LP
	.globl DoFastAset1IM
.align 3
DoFastAset1:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoFastAset1SP"
#endif
.align 3
DoFastAset1SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoFastAset1	# [0di]
	.byte 0x90
	.asciiz "DoFastAset1LP"
#endif
.align 3
DoFastAset1LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoFastAset1	# [1]
	.byte 0x84
	.asciiz "DoFastAset1FP"
#endif
.align 3
DoFastAset1FP:	# Entry point for FP relative
.align 3
beginDoFastAset1:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$19, 0($12)	# Index [0di]
        ldl	$18, 4($12)	# Index [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        ldl	$24, 0($12)	# value [1di]
        ldl	$23, 4($12)	# value [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$24, 0, $24 	# [1]
        subq	$18, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, FASTASET1IOP	# [1]
.align 3
FASTASET1RETRY:
        ldl	$21, 0($16)	#  [1-]
        ldl	$22, 8($16)	#  [1]
        ldl	$3, 16($16)	#  [1]
        extll	$21, 0, $21 	# [1di]
        extll	$22, 0, $22 	# [1]
        sll	$21, 42, $5 	# [1]
        extll	$3, 0, $3 	# [1]
        ldq	$4, PROCESSORSTATE_AREVENTCOUNT($14)	#  [0di]
        srl	$5, 42, $5 	# [1-]
        cmpult	$19, $3, $2 	# [1]
        beq	$2, FASTASET1BOUNDS	# [1]
        subq	$4, $5, $6 	# [0di]
        bne	$6, Aset1RecomputeArrayRegister	# [1]
        srl	$21, ArrayRegisterBytePackingPos, $6 	# [1]
        srl	$21, ArrayRegisterByteOffsetPos, $7 	# [1]
        srl	$21, ArrayRegisterElementTypePos, $8 	# [1]
        and	$6, ArrayRegisterBytePackingMask, $6 	# [1]
        and	$7, ArrayRegisterByteOffsetMask, $7 	# [1]
        and	$8, ArrayRegisterElementTypeMask, $8 	# [1]
/* Element checking and foreplay. */
/* TagType. */
        and	$23, 63, $1 	# [1]
        cmpeq	$8, ArrayElementTypeCharacter, $25 	# [1]
.align 3
G15017:
        beq	$25, G15013	# [1]
/* Here if argument ArrayElementTypeCharacter */
        subq	$1, TypeCharacter, $2 	# [0di]
        beq	$2, G15008	# [1]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 29, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15008:
        beq	$6, G15007	# Certainly will fit if not packed! [1-]
        bis	$31, 32, $2 	# [0di]
        srl	$2, $6, $2 	# Compute size of byte [1]
        ornot	$31, $31, $1 	# [1]
        sll	$1, $2, $1 	# [1]
        ornot	$31, $1, $1 	# Compute mask for byte [2]
        and	$24, $1, $1 	# [1]
        subq	$24, $1, $1 	# [1]
        beq	$1, G15007	# J. if character fits. [1]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 62, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15013:
        cmpeq	$8, ArrayElementTypeFixnum, $25 	# [1]
.align 3
G15018:
        beq	$25, G15014	# [1]
/* Here if argument ArrayElementTypeFixnum */
        subq	$1, TypeFixnum, $2 	# [0di]
        beq	$2, G15007	# [1]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 33, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15014:
        cmpeq	$8, ArrayElementTypeBoolean, $25 	# [1]
.align 3
G15019:
        beq	$25, G15012	# [1]
/* Here if argument ArrayElementTypeBoolean */
        bis	$31, 1, $24 	# [0di]
        subq	$1, TypeNIL, $1 	# [1]
        bne	$1, G15007	# J. if True [1]
        bis	$31, $31, $24 	# [1-]
        br	$31, G15007	# J. if False [0di]
.align 3
G15012:
/* Shove it in. */
.align 3
G15007:
        bne	$6, G15009	# J. if packed [1]
        subq	$8, ArrayElementTypeObject, $1 	# [0di]
        bne	$1, G15009	# [1]
/* Here for the simple non packed case */
        addq	$22, $19, $1 	# [1]
/* Memory Read Internal */
G15020:
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $25 	# [0di]
        ldl	$5, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$25, $31, $3 	# [0di]
        ldq_u	$2, 0($25)	#  [1-]
        subq	$1, $4, $4 	# Stack cache offset [1di]
        ldq	$18, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [1-]
        cmpult	$4, $5, $5 	# In range? [0di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$2, $25, $2 	# [0di]
        bne	$5, G15022	# [1-]
G15021:
        lda	$25, 240	#  [0di]
        srl	$18, $2, $18 	# [1]
        srl	$25, $2, $25 	# [1]
        blbs	$18, G15024	# [1-]
G15030:
/* Merge cdr-code */
        and	$23, 63, $3 	# [0di]
        and	$2, 192, $2 	# [1]
        bis	$2, $3, $2 	# [1]
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        addq	$1, $14, $4 	# [0di]
        ldl	$18, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$4, $31, $3 	# [0di]
        ldq_u	$25, 0($4)	#  [1-]
        subq	$1, $5, $5 	# Stack cache offset [1di]
        cmpult	$5, $18, $18 	# In range? [1]
        insbl	$2, $4, $5 	# [1]
        mskbl	$25, $4, $25 	# [1]
.align 3
G15032:
        bis	$25, $5, $25 	# [2]
        stq_u	$25, 0($4)	#  [0di]
        stl	$24, 0($3)	#  [1]
        bne	$18, G15031	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
/* Here for the slow packed version */
.align 3
G15009:
        addq	$7, $19, $19 	# [1-]
        srl	$19, $6, $1 	# Convert byte index to word index [1]
        addq	$1, $22, $1 	# Address of word containing byte [2]
/* Memory Read Internal */
G15033:
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $4 	# [1-]
        ldl	$3, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$4, $31, $22 	# [1-]
        ldq_u	$20, 0($4)	#  [1di]
        subq	$1, $2, $2 	# Stack cache offset [1-]
        ldq	$5, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$2, $3, $3 	# In range? [1-]
        ldl	$22, 0($22)	#  [0di]
        extbl	$20, $4, $20 	# [1-]
        bne	$3, G15035	# [0di]
G15034:
        lda	$4, 240	#  [1-]
        srl	$5, $20, $5 	# [1]
        srl	$4, $20, $4 	# [1]
        extll	$22, 0, $22 	# [1]
        blbs	$5, G15037	# [1-]
G15044:
/* Check fixnum element type */
/* TagType. */
        and	$20, 63, $2 	# [0di]
        subq	$2, TypeFixnum, $2 	# [1]
        bne	$2, G15010	# J. if element type not fixnum. [1]
        beq	$6, G15011	# J. if unpacked fixnum element type. [1]
        ornot	$31, $31, $25 	# [0di]
        sll	$25, $6, $25 	# [1]
        subq	$31, $6, $2 	# [1]
        bic	$19, $25, $25 	# Compute subword index [1]
        addq	$2, 5, $2 	# [1]
        sll	$25, $2, $2 	# Compute shift to get byte [1]
        bis	$31, 32, $25 	# [1]
        srl	$25, $6, $25 	# Compute size of byte [1]
        ornot	$31, $31, $3 	# [1]
        sll	$3, $25, $3 	# [1]
        ornot	$31, $3, $4 	# Compute mask for byte [2]
        beq	$2, G15045	# inserting into the low byte is easy [1-]
/* Inserting the byte into any byte other than the low byte */
        addq	$31, 64, $5 	# [0di]
        subq	$5, $2, $25 	# = the left shift rotate amount [1]
        srl	$22, $2, $5 	# shift selected byte into low end of word. [1]
        sll	$22, $25, $22 	# rotate low bits into high end of word. [1]
        and	$3, $5, $5 	# Remove unwanted bits [1]
        srl	$22, $25, $22 	# rotate low bits back into place. [1]
        and	$24, $4, $25 	# Strip any extra bits from element [1]
        bis	$25, $5, $5 	# Insert new bits. [1]
        sll	$5, $2, $5 	# reposition bits [1]
        bis	$22, $5, $22 	# Replace low order bits [2]
        br	$31, G15046	# [0di]
.align 3
G15045:
/* Inserting the byte into the low byte */
        and	$22, $3, $22 	# Remove the old low byte [1-]
        and	$24, $4, $25 	# Remove unwanted bits from the new byte [1]
        bis	$22, $25, $22 	# Insert the new byte in place of the old byte [1]
.align 3
G15046:
        bis	$22, $31, $24 	# [1]
.align 3
G15011:
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        addq	$1, $14, $2 	# [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$2, $31, $5 	# [0di]
        ldq_u	$4, 0($2)	#  [1-]
        subq	$1, $3, $3 	# Stack cache offset [1di]
        cmpult	$3, $25, $25 	# In range? [1]
        insbl	$20, $2, $3 	# [1]
        mskbl	$4, $2, $4 	# [1]
.align 3
G15048:
        bis	$4, $3, $4 	# [2]
        stq_u	$4, 0($2)	#  [0di]
        stl	$24, 0($5)	#  [1]
        bne	$25, G15047	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15010:
        bis	$31, $1, $20 	# [1-]
        bis	$31, 25, $17 	# [1]
	br	$31, ILLEGALOPERAND	# packed array data not in fixnum
.align 3
FASTASET1IOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 32, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
FASTASET1BOUNDS:
        bis	$31, 0, $20 	# [1]
        bis	$31, 13, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15047:
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G15049:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $3, $3 	# Stack cache offset [2di]
        s8addq	$3, $2, $2 	# reconstruct SCA [1]
        stl	$24, 0($2)	# Store in stack [2]
        stl	$20, 4($2)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15035:
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$2, $3, $2 	# reconstruct SCA [3]
        ldl	$22, 0($2)	#  [2]
        ldl	$20, 4($2)	# Read from stack cache [1]
        br	$31, G15034	# [1]
.align 3
G15037:
        blbc	$4, G15036	# [1]
        extll	$22, 0, $1 	# Do the indirect thing [0di]
        br	$31, G15033	# [1-]
.align 3
G15036:
        ldq	$5, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $4 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$4, $5, $4 	# Adjust for a longword load [2di]
        ldl	$5, 0($4)	# Get the memory action [2]
.align 3
G15041:
        and	$5, MemoryActionTransform, $4 	# [3]
        beq	$4, G15040	# [1]
        bic	$20, 63, $20 	# [1-]
        bis	$20, TypeExternalValueCellPointer, $20 	# [1]
        br	$31, G15044	# [1-]
#ifndef MINIMA
G15040:
#endif
#ifdef MINIMA
.align 3
G15040:
        and	$5, MemoryActionBinding, $4 	# [1-]
        ldq	$3, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$4, G15039	# [1-]
        sll	$1, 1, $2 	# [0di]
        ldq	$4, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$2, $3, $2 	# Hash index [1di]
        bis	$31, 1, $3 	# [1]
        sll	$3, IvoryMemoryData, $3 	# [1]
        addl	$2, $4, $2 	# [1]
        extll	$2, 0, $2 	# Clear sign-extension [1]
        s4addq	$2, $3, $3 	# [2]
        ldl	$2, 0($3)	# Fetch the key [2]
        ldl	$22, 4($3)	# Fetch value [1]
        subl	$1, $2, $4 	# Compare [2di]
        bne	$4, G15043	# Trap on miss [1]
        extll	$22, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G15033	# This is another memory read tailcall. [1-]
.align 3
G15043:
	br	$31, DBCACHEMISSTRAP
#endif
G15039:
/* Perform memory action */
        bis	$31, $5, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15031:
        ldq	$5, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G15050:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $5, $5 	# Stack cache offset [2di]
        s8addq	$5, $4, $4 	# reconstruct SCA [1]
        stl	$24, 0($4)	# Store in stack [2]
        stl	$2, 4($4)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15022:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$4, $5, $4 	# reconstruct SCA [3]
        ldl	$3, 0($4)	#  [2]
        ldl	$2, 4($4)	# Read from stack cache [1]
        br	$31, G15021	# [1]
.align 3
G15024:
        blbc	$25, G15023	# [1]
        extll	$3, 0, $1 	# Do the indirect thing [0di]
        br	$31, G15020	# [1-]
.align 3
G15023:
        ldq	$18, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $25 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$25, $18, $25 	# Adjust for a longword load [2di]
        ldl	$18, 0($25)	# Get the memory action [2]
#ifndef MINIMA
G15027:
#endif
#ifdef MINIMA
.align 3
G15027:
        and	$18, MemoryActionBinding, $25 	# [3]
        ldq	$5, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$25, G15026	# [1-]
        sll	$1, 1, $4 	# [0di]
        ldq	$25, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$4, $5, $4 	# Hash index [1di]
        bis	$31, 1, $5 	# [1]
        sll	$5, IvoryMemoryData, $5 	# [1]
        addl	$4, $25, $4 	# [1]
        extll	$4, 0, $4 	# Clear sign-extension [1]
        s4addq	$4, $5, $5 	# [2]
        ldl	$4, 0($5)	# Fetch the key [2]
        ldl	$3, 4($5)	# Fetch value [1]
        subl	$1, $4, $25 	# Compare [2di]
        bne	$25, G15029	# Trap on miss [1]
        extll	$3, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G15020	# This is another memory read tailcall. [1-]
.align 3
G15029:
	br	$31, DBCACHEMISSTRAP
#endif
G15026:
/* Perform memory action */
        bis	$31, $18, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
#ifdef TRACING
	.byte 0x82
	.asciiz "DoFastAset1IM"
#endif
DoFastAset1IM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoFastAset1.
.end DoFastAset1
/* End of Halfword operand from stack instruction - DoFastAset1 */
/* Array leaders. */
.align 5
.globl DoArrayLeader
.ent DoArrayLeader 0
/* Halfword operand from stack instruction - DoArrayLeader */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoArrayLeaderFP
	.globl DoArrayLeaderSP
	.globl DoArrayLeaderLP
	.globl DoArrayLeaderIM
.align 3
DoArrayLeader:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoArrayLeaderSP"
#endif
.align 3
DoArrayLeaderSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoArrayLeader	# [0di]
	.byte 0x90
	.asciiz "DoArrayLeaderLP"
#endif
.align 3
DoArrayLeaderLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoArrayLeader	# [1]
	.byte 0x84
	.asciiz "DoArrayLeaderFP"
#endif
.align 3
DoArrayLeaderFP:	# Entry point for FP relative
.align 3
headDoArrayLeader:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoArrayLeader:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	# arg3=arraytag, arg4=arraydata [1]
        ldl	$18, 4($12)	# arg3=arraytag, arg4=arraydata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        extll	$16, 0, $17 	# index data [1]
        srl	$16, 32, $16 	# index tag [1]
        subq	$16, TypeFixnum, $1 	# [2]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, ARRAYLEADERIOP	# [1]
.align 3
ARRAYLEADERMERGE:
        subq	$18, TypeArray, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, ARRAYLEADEREXCEPTION	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G15051:
        addq	$19, $14, $3 	# [0di]
        s4addq	$3, $31, $20 	# [1]
        ldq_u	$21, 0($3)	#  [1di]
        subq	$19, $24, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$1, $25, $2 	# In range? [1-]
        ldl	$20, 0($20)	#  [0di]
        extbl	$21, $3, $21 	# [1-]
        bne	$2, G15053	# [0di]
G15052:
        lda	$3, 64	#  [1-]
        srl	$4, $21, $4 	# [1]
        srl	$3, $21, $3 	# [1]
        blbs	$4, G15055	# [1di]
G15060:
/* TagType. */
        and	$21, 63, $1 	# [1-]
        subq	$1, TypeHeaderI, $1 	# [1]
        bne	$1, ARRAYLEADERIOP	# [1]
        srl	$20, ArrayLeaderLengthFieldPos, $8 	# [0di]
        and	$8, ArrayLeaderLengthFieldMask, $8 	# [2]
        cmpult	$17, $8, $1 	# [1]
        beq	$1, ARRAYLEADERBOUNDS	# [1]
        subq	$19, $17, $17 	# [0di]
        subq	$17, 1, $17 	# [1]
/* Memory Read Internal */
G15061:
        addq	$17, $14, $3 	# [1]
        s4addq	$3, $31, $20 	# [1]
        ldq_u	$21, 0($3)	#  [1di]
        subq	$17, $24, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$1, $25, $2 	# In range? [1-]
        ldl	$20, 0($20)	#  [0di]
        extbl	$21, $3, $21 	# [1-]
        bne	$2, G15063	# [0di]
G15062:
        lda	$3, 240	#  [1-]
        srl	$4, $21, $4 	# [1]
        srl	$3, $21, $3 	# [1]
        blbs	$4, G15065	# [1di]
G15072:
        and	$21, 63, $1 	# set CDR-NEXT [1-]
        stl	$20, 8($12)	#  [0di]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
ARRAYLEADEREXCEPTION:
        bis	$31, TypeFixnum, $16 	# [1-]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 10, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
ARRAYLEADERIOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 10, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
ARRAYLEADERBOUNDS:
        bis	$31, 0, $20 	# [1]
        bis	$31, 74, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
        br	$31, DoArrayLeaderIM	# [1-]
	.byte 0x82
	.asciiz "DoArrayLeaderIM"
#endif
.align 5
.align 3
DoArrayLeaderIM:	# Entry point for IMMEDIATE mode
        ldl	$19, 0($12)	# arg3=arraytag, arg4=arraydata [1]
        ldl	$18, 4($12)	# arg3=arraytag, arg4=arraydata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        br	$31, ARRAYLEADERMERGE	# [1-]
.align 3
G15063:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$20, 0($1)	#  [2]
        ldl	$21, 4($1)	# Read from stack cache [1]
        br	$31, G15062	# [1]
.align 3
G15065:
        blbc	$3, G15064	# [1]
        extll	$20, 0, $17 	# Do the indirect thing [0di]
        br	$31, G15061	# [1-]
.align 3
G15064:
        ldq	$4, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$21, 63, $3 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
.align 3
G15069:
        and	$4, MemoryActionTransform, $3 	# [3]
        beq	$3, G15068	# [1]
        bic	$21, 63, $21 	# [1-]
        bis	$21, TypeExternalValueCellPointer, $21 	# [1]
        br	$31, G15072	# [1-]
#ifndef MINIMA
G15068:
#endif
#ifdef MINIMA
.align 3
G15068:
        and	$4, MemoryActionBinding, $3 	# [1-]
        ldq	$2, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$3, G15067	# [1-]
        sll	$17, 1, $1 	# [0di]
        ldq	$3, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$1, $2, $1 	# Hash index [1di]
        bis	$31, 1, $2 	# [1]
        sll	$2, IvoryMemoryData, $2 	# [1]
        addl	$1, $3, $1 	# [1]
        extll	$1, 0, $1 	# Clear sign-extension [1]
        s4addq	$1, $2, $2 	# [2]
        ldl	$1, 0($2)	# Fetch the key [2]
        ldl	$20, 4($2)	# Fetch value [1]
        subl	$17, $1, $3 	# Compare [2di]
        bne	$3, G15071	# Trap on miss [1]
        extll	$20, 0, $17 	# Extract the pointer, and indirect [0di]
        br	$31, G15061	# This is another memory read tailcall. [1-]
.align 3
G15071:
	br	$31, DBCACHEMISSTRAP
#endif
G15067:
/* Perform memory action */
        bis	$31, $4, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15053:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$20, 0($1)	#  [2]
        ldl	$21, 4($1)	# Read from stack cache [1]
        br	$31, G15052	# [1]
.align 3
G15055:
        blbc	$3, G15054	# [1]
        extll	$20, 0, $19 	# Do the indirect thing [0di]
        br	$31, G15051	# [1-]
.align 3
G15054:
        ldq	$4, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$21, 63, $3 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
G15057:
/* Perform memory action */
        bis	$31, $4, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoArrayLeader
/* End of Halfword operand from stack instruction - DoArrayLeader */
.align 5
.globl DoStoreArrayLeader
.ent DoStoreArrayLeader 0
/* Halfword operand from stack instruction - DoStoreArrayLeader */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoStoreArrayLeaderFP
	.globl DoStoreArrayLeaderSP
	.globl DoStoreArrayLeaderLP
	.globl DoStoreArrayLeaderIM
.align 3
DoStoreArrayLeader:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoStoreArrayLeaderSP"
#endif
.align 3
DoStoreArrayLeaderSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoStoreArrayLeader	# [0di]
	.byte 0x90
	.asciiz "DoStoreArrayLeaderLP"
#endif
.align 3
DoStoreArrayLeaderLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoStoreArrayLeader	# [1]
	.byte 0x84
	.asciiz "DoStoreArrayLeaderFP"
#endif
.align 3
DoStoreArrayLeaderFP:	# Entry point for FP relative
.align 3
headDoStoreArrayLeader:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoStoreArrayLeader:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	# arg3=arraytag, arg4=arraydata [1]
        ldl	$18, 4($12)	# arg3=arraytag, arg4=arraydata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        ldl	$7, 0($12)	# t6=valuetag, t7=valuedata [1-]
        ldl	$6, 4($12)	# t6=valuetag, t7=valuedata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$7, 0, $7 	# [1]
        extll	$16, 0, $17 	# index data [1]
        srl	$16, 32, $16 	# index tag [1]
        subq	$16, TypeFixnum, $1 	# [2]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, STOREARRAYLEADERIOP	# [1]
.align 3
STOREARRAYLEADERMERGE:
        subq	$18, TypeArray, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, STOREARRAYLEADEREXCEPTION	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G15073:
        addq	$19, $14, $3 	# [0di]
        s4addq	$3, $31, $20 	# [1]
        ldq_u	$21, 0($3)	#  [1di]
        subq	$19, $24, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$1, $25, $2 	# In range? [1-]
        ldl	$20, 0($20)	#  [0di]
        extbl	$21, $3, $21 	# [1-]
        bne	$2, G15075	# [0di]
G15074:
        lda	$3, 64	#  [1-]
        srl	$4, $21, $4 	# [1]
        srl	$3, $21, $3 	# [1]
        blbs	$4, G15077	# [1di]
G15082:
/* TagType. */
        and	$21, 63, $1 	# [1-]
        subq	$1, TypeHeaderI, $1 	# [1]
        bne	$1, STOREARRAYLEADERIOP	# [1]
        srl	$20, ArrayLeaderLengthFieldPos, $2 	# [0di]
        and	$2, ArrayLeaderLengthFieldMask, $2 	# [2]
        cmpult	$17, $2, $1 	# [1]
        beq	$1, STOREARRAYLEADERBOUNDS	# [1]
        subq	$19, $17, $17 	# [0di]
        subq	$17, 1, $17 	# [1]
/* Memory Read Internal */
G15083:
        addq	$17, $14, $5 	# [1]
        s4addq	$5, $31, $2 	# [1]
        ldq_u	$1, 0($5)	#  [1di]
        subq	$17, $24, $3 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [0di]
        cmpult	$3, $25, $4 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $5, $1 	# [1-]
        bne	$4, G15085	# [0di]
G15084:
        lda	$5, 240	#  [1-]
        srl	$8, $1, $8 	# [1]
        srl	$5, $1, $5 	# [1]
        blbs	$8, G15087	# [1di]
G15093:
/* Merge cdr-code */
        and	$6, 63, $2 	# [1-]
        and	$1, 192, $1 	# [1]
        bis	$1, $2, $1 	# [1]
        addq	$17, $14, $3 	# [1]
        s4addq	$3, $31, $2 	# [1]
        ldq_u	$5, 0($3)	#  [1di]
        subq	$17, $24, $4 	# Stack cache offset [1-]
        cmpult	$4, $25, $8 	# In range? [1]
        insbl	$1, $3, $4 	# [1]
        mskbl	$5, $3, $5 	# [1]
.align 3
G15095:
        bis	$5, $4, $5 	# [2]
        stq_u	$5, 0($3)	#  [0di]
        stl	$7, 0($2)	#  [1]
        bne	$8, G15094	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
STOREARRAYLEADEREXCEPTION:
        bis	$31, TypeFixnum, $16 	# [1-]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 3, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 11, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
STOREARRAYLEADERIOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 11, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
STOREARRAYLEADERBOUNDS:
        bis	$31, 0, $20 	# [1]
        bis	$31, 74, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
        br	$31, DoStoreArrayLeaderIM	# [1-]
	.byte 0x82
	.asciiz "DoStoreArrayLeaderIM"
#endif
.align 5
.align 3
DoStoreArrayLeaderIM:	# Entry point for IMMEDIATE mode
        ldl	$19, 0($12)	# arg3=arraytag, arg4=arraydata [1]
        ldl	$18, 4($12)	# arg3=arraytag, arg4=arraydata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        ldl	$7, 0($12)	# t6=valuetag, t7=valuedata [1-]
        ldl	$6, 4($12)	# t6=valuetag, t7=valuedata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$7, 0, $7 	# [1]
        br	$31, STOREARRAYLEADERMERGE	# [1-]
.align 3
G15094:
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$17, $24, $4 	# Stack cache offset [0di]
        s8addq	$4, $3, $3 	# reconstruct SCA [3]
        stl	$7, 0($3)	# Store in stack [2]
        stl	$1, 4($3)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15085:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$3, $4, $3 	# reconstruct SCA [3]
        ldl	$2, 0($3)	#  [2]
        ldl	$1, 4($3)	# Read from stack cache [1]
        br	$31, G15084	# [1]
.align 3
G15087:
        blbc	$5, G15086	# [1]
        extll	$2, 0, $17 	# Do the indirect thing [0di]
        br	$31, G15083	# [1-]
.align 3
G15086:
        ldq	$8, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $5 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$5, $8, $5 	# Adjust for a longword load [2di]
        ldl	$8, 0($5)	# Get the memory action [2]
#ifndef MINIMA
G15090:
#endif
#ifdef MINIMA
.align 3
G15090:
        and	$8, MemoryActionBinding, $5 	# [3]
        ldq	$4, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$5, G15089	# [1-]
        sll	$17, 1, $3 	# [0di]
        ldq	$5, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$3, $4, $3 	# Hash index [1di]
        bis	$31, 1, $4 	# [1]
        sll	$4, IvoryMemoryData, $4 	# [1]
        addl	$3, $5, $3 	# [1]
        extll	$3, 0, $3 	# Clear sign-extension [1]
        s4addq	$3, $4, $4 	# [2]
        ldl	$3, 0($4)	# Fetch the key [2]
        ldl	$2, 4($4)	# Fetch value [1]
        subl	$17, $3, $5 	# Compare [2di]
        bne	$5, G15092	# Trap on miss [1]
        extll	$2, 0, $17 	# Extract the pointer, and indirect [0di]
        br	$31, G15083	# This is another memory read tailcall. [1-]
.align 3
G15092:
	br	$31, DBCACHEMISSTRAP
#endif
G15089:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15075:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$20, 0($1)	#  [2]
        ldl	$21, 4($1)	# Read from stack cache [1]
        br	$31, G15074	# [1]
.align 3
G15077:
        blbc	$3, G15076	# [1]
        extll	$20, 0, $19 	# Do the indirect thing [0di]
        br	$31, G15073	# [1-]
.align 3
G15076:
        ldq	$4, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$21, 63, $3 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
G15079:
/* Perform memory action */
        bis	$31, $4, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoStoreArrayLeader
/* End of Halfword operand from stack instruction - DoStoreArrayLeader */
.align 5
.globl DoAlocLeader
.ent DoAlocLeader 0
/* Halfword operand from stack instruction - DoAlocLeader */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAlocLeaderFP
	.globl DoAlocLeaderSP
	.globl DoAlocLeaderLP
	.globl DoAlocLeaderIM
.align 3
DoAlocLeader:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAlocLeaderSP"
#endif
.align 3
DoAlocLeaderSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAlocLeader	# [0di]
	.byte 0x90
	.asciiz "DoAlocLeaderLP"
#endif
.align 3
DoAlocLeaderLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAlocLeader	# [1]
	.byte 0x84
	.asciiz "DoAlocLeaderFP"
#endif
.align 3
DoAlocLeaderFP:	# Entry point for FP relative
.align 3
headDoAlocLeader:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAlocLeader:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	# arg3=arraytag, arg4=arraydata [1]
        ldl	$18, 4($12)	# arg3=arraytag, arg4=arraydata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        extll	$16, 0, $17 	# index data [1]
        srl	$16, 32, $16 	# index tag [1]
        subq	$16, TypeFixnum, $1 	# [2]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, ALOCLEADERIOP	# [1]
.align 3
ALOCLEADERMERGE:
        subq	$18, TypeArray, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, ALOCLEADEREXCEPTION	# [1]
/* Memory Read Internal */
G15096:
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1]
        addq	$19, $14, $3 	# [1-]
        ldl	$2, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$3, $31, $20 	# [1-]
        ldq_u	$21, 0($3)	#  [1di]
        subq	$19, $1, $1 	# Stack cache offset [1-]
        ldq	$4, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$1, $2, $2 	# In range? [1-]
        ldl	$20, 0($20)	#  [0di]
        extbl	$21, $3, $21 	# [1-]
        bne	$2, G15098	# [0di]
G15097:
        lda	$3, 64	#  [1-]
        srl	$4, $21, $4 	# [1]
        srl	$3, $21, $3 	# [1]
        blbs	$4, G15100	# [1di]
G15105:
/* TagType. */
        and	$21, 63, $1 	# [1-]
        subq	$1, TypeHeaderI, $1 	# [1]
        bne	$1, ALOCLEADERIOP	# [1]
        srl	$20, ArrayLeaderLengthFieldPos, $22 	# [0di]
        and	$22, ArrayLeaderLengthFieldMask, $22 	# [2]
        cmpult	$17, $22, $1 	# [1]
        beq	$1, ALOCLEADERBOUNDS	# [1]
        subq	$19, $17, $17 	# [0di]
        subq	$17, 1, $17 	# [1]
        bis	$31, TypeLocative, $1 	# [1]
        stl	$17, 8($12)	#  [1-]
        stl	$1, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
ALOCLEADEREXCEPTION:
        bis	$31, TypeFixnum, $16 	# [1-]
/* SetTag. */
        sll	$16, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
        bis	$31, 0, $20 	# [1]
        bis	$31, 10, $17 	# [1]
	br	$31, ARRAYEXCEPTION
.align 3
ALOCLEADERIOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 10, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
ALOCLEADERBOUNDS:
        bis	$31, 0, $20 	# [1]
        bis	$31, 74, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
        br	$31, DoAlocLeaderIM	# [1-]
	.byte 0x82
	.asciiz "DoAlocLeaderIM"
#endif
.align 5
.align 3
DoAlocLeaderIM:	# Entry point for IMMEDIATE mode
        ldl	$19, 0($12)	# arg3=arraytag, arg4=arraydata [1]
        ldl	$18, 4($12)	# arg3=arraytag, arg4=arraydata [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        br	$31, ALOCLEADERMERGE	# [1-]
.align 3
G15098:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$1, $2, $1 	# reconstruct SCA [3]
        ldl	$20, 0($1)	#  [2]
        ldl	$21, 4($1)	# Read from stack cache [1]
        br	$31, G15097	# [1]
.align 3
G15100:
        blbc	$3, G15099	# [1]
        extll	$20, 0, $19 	# Do the indirect thing [0di]
        br	$31, G15096	# [1-]
.align 3
G15099:
        ldq	$4, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$21, 63, $3 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$3, $4, $3 	# Adjust for a longword load [2di]
        ldl	$4, 0($3)	# Get the memory action [2]
G15102:
/* Perform memory action */
        bis	$31, $4, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoAlocLeader
/* End of Halfword operand from stack instruction - DoAlocLeader */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunarra.as */
