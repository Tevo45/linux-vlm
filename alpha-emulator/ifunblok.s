/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunblok.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Block Instructions. */
.align 5
.globl DoBlock0Read
.ent DoBlock0Read 0
/* Halfword 10 bit immediate instruction - DoBlock0Read */
	.globl DoBlock0ReadFP
	.globl DoBlock0ReadSP
	.globl DoBlock0ReadLP
	.globl DoBlock0ReadIM
.align 3
DoBlock0Read:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock0Read"
#endif
.align 3
DoBlock0ReadIM:
.align 3
DoBlock0ReadSP:
.align 3
DoBlock0ReadLP:
.align 3
DoBlock0ReadFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR0($14)	#  [1]
        br	$31, BlockRead	# [1-]
.end DoBlock0Read
/* End of Halfword operand from stack instruction - DoBlock0Read */
.align 5
.globl DoBlock0Write
.ent DoBlock0Write 0
/* Halfword operand from stack instruction - DoBlock0Write */
	.globl DoBlock0WriteFP
	.globl DoBlock0WriteSP
	.globl DoBlock0WriteLP
	.globl DoBlock0WriteIM
.align 3
DoBlock0Write:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoBlock0WriteIM"
#endif
.align 3
DoBlock0WriteIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G15484:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoBlock0Write	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock0WriteSP"
#endif
.align 3
DoBlock0WriteSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoBlock0Write	# [0di]
	.byte 0x90
	.asciiz "DoBlock0WriteLP"
#endif
.align 3
DoBlock0WriteLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoBlock0Write	# [1]
	.byte 0x84
	.asciiz "DoBlock0WriteFP"
#endif
.align 3
DoBlock0WriteFP:	# Entry point for FP relative
.align 3
headDoBlock0Write:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoBlock0Write:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$18, PROCESSORSTATE_BAR0($14)	#  [1]
        lda	$17, PROCESSORSTATE_BAR0($14)	#  [0di]
        br	$31, BlockWrite	# [1-]
.end DoBlock0Write
/* End of Halfword operand from stack instruction - DoBlock0Write */
.align 5
.globl DoBlock0ReadShift
.ent DoBlock0ReadShift 0
/* Halfword 10 bit immediate instruction - DoBlock0ReadShift */
	.globl DoBlock0ReadShiftFP
	.globl DoBlock0ReadShiftSP
	.globl DoBlock0ReadShiftLP
	.globl DoBlock0ReadShiftIM
.align 3
DoBlock0ReadShift:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock0ReadShift"
#endif
.align 3
DoBlock0ReadShiftIM:
.align 3
DoBlock0ReadShiftSP:
.align 3
DoBlock0ReadShiftLP:
.align 3
DoBlock0ReadShiftFP:
        extwl	$18, 4, $16 	# [2-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR0($14)	#  [1]
        br	$31, BlockReadShift	# [1-]
.end DoBlock0ReadShift
/* End of Halfword operand from stack instruction - DoBlock0ReadShift */
.align 5
.globl DoBlock3ReadShift
.ent DoBlock3ReadShift 0
/* Halfword 10 bit immediate instruction - DoBlock3ReadShift */
	.globl DoBlock3ReadShiftFP
	.globl DoBlock3ReadShiftSP
	.globl DoBlock3ReadShiftLP
	.globl DoBlock3ReadShiftIM
.align 3
DoBlock3ReadShift:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock3ReadShift"
#endif
.align 3
DoBlock3ReadShiftIM:
.align 3
DoBlock3ReadShiftSP:
.align 3
DoBlock3ReadShiftLP:
.align 3
DoBlock3ReadShiftFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR3($14)	#  [1]
        br	$31, BlockReadShift	# [1-]
.end DoBlock3ReadShift
/* End of Halfword operand from stack instruction - DoBlock3ReadShift */
.align 5
.globl DoBlock2ReadShift
.ent DoBlock2ReadShift 0
/* Halfword 10 bit immediate instruction - DoBlock2ReadShift */
	.globl DoBlock2ReadShiftFP
	.globl DoBlock2ReadShiftSP
	.globl DoBlock2ReadShiftLP
	.globl DoBlock2ReadShiftIM
.align 3
DoBlock2ReadShift:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock2ReadShift"
#endif
.align 3
DoBlock2ReadShiftIM:
.align 3
DoBlock2ReadShiftSP:
.align 3
DoBlock2ReadShiftLP:
.align 3
DoBlock2ReadShiftFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR2($14)	#  [1]
        br	$31, BlockReadShift	# [1-]
.end DoBlock2ReadShift
/* End of Halfword operand from stack instruction - DoBlock2ReadShift */
.align 5
.globl DoBlock1ReadShift
.ent DoBlock1ReadShift 0
/* Halfword 10 bit immediate instruction - DoBlock1ReadShift */
	.globl DoBlock1ReadShiftFP
	.globl DoBlock1ReadShiftSP
	.globl DoBlock1ReadShiftLP
	.globl DoBlock1ReadShiftIM
.align 3
DoBlock1ReadShift:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock1ReadShift"
#endif
.align 3
DoBlock1ReadShiftIM:
.align 3
DoBlock1ReadShiftSP:
.align 3
DoBlock1ReadShiftLP:
.align 3
DoBlock1ReadShiftFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR1($14)	#  [1]
.align 3
BlockReadShift:
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$2, 0($17)	# Get the vma [1]
        srl	$16, 6, $1 	# cycle type [0di]
        and	$16, 4, $4 	# =no-incrementp [1]
        and	$16, 16, $5 	# =cdr-code-nextp [1]
        and	$16, 32, $6 	# =fixnum onlyp [1]
        extll	$2, 0, $2 	# [1]
/* Memory Read Internal */
G15489:
        addq	$2, $14, $24 	# [2]
        s4addq	$1, $31, $25 	# Cycle-number -> table offset [1]
        ldq_u	$8, 0($24)	#  [1-]
        s4addq	$25, $14, $25 	# [0di]
        s4addq	$24, $31, $7 	# [1]
        subq	$2, $20, $22 	# Stack cache offset [1]
        ldq	$25, PROCESSORSTATE_DATAREAD_MASK($25)	#  [1-]
        cmpult	$22, $21, $23 	# In range? [0di]
        ldl	$7, 0($7)	#  [1-]
        extbl	$8, $24, $8 	# [0di]
        bne	$23, G15491	# [1-]
G15490:
        srl	$25, $8, $25 	# [1di]
        extll	$7, 0, $7 	# [1]
        blbs	$25, G15493	# [1di]
G15500:
        beq	$6, G15485	# J. if we don't have to test for fixnump. [1]
        subq	$8, TypeFixnum, $22 	# [0di]
        and	$22, 63, $22 	# Strip CDR code [1]
        bne	$22, G15488	# [1]
.align 3
G15485:
        bne	$4, G15486	# J. if we don't have to increment the address. [1]
        addq	$2, 1, $2 	# Increment the address [0di]
.align 3
G15486:
        stl	$2, 0($17)	# Store updated vma in BAR [1-]
        beq	$5, G15487	# J. if we don't have to clear CDR codes. [1]
        and	$8, 63, $8 	# [1-]
.align 3
G15487:
        lda	$1, 21504	#  [1]
        ldq	$3, PROCESSORSTATE_BYTEROTATE($14)	# Get rotate [0di]
        ldq	$4, PROCESSORSTATE_BYTESIZE($14)	# Get bytesize [1]
/* Get background */
        srl	$1, 10, $2 	# [0di]
        and	$2, 3, $2 	# Extract the byte background [2]
        cmpeq	$2, ALUByteBackgroundOp1, $5 	# [1]
.align 3
G15507:
        beq	$5, G15503	# [1]
/* Here if argument ALUByteBackgroundOp1 */
        bis	$1, $31, $2 	# [0di]
.align 3
G15502:
        srl	$1, 12, $6 	# [1]
        and	$6, 1, $6 	# Extractthe byte rotate latch [2]
        sll	$7, $3, $7 	# [1]
        extll	$7, 4, $5 	# [2]
        extll	$7, 0, $7 	# [1]
        bis	$7, $5, $7 	# OP2 rotated [2]
        beq	$6, G15501	# Don't update rotate latch if not requested [1-]
        stq	$7, PROCESSORSTATE_ROTATELATCH($14)	#  [1]
.align 3
G15501:
        lda	$6, -2	#  [1-]
        sll	$6, $4, $6 	# [1]
        ornot	$31, $6, $6 	# Compute mask [2]
/* Get byte function */
        srl	$1, 13, $5 	# [1]
        and	$5, 1, $5 	# [2]
        cmpeq	$5, ALUByteFunctionDpb, $4 	# [1]
.align 3
G15512:
        beq	$4, G15509	# [1]
/* Here if argument ALUByteFunctionDpb */
        sll	$6, $3, $6 	# Position mask [0di]
.align 3
G15508:
        and	$7, $6, $7 	# rotated&mask [2]
        bic	$2, $6, $2 	# background&~mask [1]
        bis	$7, $2, $7 	# [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$7, 8($12)	#  [1]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
G15488:
        bis	$31, $2, $20 	# [1-]
        bis	$31, 23, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Not a fixnum
.align 3
G15509:
        cmpeq	$5, ALUByteFunctionLdb, $4 	# [1]
.align 3
G15513:
        bne	$4, G15508	# [1]
        br	$31, G15508	# [1]
.align 3
G15503:
        cmpeq	$2, ALUByteBackgroundRotateLatch, $5 	# [1-]
.align 3
G15514:
        beq	$5, G15504	# [1]
/* Here if argument ALUByteBackgroundRotateLatch */
        ldq	$2, PROCESSORSTATE_ROTATELATCH($14)	#  [0di]
        br	$31, G15502	# [1]
.align 3
G15504:
        cmpeq	$2, ALUByteBackgroundZero, $5 	# [2-]
.align 3
G15515:
        beq	$5, G15502	# [1]
/* Here if argument ALUByteBackgroundZero */
        bis	$31, $31, $2 	# [0di]
        br	$31, G15502	# [1-]
.align 3
G15491:
        ldq	$23, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$22, $23, $22 	# reconstruct SCA [3]
        ldl	$7, 0($22)	#  [2]
        ldl	$8, 4($22)	# Read from stack cache [1]
        br	$31, G15490	# [1]
.align 3
G15493:
.align 3
G15492:
        s4addq	$1, $31, $25 	# Cycle-number -> table offset [1-]
        s4addq	$25, $14, $25 	# [1]
        ldq	$25, PROCESSORSTATE_DATAREAD($25)	#  [2]
/* TagType. */
        and	$8, 63, $24 	# Discard the CDR code [0di]
        stq	$2, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$24, $25, $24 	# Adjust for a longword load [2di]
        ldl	$25, 0($24)	# Get the memory action [2]
.align 3
G15498:
        and	$25, MemoryActionIndirect, $23 	# [3]
        beq	$23, G15497	# [1]
        extll	$7, 0, $2 	# Do the indirect thing [1-]
        br	$31, G15489	# [0di]
.align 3
G15497:
        and	$25, MemoryActionTransform, $24 	# [1-]
        beq	$24, G15496	# [1]
        bic	$8, 63, $8 	# [1-]
        bis	$8, TypeExternalValueCellPointer, $8 	# [1]
        br	$31, G15500	# [1-]
#ifndef MINIMA
G15496:
#endif
#ifdef MINIMA
.align 3
G15496:
        and	$25, MemoryActionBinding, $24 	# [1-]
        ldq	$23, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$24, G15495	# [1-]
        sll	$2, 1, $22 	# [0di]
        ldq	$24, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$22, $23, $22 	# Hash index [1di]
        bis	$31, 1, $23 	# [1]
        sll	$23, IvoryMemoryData, $23 	# [1]
        addl	$22, $24, $22 	# [1]
        extll	$22, 0, $22 	# Clear sign-extension [1]
        s4addq	$22, $23, $23 	# [2]
        ldl	$22, 0($23)	# Fetch the key [2]
        ldl	$7, 4($23)	# Fetch value [1]
        subl	$2, $22, $24 	# Compare [2di]
        bne	$24, G15499	# Trap on miss [1]
        extll	$7, 0, $2 	# Extract the pointer, and indirect [0di]
        br	$31, G15489	# This is another memory read tailcall. [1-]
.align 3
G15499:
	br	$31, DBCACHEMISSTRAP
#endif
G15495:
/* Perform memory action */
        bis	$31, $25, $16 	# [1-]
        bis	$31, $1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoBlock1ReadShift
/* End of Halfword operand from stack instruction - DoBlock1ReadShift */
.align 5
.globl DoBlock0ReadAlu
.ent DoBlock0ReadAlu 0
/* Halfword operand from stack instruction - DoBlock0ReadAlu */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoBlock0ReadAluFP
	.globl DoBlock0ReadAluSP
	.globl DoBlock0ReadAluLP
	.globl DoBlock0ReadAluIM
.align 3
DoBlock0ReadAlu:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock0ReadAluSP"
#endif
.align 3
DoBlock0ReadAluSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoBlock0ReadAlu	# [0di]
	.byte 0x90
	.asciiz "DoBlock0ReadAluLP"
#endif
.align 3
DoBlock0ReadAluLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoBlock0ReadAlu	# [1]
	.byte 0x84
	.asciiz "DoBlock0ReadAluFP"
#endif
.align 3
DoBlock0ReadAluFP:	# Entry point for FP relative
.align 3
beginDoBlock0ReadAlu:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lda	$17, PROCESSORSTATE_BAR0($14)	#  [1]
        br	$31, BlockReadAlu	# [1-]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoBlock0ReadAluIM"
#endif
DoBlock0ReadAluIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoBlock0ReadAlu.
.end DoBlock0ReadAlu
/* End of Halfword operand from stack instruction - DoBlock0ReadAlu */
.align 5
.globl DoBlock3ReadAlu
.ent DoBlock3ReadAlu 0
/* Halfword operand from stack instruction - DoBlock3ReadAlu */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoBlock3ReadAluFP
	.globl DoBlock3ReadAluSP
	.globl DoBlock3ReadAluLP
	.globl DoBlock3ReadAluIM
.align 3
DoBlock3ReadAlu:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock3ReadAluSP"
#endif
.align 3
DoBlock3ReadAluSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoBlock3ReadAlu	# [0di]
	.byte 0x90
	.asciiz "DoBlock3ReadAluLP"
#endif
.align 3
DoBlock3ReadAluLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoBlock3ReadAlu	# [1]
	.byte 0x84
	.asciiz "DoBlock3ReadAluFP"
#endif
.align 3
DoBlock3ReadAluFP:	# Entry point for FP relative
.align 3
beginDoBlock3ReadAlu:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lda	$17, PROCESSORSTATE_BAR3($14)	#  [1]
        br	$31, BlockReadAlu	# [1-]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoBlock3ReadAluIM"
#endif
DoBlock3ReadAluIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoBlock3ReadAlu.
.end DoBlock3ReadAlu
/* End of Halfword operand from stack instruction - DoBlock3ReadAlu */
.align 5
.globl DoBlock2ReadAlu
.ent DoBlock2ReadAlu 0
/* Halfword operand from stack instruction - DoBlock2ReadAlu */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoBlock2ReadAluFP
	.globl DoBlock2ReadAluSP
	.globl DoBlock2ReadAluLP
	.globl DoBlock2ReadAluIM
.align 3
DoBlock2ReadAlu:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock2ReadAluSP"
#endif
.align 3
DoBlock2ReadAluSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoBlock2ReadAlu	# [0di]
	.byte 0x90
	.asciiz "DoBlock2ReadAluLP"
#endif
.align 3
DoBlock2ReadAluLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoBlock2ReadAlu	# [1]
	.byte 0x84
	.asciiz "DoBlock2ReadAluFP"
#endif
.align 3
DoBlock2ReadAluFP:	# Entry point for FP relative
.align 3
beginDoBlock2ReadAlu:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lda	$17, PROCESSORSTATE_BAR2($14)	#  [1]
        br	$31, BlockReadAlu	# [1-]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoBlock2ReadAluIM"
#endif
DoBlock2ReadAluIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoBlock2ReadAlu.
.end DoBlock2ReadAlu
/* End of Halfword operand from stack instruction - DoBlock2ReadAlu */
.align 12
        and	$31, $31, $31 	# [1]
.align 12
.align 5
.globl DoBlock1ReadAlu
.ent DoBlock1ReadAlu 0
/* Halfword operand from stack instruction - DoBlock1ReadAlu */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoBlock1ReadAluFP
	.globl DoBlock1ReadAluSP
	.globl DoBlock1ReadAluLP
	.globl DoBlock1ReadAluIM
.align 3
DoBlock1ReadAlu:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock1ReadAluSP"
#endif
.align 3
DoBlock1ReadAluSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoBlock1ReadAlu	# [0di]
	.byte 0x90
	.asciiz "DoBlock1ReadAluLP"
#endif
.align 3
DoBlock1ReadAluLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoBlock1ReadAlu	# [1]
	.byte 0x84
	.asciiz "DoBlock1ReadAluFP"
#endif
.align 3
DoBlock1ReadAluFP:	# Entry point for FP relative
.align 3
beginDoBlock1ReadAlu:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lda	$17, PROCESSORSTATE_BAR1($14)	#  [1]
.align 3
BlockReadAlu:
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$1, 0($17)	# Get the vma [1]
        ldl	$5, 0($16)	#  [1]
        ldl	$4, 4($16)	#  [1]
        extll	$5, 0, $5 	# [2di]
        subq	$4, TypeFixnum, $22 	# [1]
        and	$22, 63, $22 	# Strip CDR code [1]
        bne	$22, G15516	# [1]
        extll	$1, 0, $1 	# [0di]
/* Memory Read Internal */
G15518:
        addq	$1, $14, $24 	# [2]
        s4addq	$24, $31, $3 	# [1]
        ldq_u	$2, 0($24)	#  [1-]
        subq	$1, $20, $22 	# Stack cache offset [0di]
        ldq	$25, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$22, $21, $23 	# In range? [0di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$2, $24, $2 	# [1di]
        bne	$23, G15520	# [1-]
G15519:
        lda	$24, 240	#  [0di]
        srl	$25, $2, $25 	# [1]
        srl	$24, $2, $24 	# [1]
        extll	$3, 0, $3 	# [1]
        blbs	$25, G15522	# [0di]
G15529:
        subq	$2, TypeFixnum, $22 	# [1-]
        and	$22, 63, $22 	# Strip CDR code [1]
        bne	$22, G15517	# [1]
        addq	$1, 1, $1 	# Increment the address [0di]
        stl	$1, 0($17)	# Store updated vma in BAR [1-]
        ldq	$6, PROCESSORSTATE_ALUOP($14)	#  [1]
        stq	$31, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1]
        ldq	$7, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1]
        cmpeq	$6, ALUFunctionBoolean, $1 	# [1-]
.align 3
G15590:
        beq	$1, G15531	# [1]
/* Here if argument ALUFunctionBoolean */
        srl	$7, 10, $8 	# [1di]
        and	$8, 15, $8 	# Extract the ALU boolean function [2]
        cmpeq	$8, BooleClear, $1 	# [1]
.align 3
G15550:
        bne	$1, G15532	# [1]
.align 3
G15533:
        cmpeq	$8, BooleAnd, $1 	# [1]
.align 3
G15551:
        beq	$1, G15534	# [1]
/* Here if argument BooleAnd */
        and	$3, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15534:
        cmpeq	$8, BooleAndC1, $1 	# [1-]
.align 3
G15552:
        beq	$1, G15535	# [1]
/* Here if argument BooleAndC1 */
        bic	$5, $3, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15535:
        cmpeq	$8, Boole2, $1 	# [1-]
.align 3
G15553:
        beq	$1, G15536	# [1]
/* Here if argument Boole2 */
        bis	$5, $31, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15536:
        cmpeq	$8, BooleAndC2, $1 	# [1-]
.align 3
G15554:
        beq	$1, G15537	# [1]
/* Here if argument BooleAndC2 */
        bic	$3, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15537:
        cmpeq	$8, Boole1, $1 	# [1-]
.align 3
G15555:
        beq	$1, G15538	# [1]
/* Here if argument Boole1 */
        bis	$3, $31, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15538:
        cmpeq	$8, BooleXor, $1 	# [1-]
.align 3
G15556:
        beq	$1, G15539	# [1]
/* Here if argument BooleXor */
        xor	$3, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15539:
        cmpeq	$8, BooleIor, $1 	# [1-]
.align 3
G15557:
        beq	$1, G15540	# [1]
/* Here if argument BooleIor */
        bis	$3, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15540:
        cmpeq	$8, BooleNor, $1 	# [1-]
.align 3
G15558:
        beq	$1, G15541	# [1]
/* Here if argument BooleNor */
        bis	$3, $5, $8 	# [0di]
        ornot	$31, $8, $8 	# [1]
        br	$31, G15532	# [0di]
.align 3
G15541:
        cmpeq	$8, BooleEquiv, $1 	# [1-]
.align 3
G15559:
        beq	$1, G15542	# [1]
/* Here if argument BooleEquiv */
        xor	$3, $5, $8 	# [0di]
        ornot	$31, $8, $8 	# [1]
        br	$31, G15532	# [0di]
.align 3
G15542:
        cmpeq	$8, BooleC1, $1 	# [1-]
.align 3
G15560:
        beq	$1, G15543	# [1]
/* Here if argument BooleC1 */
        ornot	$31, $3, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15543:
        cmpeq	$8, BooleOrC1, $1 	# [1-]
.align 3
G15561:
        beq	$1, G15544	# [1]
/* Here if argument BooleOrC1 */
        ornot	$5, $3, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15544:
        cmpeq	$8, BooleC2, $1 	# [1-]
.align 3
G15562:
        beq	$1, G15545	# [1]
/* Here if argument BooleC2 */
        ornot	$31, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15545:
        cmpeq	$8, BooleOrC2, $1 	# [1-]
.align 3
G15563:
        beq	$1, G15546	# [1]
/* Here if argument BooleOrC2 */
        bic	$3, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15546:
        cmpeq	$8, BooleNand, $1 	# [1-]
.align 3
G15564:
        beq	$1, G15547	# [1]
/* Here if argument BooleNand */
        and	$3, $5, $8 	# [0di]
        br	$31, G15532	# [1-]
.align 3
G15547:
        cmpeq	$8, BooleSet, $1 	# [1-]
.align 3
G15565:
        beq	$1, G15532	# [1]
/* Here if argument BooleSet */
        ornot	$31, $31, $8 	# [0di]
.align 3
G15532:
        stl	$8, 0($16)	#  [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15531:
        cmpeq	$6, ALUFunctionByte, $1 	# [1-]
.align 3
G15591:
        beq	$1, G15566	# [1]
/* Here if argument ALUFunctionByte */
        ldq	$22, PROCESSORSTATE_BYTEROTATE($14)	# Get rotate [0di]
        ldq	$23, PROCESSORSTATE_BYTESIZE($14)	# Get bytesize [1]
/* Get background */
        srl	$7, 10, $1 	# [0di]
        and	$1, 3, $1 	# Extract the byte background [2]
        cmpeq	$1, ALUByteBackgroundOp1, $24 	# [1]
.align 3
G15573:
        beq	$24, G15569	# [1]
/* Here if argument ALUByteBackgroundOp1 */
        bis	$3, $31, $1 	# [0di]
.align 3
G15568:
        srl	$7, 12, $25 	# [1]
        and	$25, 1, $25 	# Extractthe byte rotate latch [2]
        sll	$5, $22, $8 	# [1]
        extll	$8, 4, $24 	# [2]
        extll	$8, 0, $8 	# [1]
        bis	$8, $24, $8 	# OP2 rotated [2]
        beq	$25, G15567	# Don't update rotate latch if not requested [1-]
        stq	$8, PROCESSORSTATE_ROTATELATCH($14)	#  [1]
.align 3
G15567:
        lda	$25, -2	#  [1-]
        sll	$25, $23, $25 	# [1]
        ornot	$31, $25, $25 	# Compute mask [2]
/* Get byte function */
        srl	$7, 13, $24 	# [1]
        and	$24, 1, $24 	# [2]
        cmpeq	$24, ALUByteFunctionDpb, $23 	# [1]
.align 3
G15578:
        beq	$23, G15575	# [1]
/* Here if argument ALUByteFunctionDpb */
        sll	$25, $22, $25 	# Position mask [0di]
.align 3
G15574:
        and	$8, $25, $8 	# rotated&mask [2]
        bic	$1, $25, $1 	# background&~mask [1]
        bis	$8, $1, $8 	# [1]
        stl	$8, 0($16)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15566:
        cmpeq	$6, ALUFunctionAdder, $1 	# [1-]
.align 3
G15592:
        beq	$1, G15579	# [1]
/* Here if argument ALUFunctionAdder */
        srl	$7, 11, $23 	# [0di]
        and	$23, 3, $23 	# Extract the op2 [2]
        srl	$7, 10, $22 	# [1]
        and	$22, 1, $22 	# Extract the adder carry in [2]
        cmpeq	$23, ALUAdderOp2Op2, $24 	# [1]
.align 3
G15587:
        beq	$24, G15582	# [1]
/* Here if argument ALUAdderOp2Op2 */
        bis	$5, $31, $1 	# [0di]
.align 3
G15581:
        addq	$3, $1, $8 	# [1]
        addq	$8, $22, $8 	# [1]
        srl	$8, 31, $23 	# Sign bit [1]
        srl	$8, 32, $24 	# Next bit [1]
        xor	$23, $24, $23 	# Low bit is now overflow indicator [2]
        srl	$7, 24, $24 	# Get the load-carry-in bit [1]
        stq	$23, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1-]
        blbc	$24, G15580	# [1]
        extll	$8, 4, $23 	# Get the carry [1-]
        lda	$24, 1024	#  [1]
        bic	$7, $24, $7 	# [1]
        and	$23, 1, $24 	# [1]
        sll	$24, 10, $24 	# [1]
        bis	$7, $24, $7 	# Set the adder carry in [2]
        stq	$7, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1-]
.align 3
G15580:
        cmplt	$3, $1, $23 	# [1-]
        stq	$23, PROCESSORSTATE_ALUBORROW($14)	#  [0di]
        addl	$3, $31, $3 	# [1-]
        addl	$5, $31, $5 	# [1]
        cmplt	$3, $1, $23 	# [1]
        stq	$23, PROCESSORSTATE_ALULESSTHAN($14)	#  [0di]
        stl	$8, 0($16)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15579:
        cmpeq	$6, ALUFunctionMultiplyDivide, $1 	# [1-]
.align 3
G15593:
        beq	$1, G15530	# [1]
/* Here if argument ALUFunctionMultiplyDivide */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
        stl	$8, 0($16)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15530:
.align 3
G15516:
/* Convert stack cache address to VMA */
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$16, $22, $22 	# stack cache base relative offset [3]
        srl	$22, 3, $22 	# convert byte address to word address [1]
        addq	$22, $20, $1 	# reconstruct VMA [2]
        bis	$31, $1, $20 	# [1]
        bis	$31, 23, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Not a fixnum
.align 3
G15517:
        bis	$31, $1, $20 	# [1]
        bis	$31, 23, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Not a fixnum
.align 3
G15582:
        cmpeq	$23, ALUAdderOp2Zero, $24 	# [1]
.align 3
G15594:
        beq	$24, G15583	# [1]
/* Here if argument ALUAdderOp2Zero */
        bis	$31, $31, $1 	# [0di]
        br	$31, G15581	# [1-]
.align 3
G15583:
        cmpeq	$23, ALUAdderOp2Invert, $24 	# [1-]
.align 3
G15595:
        beq	$24, G15584	# [1]
/* Here if argument ALUAdderOp2Invert */
        addl	$5, $31, $1 	# [0di]
        subq	$31, $1, $1 	# [1]
        extll	$1, 0, $1 	# [1]
        br	$31, G15581	# [1-]
.align 3
G15584:
        cmpeq	$23, ALUAdderOp2MinusOne, $24 	# [1-]
.align 3
G15596:
        beq	$24, G15581	# [1]
/* Here if argument ALUAdderOp2MinusOne */
        ornot	$31, $31, $1 	# [0di]
        extll	$1, 0, $1 	# [1]
        br	$31, G15581	# [0di]
.align 3
G15575:
        cmpeq	$24, ALUByteFunctionLdb, $23 	# [1-]
.align 3
G15597:
        bne	$23, G15574	# [1]
        br	$31, G15574	# [1]
.align 3
G15569:
        cmpeq	$1, ALUByteBackgroundRotateLatch, $24 	# [1-]
.align 3
G15598:
        beq	$24, G15570	# [1]
/* Here if argument ALUByteBackgroundRotateLatch */
        ldq	$1, PROCESSORSTATE_ROTATELATCH($14)	#  [0di]
        br	$31, G15568	# [1]
.align 3
G15570:
        cmpeq	$1, ALUByteBackgroundZero, $24 	# [2-]
.align 3
G15599:
        beq	$24, G15568	# [1]
/* Here if argument ALUByteBackgroundZero */
        bis	$31, $31, $1 	# [0di]
        br	$31, G15568	# [1-]
.align 3
G15520:
        ldq	$23, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$22, $23, $22 	# reconstruct SCA [3]
        ldl	$3, 0($22)	#  [2]
        ldl	$2, 4($22)	# Read from stack cache [1]
        br	$31, G15519	# [1]
.align 3
G15522:
        blbc	$24, G15521	# [1]
        extll	$3, 0, $1 	# Do the indirect thing [0di]
        br	$31, G15518	# [1-]
.align 3
G15521:
        ldq	$25, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $24 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$24, $25, $24 	# Adjust for a longword load [2di]
        ldl	$25, 0($24)	# Get the memory action [2]
.align 3
G15526:
        and	$25, MemoryActionTransform, $24 	# [3]
        beq	$24, G15525	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G15529	# [1-]
#ifndef MINIMA
G15525:
#endif
#ifdef MINIMA
.align 3
G15525:
        and	$25, MemoryActionBinding, $24 	# [1-]
        ldq	$23, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$24, G15524	# [1-]
        sll	$1, 1, $22 	# [0di]
        ldq	$24, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$22, $23, $22 	# Hash index [1di]
        bis	$31, 1, $23 	# [1]
        sll	$23, IvoryMemoryData, $23 	# [1]
        addl	$22, $24, $22 	# [1]
        extll	$22, 0, $22 	# Clear sign-extension [1]
        s4addq	$22, $23, $23 	# [2]
        ldl	$22, 0($23)	# Fetch the key [2]
        ldl	$3, 4($23)	# Fetch value [1]
        subl	$1, $22, $24 	# Compare [2di]
        bne	$24, G15528	# Trap on miss [1]
        extll	$3, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G15518	# This is another memory read tailcall. [1-]
.align 3
G15528:
	br	$31, DBCACHEMISSTRAP
#endif
G15524:
/* Perform memory action */
        bis	$31, $25, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
#ifdef TRACING
	.byte 0x82
	.asciiz "DoBlock1ReadAluIM"
#endif
DoBlock1ReadAluIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoBlock1ReadAlu.
.end DoBlock1ReadAlu
/* End of Halfword operand from stack instruction - DoBlock1ReadAlu */
.align 5
.globl DoBlock0ReadTest
.ent DoBlock0ReadTest 0
/* Halfword 10 bit immediate instruction - DoBlock0ReadTest */
	.globl DoBlock0ReadTestFP
	.globl DoBlock0ReadTestSP
	.globl DoBlock0ReadTestLP
	.globl DoBlock0ReadTestIM
.align 3
DoBlock0ReadTest:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock0ReadTest"
#endif
.align 3
DoBlock0ReadTestIM:
.align 3
DoBlock0ReadTestSP:
.align 3
DoBlock0ReadTestLP:
.align 3
DoBlock0ReadTestFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR0($14)	#  [1]
        br	$31, BlockReadTest	# [1-]
.end DoBlock0ReadTest
/* End of Halfword operand from stack instruction - DoBlock0ReadTest */
.align 5
.globl DoBlock3ReadTest
.ent DoBlock3ReadTest 0
/* Halfword 10 bit immediate instruction - DoBlock3ReadTest */
	.globl DoBlock3ReadTestFP
	.globl DoBlock3ReadTestSP
	.globl DoBlock3ReadTestLP
	.globl DoBlock3ReadTestIM
.align 3
DoBlock3ReadTest:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock3ReadTest"
#endif
.align 3
DoBlock3ReadTestIM:
.align 3
DoBlock3ReadTestSP:
.align 3
DoBlock3ReadTestLP:
.align 3
DoBlock3ReadTestFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR3($14)	#  [1]
        br	$31, BlockReadTest	# [1-]
.end DoBlock3ReadTest
/* End of Halfword operand from stack instruction - DoBlock3ReadTest */
.align 5
.globl DoBlock2ReadTest
.ent DoBlock2ReadTest 0
/* Halfword 10 bit immediate instruction - DoBlock2ReadTest */
	.globl DoBlock2ReadTestFP
	.globl DoBlock2ReadTestSP
	.globl DoBlock2ReadTestLP
	.globl DoBlock2ReadTestIM
.align 3
DoBlock2ReadTest:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock2ReadTest"
#endif
.align 3
DoBlock2ReadTestIM:
.align 3
DoBlock2ReadTestSP:
.align 3
DoBlock2ReadTestLP:
.align 3
DoBlock2ReadTestFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR2($14)	#  [1]
        br	$31, BlockReadTest	# [1-]
.end DoBlock2ReadTest
/* End of Halfword operand from stack instruction - DoBlock2ReadTest */
.align 5
.globl DoBlock1ReadTest
.ent DoBlock1ReadTest 0
/* Halfword 10 bit immediate instruction - DoBlock1ReadTest */
	.globl DoBlock1ReadTestFP
	.globl DoBlock1ReadTestSP
	.globl DoBlock1ReadTestLP
	.globl DoBlock1ReadTestIM
.align 3
DoBlock1ReadTest:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoBlock1ReadTest"
#endif
.align 3
DoBlock1ReadTestIM:
.align 3
DoBlock1ReadTestSP:
.align 3
DoBlock1ReadTestLP:
.align 3
DoBlock1ReadTestFP:
        extwl	$18, 4, $16 	# [1-]
/* arg1 has operand preloaded. */
        lda	$17, PROCESSORSTATE_BAR1($14)	#  [1]
.align 3
BlockReadTest:
        ldl	$18, 0($17)	# Get the vma [2]
        srl	$16, 6, $1 	# cycle type [0di]
        ldl	$5, 0($12)	#  [1-]
        ldl	$4, 4($12)	#  [1]
        extll	$5, 0, $5 	# [2-]
        extll	$18, 0, $18 	# [1]
/* Memory Read Internal */
G15606:
        ldq	$22, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$18, $14, $24 	# [1di]
        ldl	$23, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$1, $31, $25 	# Cycle-number -> table offset [0di]
        ldq_u	$2, 0($24)	#  [1-]
        s4addq	$25, $14, $25 	# [0di]
        s4addq	$24, $31, $3 	# [1]
        subq	$18, $22, $22 	# Stack cache offset [1]
        ldq	$25, PROCESSORSTATE_DATAREAD_MASK($25)	#  [1-]
        cmpult	$22, $23, $23 	# In range? [0di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$2, $24, $2 	# [0di]
        bne	$23, G15608	# [1-]
G15607:
        srl	$25, $2, $25 	# [1di]
        extll	$3, 0, $3 	# [1]
        blbs	$25, G15610	# [1di]
G15617:
        and	$16, 32, $1 	# =fixnum onlyp [1-]
        beq	$1, G15600	# J. if we don't have to test for fixnump. [1]
        subq	$2, TypeFixnum, $22 	# [1-]
        and	$22, 63, $22 	# Strip CDR code [1]
        bne	$22, G15603	# [1]
        subq	$4, TypeFixnum, $22 	# [1]
        and	$22, 63, $22 	# Strip CDR code [1]
        bne	$22, G15604	# [1]
.align 3
G15600:
        and	$16, 16, $1 	# =cdr-code-nextp [1-]
        beq	$1, G15602	# J. if we don't have to clear CDR codes. [1]
/* TagType. */
        and	$2, 63, $2 	# [1-]
.align 3
G15602:
        ldq	$6, PROCESSORSTATE_ALUOP($14)	#  [1-]
        stq	$31, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1]
        ldq	$7, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1]
        cmpeq	$6, ALUFunctionBoolean, $1 	# [1di]
.align 3
G15678:
        beq	$1, G15619	# [1]
/* Here if argument ALUFunctionBoolean */
        srl	$7, 10, $8 	# [1di]
        and	$8, 15, $8 	# Extract the ALU boolean function [2]
        cmpeq	$8, BooleClear, $1 	# [1]
.align 3
G15638:
        bne	$1, G15620	# [1]
.align 3
G15621:
        cmpeq	$8, BooleAnd, $1 	# [1]
.align 3
G15639:
        beq	$1, G15622	# [1]
/* Here if argument BooleAnd */
        and	$3, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15622:
        cmpeq	$8, BooleAndC1, $1 	# [1-]
.align 3
G15640:
        beq	$1, G15623	# [1]
/* Here if argument BooleAndC1 */
        bic	$5, $3, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15623:
        cmpeq	$8, Boole2, $1 	# [1-]
.align 3
G15641:
        beq	$1, G15624	# [1]
/* Here if argument Boole2 */
        bis	$5, $31, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15624:
        cmpeq	$8, BooleAndC2, $1 	# [1-]
.align 3
G15642:
        beq	$1, G15625	# [1]
/* Here if argument BooleAndC2 */
        bic	$3, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15625:
        cmpeq	$8, Boole1, $1 	# [1-]
.align 3
G15643:
        beq	$1, G15626	# [1]
/* Here if argument Boole1 */
        bis	$3, $31, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15626:
        cmpeq	$8, BooleXor, $1 	# [1-]
.align 3
G15644:
        beq	$1, G15627	# [1]
/* Here if argument BooleXor */
        xor	$3, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15627:
        cmpeq	$8, BooleIor, $1 	# [1-]
.align 3
G15645:
        beq	$1, G15628	# [1]
/* Here if argument BooleIor */
        bis	$3, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15628:
        cmpeq	$8, BooleNor, $1 	# [1-]
.align 3
G15646:
        beq	$1, G15629	# [1]
/* Here if argument BooleNor */
        bis	$3, $5, $8 	# [0di]
        ornot	$31, $8, $8 	# [1]
        br	$31, G15620	# [0di]
.align 3
G15629:
        cmpeq	$8, BooleEquiv, $1 	# [1-]
.align 3
G15647:
        beq	$1, G15630	# [1]
/* Here if argument BooleEquiv */
        xor	$3, $5, $8 	# [0di]
        ornot	$31, $8, $8 	# [1]
        br	$31, G15620	# [0di]
.align 3
G15630:
        cmpeq	$8, BooleC1, $1 	# [1-]
.align 3
G15648:
        beq	$1, G15631	# [1]
/* Here if argument BooleC1 */
        ornot	$31, $3, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15631:
        cmpeq	$8, BooleOrC1, $1 	# [1-]
.align 3
G15649:
        beq	$1, G15632	# [1]
/* Here if argument BooleOrC1 */
        ornot	$5, $3, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15632:
        cmpeq	$8, BooleC2, $1 	# [1-]
.align 3
G15650:
        beq	$1, G15633	# [1]
/* Here if argument BooleC2 */
        ornot	$31, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15633:
        cmpeq	$8, BooleOrC2, $1 	# [1-]
.align 3
G15651:
        beq	$1, G15634	# [1]
/* Here if argument BooleOrC2 */
        bic	$3, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15634:
        cmpeq	$8, BooleNand, $1 	# [1-]
.align 3
G15652:
        beq	$1, G15635	# [1]
/* Here if argument BooleNand */
        and	$3, $5, $8 	# [0di]
        br	$31, G15620	# [1-]
.align 3
G15635:
        cmpeq	$8, BooleSet, $1 	# [1-]
.align 3
G15653:
        beq	$1, G15620	# [1]
/* Here if argument BooleSet */
        ornot	$31, $31, $8 	# [0di]
.align 3
G15620:
.align 3
G15618:
        srl	$7, 16, $1 	# [1]
        and	$1, 31, $1 	# Extract ALU condition [2]
        ldq	$23, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1-]
        ldq	$24, PROCESSORSTATE_ALUBORROW($14)	#  [1]
        ldq	$25, PROCESSORSTATE_ALULESSTHAN($14)	#  [1]
        cmpeq	$1, ALUConditionSignedLessThanOrEqual, $22 	# [0di]
.align 3
G15710:
        beq	$22, G15683	# [1]
/* Here if argument ALUConditionSignedLessThanOrEqual */
        bne	$25, G15679	# [2]
        beq	$8, G15679	# [1]
.align 3
G15682:
.align 3
G15680:
        bis	$31, $31, $1 	# [1-]
        br	$31, G15681	# [0di]
.align 3
G15679:
        bis	$31, 1, $1 	# [1-]
.align 3
G15681:
        srl	$7, 21, $22 	# [1]
        and	$22, 1, $22 	# Extract the condition sense [2]
        xor	$1, $22, $1 	# [1]
        bne	$1, G15605	# [1]
        and	$16, 4, $1 	# =no-incrementp [1]
        bne	$1, G15601	# J. if we don't have to increment the address. [1]
        addq	$18, 1, $18 	# Increment the address [1-]
.align 3
G15601:
        stl	$18, 0($17)	# Store updated vma in BAR [1-]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G15605:
        ldl	$23, -8($12)	#  [1]
        ldl	$22, -4($12)	#  [1]
        extll	$23, 0, $23 	# [2-]
        sll	$23, 1, $23 	# [2]
        and	$22, 1, $9 	# [1]
        addq	$9, $23, $9 	# [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [1-]
.align 3
G15604:
/* Convert stack cache address to VMA */
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$18, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $22, $22 	# stack cache base relative offset [2-]
        srl	$22, 3, $22 	# convert byte address to word address [1]
        addq	$22, $18, $18 	# reconstruct VMA [2]
        bis	$31, $18, $20 	# [1]
        bis	$31, 23, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Not a fixnum
.align 3
G15603:
        bis	$31, $18, $20 	# [1]
        bis	$31, 23, $17 	# [1]
	br	$31, ILLEGALOPERAND	# Not a fixnum
.align 3
G15683:
        cmpeq	$1, ALUConditionSignedLessThan, $22 	# [1]
.align 3
G15711:
        beq	$22, G15684	# [1]
/* Here if argument ALUConditionSignedLessThan */
        bne	$25, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15684:
        cmpeq	$1, ALUConditionNegative, $22 	# [1-]
.align 3
G15712:
        beq	$22, G15685	# [1]
/* Here if argument ALUConditionNegative */
        blt	$8, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15685:
        cmpeq	$1, ALUConditionSignedOverflow, $22 	# [1-]
.align 3
G15713:
        beq	$22, G15686	# [1]
/* Here if argument ALUConditionSignedOverflow */
        bne	$23, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15686:
        cmpeq	$1, ALUConditionUnsignedLessThanOrEqual, $22 	# [1-]
.align 3
G15714:
        beq	$22, G15687	# [1]
/* Here if argument ALUConditionUnsignedLessThanOrEqual */
        bne	$24, G15679	# [1]
        beq	$8, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15687:
        cmpeq	$1, ALUConditionUnsignedLessThan, $22 	# [1-]
.align 3
G15715:
        beq	$22, G15688	# [1]
/* Here if argument ALUConditionUnsignedLessThan */
        bne	$24, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15688:
        cmpeq	$1, ALUConditionZero, $22 	# [1-]
.align 3
G15716:
        beq	$22, G15689	# [1]
/* Here if argument ALUConditionZero */
        beq	$8, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15689:
        cmpeq	$1, ALUConditionHigh25Zero, $22 	# [1-]
.align 3
G15717:
        beq	$22, G15690	# [1]
/* Here if argument ALUConditionHigh25Zero */
        srl	$8, 7, $1 	# [0di]
        beq	$1, G15679	# [2]
        br	$31, G15682	# [1]
.align 3
G15690:
        cmpeq	$1, ALUConditionEq, $22 	# [1-]
.align 3
G15718:
        beq	$22, G15691	# [1]
/* Here if argument ALUConditionEq */
        bne	$8, G15680	# [1]
        xor	$2, $4, $22 	# [1-]
/* TagType. */
        and	$22, 63, $22 	# [1]
        beq	$22, G15679	# [1]
        br	$31, G15682	# [1]
.align 3
G15691:
        cmpeq	$1, ALUConditionOp1Ephemeralp, $22 	# [1-]
.align 3
G15719:
        beq	$22, G15692	# [1]
/* Here if argument ALUConditionOp1Ephemeralp */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15692:
        cmpeq	$1, ALUConditionResultTypeNil, $22 	# [1]
.align 3
G15720:
        beq	$22, G15693	# [1]
/* Here if argument ALUConditionResultTypeNil */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15693:
        cmpeq	$1, ALUConditionOp2Fixnum, $22 	# [1]
.align 3
G15721:
        beq	$22, G15694	# [1]
/* Here if argument ALUConditionOp2Fixnum */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15694:
        cmpeq	$1, ALUConditionFalse, $22 	# [1]
.align 3
G15722:
        beq	$22, G15695	# [1]
/* Here if argument ALUConditionFalse */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15695:
        cmpeq	$1, ALUConditionResultCdrLow, $22 	# [1]
.align 3
G15723:
        beq	$22, G15696	# [1]
/* Here if argument ALUConditionResultCdrLow */
/* TagCdr. */
        srl	$2, 6, $22 	# [1]
        and	$22, 1, $1 	# [2]
        br	$31, G15681	# [0di]
.align 3
G15696:
        cmpeq	$1, ALUConditionCleanupBitsSet, $22 	# [1-]
.align 3
G15724:
        beq	$22, G15697	# [1]
/* Here if argument ALUConditionCleanupBitsSet */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15697:
        cmpeq	$1, ALUConditionAddressInStackCache, $22 	# [1]
.align 3
G15725:
        beq	$22, G15698	# [1]
/* Here if argument ALUConditionAddressInStackCache */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15698:
        cmpeq	$1, ALUConditionExtraStackMode, $22 	# [1]
.align 3
G15726:
        beq	$22, G15699	# [1]
/* Here if argument ALUConditionExtraStackMode */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15699:
        cmpeq	$1, ALUConditionFepMode, $22 	# [1]
.align 3
G15727:
        beq	$22, G15700	# [1]
/* Here if argument ALUConditionFepMode */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15700:
        cmpeq	$1, ALUConditionFpCoprocessorPresent, $22 	# [1]
.align 3
G15728:
        beq	$22, G15701	# [1]
/* Here if argument ALUConditionFpCoprocessorPresent */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15701:
        cmpeq	$1, ALUConditionOp1Oldspacep, $22 	# [1]
.align 3
G15729:
        beq	$22, G15702	# [1]
/* Here if argument ALUConditionOp1Oldspacep */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15702:
        cmpeq	$1, ALUConditionPendingSequenceBreakEnabled, $22 	# [1]
.align 3
G15730:
        beq	$22, G15703	# [1]
/* Here if argument ALUConditionPendingSequenceBreakEnabled */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15703:
        cmpeq	$1, ALUConditionOp1TypeAcceptable, $22 	# [1]
.align 3
G15731:
        beq	$22, G15704	# [1]
/* Here if argument ALUConditionOp1TypeAcceptable */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15704:
        cmpeq	$1, ALUConditionOp1TypeCondition, $22 	# [1]
.align 3
G15732:
        beq	$22, G15705	# [1]
/* Here if argument ALUConditionOp1TypeCondition */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15705:
        cmpeq	$1, ALUConditionStackCacheOverflow, $22 	# [1]
.align 3
G15733:
        beq	$22, G15706	# [1]
/* Here if argument ALUConditionStackCacheOverflow */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15706:
        cmpeq	$1, ALUConditionOrLogicVariable, $22 	# [1]
.align 3
G15734:
        beq	$22, G15707	# [1]
/* Here if argument ALUConditionOrLogicVariable */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15707:
/* Here for all other cases */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [1]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15619:
        cmpeq	$6, ALUFunctionByte, $1 	# [1]
.align 3
G15735:
        beq	$1, G15654	# [1]
/* Here if argument ALUFunctionByte */
        ldq	$22, PROCESSORSTATE_BYTEROTATE($14)	# Get rotate [0di]
        ldq	$23, PROCESSORSTATE_BYTESIZE($14)	# Get bytesize [1]
/* Get background */
        srl	$7, 10, $1 	# [0di]
        and	$1, 3, $1 	# Extract the byte background [2]
        cmpeq	$1, ALUByteBackgroundOp1, $24 	# [1]
.align 3
G15661:
        beq	$24, G15657	# [1]
/* Here if argument ALUByteBackgroundOp1 */
        bis	$3, $31, $1 	# [0di]
.align 3
G15656:
        srl	$7, 12, $25 	# [1]
        and	$25, 1, $25 	# Extractthe byte rotate latch [2]
        sll	$5, $22, $8 	# [1]
        extll	$8, 4, $24 	# [2]
        extll	$8, 0, $8 	# [1]
        bis	$8, $24, $8 	# OP2 rotated [2]
        beq	$25, G15655	# Don't update rotate latch if not requested [1-]
        stq	$8, PROCESSORSTATE_ROTATELATCH($14)	#  [1]
.align 3
G15655:
        lda	$25, -2	#  [1-]
        sll	$25, $23, $25 	# [1]
        ornot	$31, $25, $25 	# Compute mask [2]
/* Get byte function */
        srl	$7, 13, $24 	# [1]
        and	$24, 1, $24 	# [2]
        cmpeq	$24, ALUByteFunctionDpb, $23 	# [1]
.align 3
G15666:
        beq	$23, G15663	# [1]
/* Here if argument ALUByteFunctionDpb */
        sll	$25, $22, $25 	# Position mask [0di]
.align 3
G15662:
        and	$8, $25, $8 	# rotated&mask [2]
        bic	$1, $25, $1 	# background&~mask [1]
        bis	$8, $1, $8 	# [1]
        br	$31, G15618	# [0di]
.align 3
G15654:
        cmpeq	$6, ALUFunctionAdder, $1 	# [1-]
.align 3
G15736:
        beq	$1, G15667	# [1]
/* Here if argument ALUFunctionAdder */
        srl	$7, 11, $23 	# [0di]
        and	$23, 3, $23 	# Extract the op2 [2]
        srl	$7, 10, $22 	# [1]
        and	$22, 1, $22 	# Extract the adder carry in [2]
        cmpeq	$23, ALUAdderOp2Op2, $24 	# [1]
.align 3
G15675:
        beq	$24, G15670	# [1]
/* Here if argument ALUAdderOp2Op2 */
        bis	$5, $31, $1 	# [0di]
.align 3
G15669:
        addq	$3, $1, $8 	# [1]
        addq	$8, $22, $8 	# [1]
        srl	$8, 31, $23 	# Sign bit [1]
        srl	$8, 32, $24 	# Next bit [1]
        xor	$23, $24, $23 	# Low bit is now overflow indicator [2]
        srl	$7, 24, $24 	# Get the load-carry-in bit [1]
        stq	$23, PROCESSORSTATE_ALUOVERFLOW($14)	#  [1-]
        blbc	$24, G15668	# [1]
        extll	$8, 4, $23 	# Get the carry [1-]
        lda	$24, 1024	#  [1]
        bic	$7, $24, $7 	# [1]
        and	$23, 1, $24 	# [1]
        sll	$24, 10, $24 	# [1]
        bis	$7, $24, $7 	# Set the adder carry in [2]
        stq	$7, PROCESSORSTATE_ALUANDROTATECONTROL($14)	#  [1-]
.align 3
G15668:
        cmplt	$3, $1, $23 	# [1-]
        stq	$23, PROCESSORSTATE_ALUBORROW($14)	#  [0di]
        addl	$3, $31, $3 	# [1-]
        addl	$5, $31, $5 	# [1]
        cmplt	$3, $1, $23 	# [1]
        stq	$23, PROCESSORSTATE_ALULESSTHAN($14)	#  [0di]
        br	$31, G15618	# [1]
.align 3
G15667:
        cmpeq	$6, ALUFunctionMultiplyDivide, $1 	# [1-]
.align 3
G15737:
        beq	$1, G15618	# [1]
/* Here if argument ALUFunctionMultiplyDivide */
/* This instruction has not been written yet. */
        bis	$31, 0, $20 	# [0di]
        bis	$31, 38, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15670:
        cmpeq	$23, ALUAdderOp2Zero, $24 	# [1]
.align 3
G15738:
        beq	$24, G15671	# [1]
/* Here if argument ALUAdderOp2Zero */
        bis	$31, $31, $1 	# [0di]
        br	$31, G15669	# [1-]
.align 3
G15671:
        cmpeq	$23, ALUAdderOp2Invert, $24 	# [1-]
.align 3
G15739:
        beq	$24, G15672	# [1]
/* Here if argument ALUAdderOp2Invert */
        addl	$5, $31, $1 	# [0di]
        subq	$31, $1, $1 	# [1]
        extll	$1, 0, $1 	# [1]
        br	$31, G15669	# [1-]
.align 3
G15672:
        cmpeq	$23, ALUAdderOp2MinusOne, $24 	# [1-]
.align 3
G15740:
        beq	$24, G15669	# [1]
/* Here if argument ALUAdderOp2MinusOne */
        ornot	$31, $31, $1 	# [0di]
        extll	$1, 0, $1 	# [1]
        br	$31, G15669	# [0di]
.align 3
G15663:
        cmpeq	$24, ALUByteFunctionLdb, $23 	# [1-]
.align 3
G15741:
        bne	$23, G15662	# [1]
        br	$31, G15662	# [1]
.align 3
G15657:
        cmpeq	$1, ALUByteBackgroundRotateLatch, $24 	# [1-]
.align 3
G15742:
        beq	$24, G15658	# [1]
/* Here if argument ALUByteBackgroundRotateLatch */
        ldq	$1, PROCESSORSTATE_ROTATELATCH($14)	#  [0di]
        br	$31, G15656	# [1]
.align 3
G15658:
        cmpeq	$1, ALUByteBackgroundZero, $24 	# [2-]
.align 3
G15743:
        beq	$24, G15656	# [1]
/* Here if argument ALUByteBackgroundZero */
        bis	$31, $31, $1 	# [0di]
        br	$31, G15656	# [1-]
.align 3
G15608:
        ldq	$23, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$22, $23, $22 	# reconstruct SCA [3]
        ldl	$3, 0($22)	#  [2]
        ldl	$2, 4($22)	# Read from stack cache [1]
        br	$31, G15607	# [1]
.align 3
G15610:
.align 3
G15609:
        s4addq	$1, $31, $25 	# Cycle-number -> table offset [1-]
        s4addq	$25, $14, $25 	# [1]
        ldq	$25, PROCESSORSTATE_DATAREAD($25)	#  [2]
/* TagType. */
        and	$2, 63, $24 	# Discard the CDR code [0di]
        stq	$18, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$24, $25, $24 	# Adjust for a longword load [2di]
        ldl	$25, 0($24)	# Get the memory action [2]
.align 3
G15615:
        and	$25, MemoryActionIndirect, $23 	# [3]
        beq	$23, G15614	# [1]
        extll	$3, 0, $18 	# Do the indirect thing [1-]
        br	$31, G15606	# [0di]
.align 3
G15614:
        and	$25, MemoryActionTransform, $24 	# [1-]
        beq	$24, G15613	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G15617	# [1-]
#ifndef MINIMA
G15613:
#endif
#ifdef MINIMA
.align 3
G15613:
        and	$25, MemoryActionBinding, $24 	# [1-]
        ldq	$23, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$24, G15612	# [1-]
        sll	$18, 1, $22 	# [0di]
        ldq	$24, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$22, $23, $22 	# Hash index [1di]
        bis	$31, 1, $23 	# [1]
        sll	$23, IvoryMemoryData, $23 	# [1]
        addl	$22, $24, $22 	# [1]
        extll	$22, 0, $22 	# Clear sign-extension [1]
        s4addq	$22, $23, $23 	# [2]
        ldl	$22, 0($23)	# Fetch the key [2]
        ldl	$3, 4($23)	# Fetch value [1]
        subl	$18, $22, $24 	# Compare [2di]
        bne	$24, G15616	# Trap on miss [1]
        extll	$3, 0, $18 	# Extract the pointer, and indirect [0di]
        br	$31, G15606	# This is another memory read tailcall. [1-]
.align 3
G15616:
	br	$31, DBCACHEMISSTRAP
#endif
G15612:
/* Perform memory action */
        bis	$31, $25, $16 	# [1-]
        bis	$31, $1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoBlock1ReadTest
/* End of Halfword operand from stack instruction - DoBlock1ReadTest */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunblok.as */
