/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuncom2.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* The most commonly used instructions, part 2. */
.align 5
.globl DoPushInstanceVariable
.ent DoPushInstanceVariable 0
/* Halfword 10 bit immediate instruction - DoPushInstanceVariable */
	.globl DoPushInstanceVariableFP
	.globl DoPushInstanceVariableSP
	.globl DoPushInstanceVariableLP
	.globl DoPushInstanceVariableIM
.align 3
DoPushInstanceVariable:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoPushInstanceVariable"
#endif
.align 3
DoPushInstanceVariableIM:
.align 3
DoPushInstanceVariableSP:
.align 3
DoPushInstanceVariableLP:
.align 3
DoPushInstanceVariableFP:
/* arg1 has operand preloaded. */
        bis	$17, $31, $16 	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Mapped */
        ldl	$17, 16($10)	# Map [1]
        ldl	$20, 20($10)	#  [1]
        extll	$17, 0, $17 	# [2di]
        subq	$20, TypeArray, $2 	# [1]
        and	$2, 63, $2 	# Strip CDR code [1]
        bne	$2, IVBADMAP	# [1]
/* Memory Read Internal */
G13739:
        addq	$17, $14, $7 	# [0di]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13741	# [0di]
G13740:
        lda	$7, 64	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13743	# [1di]
G13748:
        and	$21, ArrayLengthMask, $21 	# [1-]
        subq	$21, $16, $3 	# [1]
        ble	$3, IVBADINDEX	# J. if mapping-table-index-out-of-bounds [1]
        addq	$17, $16, $17 	# [0di]
        addq	$17, 1, $17 	# [1]
/* Memory Read Internal */
G13749:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13751	# [0di]
G13750:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13753	# [1-]
G13760:
        bis	$21, $31, $1 	# [1di]
        subq	$20, TypeFixnum, $4 	# [1]
        and	$4, 63, $4 	# Strip CDR code [1]
        bne	$4, PUSHIVEXCEPTION	# [1]
        ldl	$17, 24($10)	# Self [0di]
        ldl	$4, 28($10)	#  [1]
        extll	$17, 0, $17 	# [2di]
        subq	$4, TypeInstance, $3 	# [1]
        and	$3, 60, $3 	# Strip CDR code, low bits [1]
        bne	$3, IVBADINST	# [1]
        and	$4, 192, $3 	# Unshifted cdr code [1]
        subq	$3, 64, $3 	# Check for CDR code 1 [1]
        bne	$3, G13738	# J. if CDR code is not 1 [1]
.align 3
G13737:
        addq	$17, $1, $17 	# [1-]
.align 3
G13736:
/* Memory Read Internal */
G13761:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13763	# [1-]
G13762:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13765	# [1-]
G13772:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        and	$20, 63, $7 	# set CDR-NEXT [0di]
        stl	$21, 8($12)	#  [1-]
        stl	$7, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G13765:
        blbc	$7, G13764	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13761	# [1-]
.align 3
G13764:
.align 3
G13763:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13772	# [1]
.align 3
G13753:
        blbc	$7, G13752	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13749	# [1-]
.align 3
G13752:
.align 3
G13751:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G13760	# [1]
.align 3
G13743:
        blbc	$7, G13742	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13739	# [1-]
.align 3
G13742:
.align 3
G13741:
	bsr	$0, MemoryReadHeaderDECODE
        br	$31, G13748	# [1]
.align 3
G13738:
        bis	$17, $31, $3 	# [1-]
/* Memory Read Internal */
G13773:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G13775	# [0di]
G13774:
        lda	$7, 64	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13777	# [1-]
G13782:
        subq	$3, $17, $3 	# [0di]
        bne	$3, G13737	# [1]
/* TagType. */
        and	$4, 63, $4 	# [0di]
        bis	$4, 64, $4 	# Set CDR code to 1 [1]
        stl	$17, 24($10)	# Update self [0di]
        stl	$4, 28($10)	# write the stack cache [1]
        br	$31, G13737	# [1]
.align 3
G13777:
        blbc	$7, G13776	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13773	# [1-]
.align 3
G13776:
.align 3
G13775:
	bsr	$0, MemoryReadHeaderDECODE
        br	$31, G13782	# [1]
.end DoPushInstanceVariable
/* End of Halfword operand from stack instruction - DoPushInstanceVariable */
.align 5
.globl DoAdd
.ent DoAdd 0
/* Halfword operand from stack instruction - DoAdd */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAddFP
	.globl DoAddSP
	.globl DoAddLP
	.globl DoAddIM
.align 3
DoAdd:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAddSP"
#endif
.align 3
DoAddSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoAdd	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoAdd	# [0di]
	.byte 0x90
	.asciiz "DoAddLP"
#endif
.align 3
DoAddLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoAdd	# [1]
	.byte 0x84
	.asciiz "DoAddFP"
#endif
.align 3
DoAddFP:	# Entry point for FP relative
.align 3
beginDoAdd:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lds	$f1, 0($12)	#  [0di]
        extll	$21, 4, $1 	# ARG1 tag [1-]
        ldl	$3, 4($16)	# ARG2 tag [1di]
        addl	$21, $31, $2 	# ARG1 data [1-]
        ldl	$4, 0($16)	# ARG2 data [0di]
        lds	$f2, 0($16)	#  [1]
        and	$1, 63, $22 	# Strip off any CDR code bits. [0di]
        and	$3, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$22, TypeFixnum, $23 	# [1]
.align 3
G13822:
        beq	$23, G13793	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$24, TypeFixnum, $25 	# [0di]
.align 3
G13799:
        beq	$25, G13795	# [1]
/* Here if argument TypeFixnum */
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [0di]
        addlv	$2, $4, $5 	# compute 64-bit result [1-]
        ldq	$7, CACHELINE_NEXTCP($13)	#  [0di]
        trapb			# Force the trap to occur here [3]
        stl	$22, 4($12)	# Semi-cheat, we know temp2 has CDRNext/TypeFixnum [1]
        bis	$6, $31, $9 	# [1-]
        stl	$5, 0($12)	#  [0di]
        bis	$7, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G13795:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G13800:
        beq	$25, G13796	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G13783	# [1]
.align 3
G13796:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G13801:
        beq	$25, G13790	# [1]
/* Here if argument TypeDoubleFloat */
        cvtlq	$f1, $f1 	# [3]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G13786	# [1]
.align 3
G13794:
.align 3
G13793:
        cmpeq	$22, TypeSingleFloat, $23 	# [1-]
.align 3
G13823:
        beq	$23, G13802	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$24, TypeSingleFloat, $25 	# [0di]
.align 3
G13808:
        beq	$25, G13804	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G13783:
        adds	$f1, $f2, $f0 	# [2]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1-]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G13804:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G13809:
        beq	$25, G13805	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G13783	# [1]
.align 3
G13805:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G13810:
        beq	$25, G13790	# [1]
/* Here if argument TypeDoubleFloat */
.align 3
G13786:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        br	$31, G13787	# [1]
.align 3
G13803:
.align 3
G13802:
        cmpeq	$22, TypeDoubleFloat, $23 	# [1-]
.align 3
G13824:
        beq	$23, G13811	# [1]
/* Here if argument TypeDoubleFloat */
        cmpeq	$24, TypeDoubleFloat, $25 	# [0di]
.align 3
G13817:
        beq	$25, G13813	# [1]
/* Here if argument TypeDoubleFloat */
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [0di]
	bsr	$0, FetchDoubleFloat
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [1-]
.align 3
G13787:
        extll	$4, 0, $17 	# [1-]
	bsr	$0, FetchDoubleFloat
        ldt	$f2, PROCESSORSTATE_FP0($14)	#  [0di]
.align 3
G13784:
        addt	$f1, $f2, $f0 	# [3]
        stt	$f0, PROCESSORSTATE_FP0($14)	#  [0di]
	bsr	$0, ConsDoubleFloat
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1-]
        stl	$17, 0($12)	#  [0di]
        stl	$8, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G13813:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G13818:
        beq	$25, G13814	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G13785:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [1-]
	bsr	$0, FetchDoubleFloat
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [0di]
        br	$31, G13784	# [1]
.align 3
G13814:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G13819:
        beq	$25, G13790	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G13785	# [1]
.align 3
G13812:
.align 3
G13811:
/* Here for all other cases */
.align 3
G13789:
.align 3
DOADDOVFL:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G13791	# [1-]
.align 3
G13790:
        bis	$3, $31, $1 	# [1-]
        br	$31, DOADDOVFL	# [0di]
.align 3
G13791:
.align 3
G13792:
#ifdef TRACING
        br	$31, DoAddIM	# [1]
	.byte 0x82
	.asciiz "DoAddIM"
#endif
.align 5
.align 3
DoAddIM:	# Entry point for IMMEDIATE mode
        extll	$21, 4, $1 	# [1-]
        addl	$21, $31, $2 	# get ARG1 tag/data [1]
        and	$1, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$24, TypeFixnum, $25 	# [1]
.align 3
G13829:
        beq	$25, G13826	# [1]
/* Here if argument TypeFixnum */
        addq	$2, $17, $3 	# compute 64-bit result [0di]
        ldq	$4, CACHELINE_NEXTPCDATA($13)	#  [1-]
        addl	$3, $31, $23 	# compute 32-bit sign-extended result [0di]
        ldq	$5, CACHELINE_NEXTCP($13)	#  [1-]
        cmpeq	$3, $23, $23 	# is it the same as the 64-bit result? [0di]
        beq	$23, DOADDOVFL	# if not, we overflowed [1]
        stl	$24, 4($12)	# Semi-cheat, we know temp2 has CDRNext/TypeFixnum [1]
        bis	$4, $31, $9 	# [1-]
        stl	$3, 0($12)	#  [0di]
        bis	$5, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G13826:
/* Here for all other cases */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        bis	$31, $31, $17 	# [1]
        br	$31, beginDoAdd	# [0di]
.align 3
G13825:
.end DoAdd
/* End of Halfword operand from stack instruction - DoAdd */
.align 5
.globl DoBlock3Write
.ent DoBlock3Write 0
/* Halfword operand from stack instruction - DoBlock3Write */
	.globl DoBlock3WriteFP
	.globl DoBlock3WriteSP
	.globl DoBlock3WriteLP
	.globl DoBlock3WriteIM
.align 3
DoBlock3Write:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoBlock3WriteIM"
#endif
.align 3
DoBlock3WriteIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1-]
.align 3
G13863:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoBlock3Write	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoBlock3WriteSP"
#endif
.align 3
DoBlock3WriteSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoBlock3Write	# [0di]
	.byte 0x90
	.asciiz "DoBlock3WriteLP"
#endif
.align 3
DoBlock3WriteLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoBlock3Write	# [1]
	.byte 0x84
	.asciiz "DoBlock3WriteFP"
#endif
.align 3
DoBlock3WriteFP:	# Entry point for FP relative
.align 3
headDoBlock3Write:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoBlock3Write:
/* arg1 has the operand, sign extended if immediate. */
        ldl	$18, PROCESSORSTATE_BAR3($14)	#  [1]
        lda	$17, PROCESSORSTATE_BAR3($14)	#  [0di]
        br	$31, BlockWrite	# [1-]
.end DoBlock3Write
/* End of Halfword operand from stack instruction - DoBlock3Write */
.align 5
.globl DoAset1
.ent DoAset1 0
/* Halfword operand from stack instruction - DoAset1 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAset1FP
	.globl DoAset1SP
	.globl DoAset1LP
	.globl DoAset1IM
.align 3
DoAset1:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAset1SP"
#endif
.align 3
DoAset1SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoAset1	# [0di]
	.byte 0x90
	.asciiz "DoAset1LP"
#endif
.align 3
DoAset1LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoAset1	# [1]
	.byte 0x84
	.asciiz "DoAset1FP"
#endif
.align 3
DoAset1FP:	# Entry point for FP relative
.align 3
headDoAset1:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoAset1:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	# Get the array tag/data [1]
        ldl	$18, 4($12)	# Get the array tag/data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        ldl	$6, 0($12)	# Get the new value tag/data [1-]
        ldl	$5, 4($12)	# Get the new value tag/data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$6, 0, $6 	# [1]
        addl	$16, 0, $17 	# (sign-extended, for fast bounds check) Index Data [1]
        lda	$8, AutoArrayRegMask	#  [1]
        and	$19, $8, $8 	# [1]
        srl	$16, 32, $16 	# Index Tag [1]
        lda	$7, PROCESSORSTATE_AC0ARRAY($14)	#  [1]
        addq	$7, $8, $7 	# This is the address if the array register block. [1]
        subq	$16, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, ASET1ILLEGAL	# [1]
.align 3
ASET1MERGE:
        beq	$19, Aset1Regset	# [1]
        ldq	$8, ARRAYCACHE_ARRAY($7)	# Cached array object. [0di]
        subq	$18, TypeArray, $1 	# [1-]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, REALLYASET1EXC	# [1]
        cmpeq	$19, $8, $8 	# t8==1 iff cached array is ours. [0di]
        beq	$8, Aset1Regset	# Go and setup the array register. [1]
#ifdef SLOWARRAYS
        br	$31, Aset1Regset	# [1]
#endif
        ldq	$21, ARRAYCACHE_ARWORD($7)	#  [1]
        ldq	$22, ARRAYCACHE_LOCAT($7)	# high order bits all zero [1]
        ldq	$3, ARRAYCACHE_LENGTH($7)	# high order bits all zero [1]
        sll	$21, 42, $24 	# [1di]
        ldq	$4, PROCESSORSTATE_AREVENTCOUNT($14)	#  [1-]
        srl	$24, 42, $24 	# [1di]
        cmpult	$17, $3, $2 	# [1]
        subq	$4, $24, $25 	# [1]
        bne	$25, Aset1Regset	# J. if event count ticked. [1]
        beq	$2, ASET1BOUNDS	# [1]
        srl	$21, ArrayRegisterBytePackingPos, $20 	# [1-]
        srl	$21, ArrayRegisterElementTypePos, $8 	# [1]
        srl	$21, ArrayRegisterByteOffsetPos, $19 	# [1]
        and	$20, ArrayRegisterBytePackingMask, $20 	# [1]
        and	$19, ArrayRegisterByteOffsetMask, $19 	# [1]
        and	$8, ArrayRegisterElementTypeMask, $21 	# [1]
.align 3
ASET1RESTART:
/* Element checking and foreplay. */
/* TagType. */
        and	$5, 63, $1 	# [1]
        cmpeq	$21, ArrayElementTypeCharacter, $8 	# [1]
.align 3
G13874:
        beq	$8, G13870	# [1]
/* Here if argument ArrayElementTypeCharacter */
        subq	$1, TypeCharacter, $2 	# [0di]
        beq	$2, G13865	# [1]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 29, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13865:
        beq	$20, G13864	# Certainly will fit if not packed! [1-]
        bis	$31, 32, $2 	# [0di]
        srl	$2, $20, $2 	# Compute size of byte [1]
        ornot	$31, $31, $1 	# [1]
        sll	$1, $2, $1 	# [1]
        ornot	$31, $1, $1 	# Compute mask for byte [2]
        and	$6, $1, $1 	# [1]
        subq	$6, $1, $1 	# [1]
        beq	$1, G13864	# J. if character fits. [1]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 62, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13870:
        cmpeq	$21, ArrayElementTypeFixnum, $8 	# [1]
.align 3
G13875:
        beq	$8, G13871	# [1]
/* Here if argument ArrayElementTypeFixnum */
        subq	$1, TypeFixnum, $2 	# [0di]
        beq	$2, G13864	# [1]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 33, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13871:
        cmpeq	$21, ArrayElementTypeBoolean, $8 	# [1]
.align 3
G13876:
        beq	$8, G13869	# [1]
/* Here if argument ArrayElementTypeBoolean */
        bis	$31, 1, $6 	# [0di]
        subq	$1, TypeNIL, $1 	# [1]
        bne	$1, G13864	# J. if True [1]
        bis	$31, $31, $6 	# [1-]
        br	$31, G13864	# J. if False [0di]
.align 3
G13869:
/* Shove it in. */
.align 3
G13864:
        bne	$20, G13866	# J. if packed [1]
        subq	$21, ArrayElementTypeObject, $1 	# [0di]
        bne	$1, G13866	# [1]
/* Here for the simple non packed case */
        addq	$22, $17, $1 	# [1]
/* Memory Read Internal */
G13877:
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $8 	# [0di]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$8, $31, $3 	# [0di]
        ldq_u	$2, 0($8)	#  [1-]
        subq	$1, $4, $4 	# Stack cache offset [1di]
        ldq	$16, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [1-]
        cmpult	$4, $7, $7 	# In range? [0di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$2, $8, $2 	# [0di]
        bne	$7, G13879	# [1-]
G13878:
        lda	$8, 240	#  [0di]
        srl	$16, $2, $16 	# [1]
        srl	$8, $2, $8 	# [1]
        blbs	$16, G13881	# [1-]
G13887:
/* Merge cdr-code */
        and	$5, 63, $3 	# [0di]
        and	$2, 192, $2 	# [1]
        bis	$2, $3, $2 	# [1]
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        addq	$1, $14, $4 	# [0di]
        ldl	$16, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$4, $31, $3 	# [0di]
        ldq_u	$8, 0($4)	#  [1-]
        subq	$1, $7, $7 	# Stack cache offset [1di]
        cmpult	$7, $16, $16 	# In range? [1]
        insbl	$2, $4, $7 	# [1]
        mskbl	$8, $4, $8 	# [1]
.align 3
G13889:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($4)	#  [0di]
        stl	$6, 0($3)	#  [1]
        bne	$16, G13888	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
/* Here for the slow packed version */
.align 3
G13866:
        addq	$19, $17, $17 	# [1-]
        srl	$17, $20, $1 	# Convert byte index to word index [1]
        addq	$1, $22, $1 	# Address of word containing byte [2]
/* Memory Read Internal */
G13890:
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$1, $14, $4 	# [1-]
        ldl	$3, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$4, $31, $22 	# [1-]
        ldq_u	$18, 0($4)	#  [1di]
        subq	$1, $2, $2 	# Stack cache offset [1-]
        ldq	$7, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$2, $3, $3 	# In range? [1-]
        ldl	$22, 0($22)	#  [0di]
        extbl	$18, $4, $18 	# [1-]
        bne	$3, G13892	# [0di]
G13891:
        lda	$4, 240	#  [1-]
        srl	$7, $18, $7 	# [1]
        srl	$4, $18, $4 	# [1]
        extll	$22, 0, $22 	# [1]
        blbs	$7, G13894	# [1-]
G13901:
/* Check fixnum element type */
/* TagType. */
        and	$18, 63, $2 	# [0di]
        subq	$2, TypeFixnum, $2 	# [1]
        bne	$2, G13867	# J. if element type not fixnum. [1]
        beq	$20, G13868	# J. if unpacked fixnum element type. [1]
        ornot	$31, $31, $8 	# [0di]
        sll	$8, $20, $8 	# [1]
        subq	$31, $20, $2 	# [1]
        bic	$17, $8, $8 	# Compute subword index [1]
        addq	$2, 5, $2 	# [1]
        sll	$8, $2, $2 	# Compute shift to get byte [1]
        bis	$31, 32, $8 	# [1]
        srl	$8, $20, $8 	# Compute size of byte [1]
        ornot	$31, $31, $3 	# [1]
        sll	$3, $8, $3 	# [1]
        ornot	$31, $3, $4 	# Compute mask for byte [2]
        beq	$2, G13902	# inserting into the low byte is easy [1-]
/* Inserting the byte into any byte other than the low byte */
        addq	$31, 64, $7 	# [0di]
        subq	$7, $2, $8 	# = the left shift rotate amount [1]
        srl	$22, $2, $7 	# shift selected byte into low end of word. [1]
        sll	$22, $8, $22 	# rotate low bits into high end of word. [1]
        and	$3, $7, $7 	# Remove unwanted bits [1]
        srl	$22, $8, $22 	# rotate low bits back into place. [1]
        and	$6, $4, $8 	# Strip any extra bits from element [1]
        bis	$8, $7, $7 	# Insert new bits. [1]
        sll	$7, $2, $7 	# reposition bits [1]
        bis	$22, $7, $22 	# Replace low order bits [2]
        br	$31, G13903	# [0di]
.align 3
G13902:
/* Inserting the byte into the low byte */
        and	$22, $3, $22 	# Remove the old low byte [1-]
        and	$6, $4, $8 	# Remove unwanted bits from the new byte [1]
        bis	$22, $8, $22 	# Insert the new byte in place of the old byte [1]
.align 3
G13903:
        bis	$22, $31, $6 	# [1]
.align 3
G13868:
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        addq	$1, $14, $2 	# [0di]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$2, $31, $7 	# [0di]
        ldq_u	$4, 0($2)	#  [1-]
        subq	$1, $3, $3 	# Stack cache offset [1di]
        cmpult	$3, $8, $8 	# In range? [1]
        insbl	$18, $2, $3 	# [1]
        mskbl	$4, $2, $4 	# [1]
.align 3
G13905:
        bis	$4, $3, $4 	# [2]
        stq_u	$4, 0($2)	#  [0di]
        stl	$6, 0($7)	#  [1]
        bne	$8, G13904	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13867:
        bis	$31, $1, $20 	# [1-]
        bis	$31, 25, $17 	# [1]
	br	$31, ILLEGALOPERAND	# packed array data not in fixnum
#ifdef TRACING
        br	$31, DoAset1IM	# [1-]
	.byte 0x82
	.asciiz "DoAset1IM"
#endif
.align 5
.align 3
DoAset1IM:	# Entry point for IMMEDIATE mode
        lda	$8, AutoArrayRegMask	#  [1-]
        ldl	$19, 0($12)	# Get the array tag/data [0di]
        ldl	$18, 4($12)	# Get the array tag/data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        lda	$7, PROCESSORSTATE_AC0ARRAY($14)	#  [1]
        and	$19, $8, $8 	# [1]
        addq	$7, $8, $7 	# This is the address of the array register block. [1]
        ldl	$6, 0($12)	# Get the new value tag/data [1-]
        ldl	$5, 4($12)	# Get the new value tag/data [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$6, 0, $6 	# [1]
        br	$31, ASET1MERGE	# [1-]
.align 3
G13904:
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
.align 3
G13906:
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $3, $3 	# Stack cache offset [2di]
        s8addq	$3, $2, $2 	# reconstruct SCA [1]
        stl	$6, 0($2)	# Store in stack [2]
        stl	$18, 4($2)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13892:
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$2, $3, $2 	# reconstruct SCA [3]
        ldl	$22, 0($2)	#  [2]
        ldl	$18, 4($2)	# Read from stack cache [1]
        br	$31, G13891	# [1]
.align 3
G13894:
        blbc	$4, G13893	# [1]
        extll	$22, 0, $1 	# Do the indirect thing [0di]
        br	$31, G13890	# [1-]
.align 3
G13893:
        ldq	$7, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$18, 63, $4 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$4, $7, $4 	# Adjust for a longword load [2di]
        ldl	$7, 0($4)	# Get the memory action [2]
.align 3
G13898:
        and	$7, MemoryActionTransform, $4 	# [3]
        beq	$4, G13897	# [1]
        bic	$18, 63, $18 	# [1-]
        bis	$18, TypeExternalValueCellPointer, $18 	# [1]
        br	$31, G13901	# [1-]
#ifndef MINIMA
G13897:
#endif
#ifdef MINIMA
.align 3
G13897:
        and	$7, MemoryActionBinding, $4 	# [1-]
        ldq	$3, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$4, G13896	# [1-]
        sll	$1, 1, $2 	# [0di]
        ldq	$4, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$2, $3, $2 	# Hash index [1di]
        bis	$31, 1, $3 	# [1]
        sll	$3, IvoryMemoryData, $3 	# [1]
        addl	$2, $4, $2 	# [1]
        extll	$2, 0, $2 	# Clear sign-extension [1]
        s4addq	$2, $3, $3 	# [2]
        ldl	$2, 0($3)	# Fetch the key [2]
        ldl	$22, 4($3)	# Fetch value [1]
        subl	$1, $2, $4 	# Compare [2di]
        bne	$4, G13900	# Trap on miss [1]
        extll	$22, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G13890	# This is another memory read tailcall. [1-]
.align 3
G13900:
	br	$31, DBCACHEMISSTRAP
#endif
G13896:
/* Perform memory action */
        bis	$31, $7, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G13888:
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
.align 3
G13907:
        ldq	$4, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $7, $7 	# Stack cache offset [2di]
        s8addq	$7, $4, $4 	# reconstruct SCA [1]
        stl	$6, 0($4)	# Store in stack [2]
        stl	$2, 4($4)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13879:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$4, $7, $4 	# reconstruct SCA [3]
        ldl	$3, 0($4)	#  [2]
        ldl	$2, 4($4)	# Read from stack cache [1]
        br	$31, G13878	# [1]
.align 3
G13881:
        blbc	$8, G13880	# [1]
        extll	$3, 0, $1 	# Do the indirect thing [0di]
        br	$31, G13877	# [1-]
.align 3
G13880:
        ldq	$16, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $8 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $16, $8 	# Adjust for a longword load [2di]
        ldl	$16, 0($8)	# Get the memory action [2]
#ifndef MINIMA
G13884:
#endif
#ifdef MINIMA
.align 3
G13884:
        and	$16, MemoryActionBinding, $8 	# [3]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$8, G13883	# [1-]
        sll	$1, 1, $4 	# [0di]
        ldq	$8, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$4, $7, $4 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$4, $8, $4 	# [1]
        extll	$4, 0, $4 	# Clear sign-extension [1]
        s4addq	$4, $7, $7 	# [2]
        ldl	$4, 0($7)	# Fetch the key [2]
        ldl	$3, 4($7)	# Fetch value [1]
        subl	$1, $4, $8 	# Compare [2di]
        bne	$8, G13886	# Trap on miss [1]
        extll	$3, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G13877	# This is another memory read tailcall. [1-]
.align 3
G13886:
	br	$31, DBCACHEMISSTRAP
#endif
G13883:
/* Perform memory action */
        bis	$31, $16, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoAset1
/* End of Halfword operand from stack instruction - DoAset1 */
.align 5
.globl DoFastAref1
.ent DoFastAref1 0
/* Halfword operand from stack instruction - DoFastAref1 */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoFastAref1FP
	.globl DoFastAref1SP
	.globl DoFastAref1LP
	.globl DoFastAref1IM
.align 3
DoFastAref1:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoFastAref1SP"
#endif
.align 3
DoFastAref1SP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        bne	$17, beginDoFastAref1	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoFastAref1	# [0di]
	.byte 0x90
	.asciiz "DoFastAref1LP"
#endif
.align 3
DoFastAref1LP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoFastAref1	# [1]
	.byte 0x84
	.asciiz "DoFastAref1FP"
#endif
.align 3
DoFastAref1FP:	# Entry point for FP relative
.align 3
beginDoFastAref1:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        extll	$21, 4, $18 	# [1]
        addl	$21, $31, $19 	# [1]
        subq	$18, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, FASTAREF1IOP	# [1]
.align 3
FASTAREF1RETRY:
        ldl	$21, 0($16)	#  [1-]
        ldl	$22, 8($16)	#  [1]
        ldl	$3, 16($16)	#  [1]
        extll	$21, 0, $21 	# [1di]
        extll	$22, 0, $22 	# [1]
        sll	$21, 42, $5 	# [1]
        extll	$3, 0, $3 	# [1]
        ldq	$4, PROCESSORSTATE_AREVENTCOUNT($14)	#  [0di]
        srl	$5, 42, $5 	# [1-]
        cmpult	$19, $3, $2 	# [1]
        beq	$2, FASTAREF1BOUNDS	# [1]
        subq	$4, $5, $6 	# [0di]
        bne	$6, Aref1RecomputeArrayRegister	# [1]
        srl	$21, ArrayRegisterBytePackingPos, $6 	# [1]
        srl	$21, ArrayRegisterByteOffsetPos, $7 	# [1]
        srl	$21, ArrayRegisterElementTypePos, $8 	# [1]
        and	$6, ArrayRegisterBytePackingMask, $6 	# [1]
        and	$7, ArrayRegisterByteOffsetMask, $7 	# [1]
        and	$8, ArrayRegisterElementTypeMask, $8 	# [1]
        bne	$6, G13908	# [0di]
        addq	$22, $19, $1 	# [1-]
.align 3
G13909:
/* Memory Read Internal */
G13916:
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $4 	# [0di]
        ldl	$3, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$4, $31, $22 	# [0di]
        ldq_u	$20, 0($4)	#  [1-]
        subq	$1, $2, $2 	# Stack cache offset [1di]
        ldq	$5, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$2, $3, $3 	# In range? [0di]
        ldl	$22, 0($22)	#  [1-]
        extbl	$20, $4, $20 	# [0di]
        bne	$3, G13918	# [1-]
G13917:
        lda	$4, 240	#  [0di]
        srl	$5, $20, $5 	# [1]
        srl	$4, $20, $4 	# [1]
        extll	$22, 0, $22 	# [1]
        blbs	$5, G13920	# [0di]
G13927:
        bne	$6, G13910	# [1]
.align 3
G13911:
        bis	$31, $31, $31 	# [0]
        subq	$8, 2, $1 	# [1]
        ble	$1, G13912	# [1]
/* TagType. */
        and	$20, 63, $20 	# [0di]
.align 3
G13913:
        stl	$20, 4($12)	#  [1-]
        cmpeq	$6, 0, $4 	# [0di]
        beq	$4, CASE_OTHERS_14	# [1]
.align 3
CASE_0_8:
        bis	$31, $31, $31 	# [0]
        beq	$1, G13914	# [0di]
        stl	$22, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_2_9:
/* AREF1-8B */
        bis	$31, $31, $31 	# [0]
        and	$19, 3, $4 	# [1]
        extbl	$22, $4, $5 	# [1]
        beq	$1, G13914	# [0di]
        stl	$5, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_3_10:
/* AREF1-4B */
        bis	$31, $31, $31 	# [0]
        and	$19, 7, $4 	# byte-index [1]
        sll	$4, 2, $4 	# byte-position [1]
        srl	$22, $4, $5 	# byte in position [2]
        and	$5, 15, $5 	# byte masked [2]
        beq	$1, G13914	# [0di]
        stl	$5, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_5_11:
/* AREF1-1B */
        bis	$31, $31, $31 	# [0]
        and	$19, 31, $4 	# byte-index [1]
        bis	$31, $31, $31 	# [0]
        srl	$22, $4, $5 	# byte in position [1]
        and	$5, 1, $5 	# byte masked [2]
        beq	$1, G13914	# [0di]
        stl	$5, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_1_12:
/* AREF1-16B */
        and	$19, 1, $4 	# [1-]
        addq	$4, $4, $4 	# Bletch, it's a byte ref [1]
        extwl	$22, $4, $5 	# [1]
        beq	$1, G13914	# [0di]
        stl	$5, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
CASE_OTHERS_14:
        bis	$31, $31, $31 	# [0]
        cmpeq	$6, 2, $4 	# [1]
        cmpeq	$6, 3, $5 	# [1]
        bne	$4, CASE_2_9	# [0di]
        cmpeq	$6, 5, $4 	# [1]
        bne	$5, CASE_3_10	# [0di]
        cmpeq	$6, 1, $5 	# [1]
        bne	$4, CASE_5_11	# [0di]
        bne	$5, CASE_1_12	# [1]
.align 3
CASE_4_13:
/* AREF1-2B */
        bis	$31, $31, $31 	# [0]
        and	$19, 15, $4 	# byte-index [1]
        sll	$4, 1, $4 	# byte-position [1]
        srl	$22, $4, $5 	# byte in position [2]
        and	$5, 3, $5 	# byte masked [2]
        beq	$1, G13914	# [0di]
        stl	$5, 0($12)	#  [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13908:
        addq	$7, $19, $19 	# [1-]
        srl	$19, $6, $1 	# Convert byte index to word index [1]
        addq	$1, $22, $1 	# Address of word containing byte [2]
        br	$31, G13909	# [0di]
.align 3
G13910:
        subq	$20, TypeFixnum, $1 	# [1-]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, G13915	# [1]
        br	$31, G13911	# [1]
.align 3
G13912:
        bis	$31, TypeCharacter, $20 	# [1-]
        blbs	$8, G13913	# [0di]
        bis	$31, TypeFixnum, $20 	# [1-]
        beq	$8, G13913	# [0di]
        ldq	$2, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        ldq	$3, PROCESSORSTATE_TADDRESS($14)	#  [1]
        br	$31, G13913	# [1]
.align 3
G13914:
        cmovne	$5, $3, $2 	# [2-]
        stq	$2, 0($12)	#  [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13915:
        bis	$31, $1, $20 	# [1-]
        bis	$31, 25, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
FASTAREF1IOP:
        bis	$31, 0, $20 	# [1]
        bis	$31, 32, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
FASTAREF1BOUNDS:
        bis	$31, 0, $20 	# [1]
        bis	$31, 13, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G13918:
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$2, $3, $2 	# reconstruct SCA [3]
        ldl	$22, 0($2)	#  [2]
        ldl	$20, 4($2)	# Read from stack cache [1]
        br	$31, G13917	# [1]
.align 3
G13920:
        blbc	$4, G13919	# [1]
        extll	$22, 0, $1 	# Do the indirect thing [0di]
        br	$31, G13916	# [1-]
.align 3
G13919:
        ldq	$5, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $4 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$4, $5, $4 	# Adjust for a longword load [2di]
        ldl	$5, 0($4)	# Get the memory action [2]
.align 3
G13924:
        and	$5, MemoryActionTransform, $4 	# [3]
        beq	$4, G13923	# [1]
        bic	$20, 63, $20 	# [1-]
        bis	$20, TypeExternalValueCellPointer, $20 	# [1]
        br	$31, G13927	# [1-]
#ifndef MINIMA
G13923:
#endif
#ifdef MINIMA
.align 3
G13923:
        and	$5, MemoryActionBinding, $4 	# [1-]
        ldq	$3, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$4, G13922	# [1-]
        sll	$1, 1, $2 	# [0di]
        ldq	$4, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$2, $3, $2 	# Hash index [1di]
        bis	$31, 1, $3 	# [1]
        sll	$3, IvoryMemoryData, $3 	# [1]
        addl	$2, $4, $2 	# [1]
        extll	$2, 0, $2 	# Clear sign-extension [1]
        s4addq	$2, $3, $3 	# [2]
        ldl	$2, 0($3)	# Fetch the key [2]
        ldl	$22, 4($3)	# Fetch value [1]
        subl	$1, $2, $4 	# Compare [2di]
        bne	$4, G13926	# Trap on miss [1]
        extll	$22, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G13916	# This is another memory read tailcall. [1-]
.align 3
G13926:
	br	$31, DBCACHEMISSTRAP
#endif
G13922:
/* Perform memory action */
        bis	$31, $5, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
#ifdef TRACING
	.byte 0x82
	.asciiz "DoFastAref1IM"
#endif
DoFastAref1IM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoFastAref1.
.end DoFastAref1
/* End of Halfword operand from stack instruction - DoFastAref1 */
.align 5
.globl DoRplaca
.ent DoRplaca 0
/* Halfword operand from stack instruction - DoRplaca */
	.globl DoRplacaFP
	.globl DoRplacaSP
	.globl DoRplacaLP
	.globl DoRplacaIM
.align 3
DoRplaca:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoRplacaIM"
#endif
.align 3
DoRplacaIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G13941:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoRplaca	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRplacaSP"
#endif
.align 3
DoRplacaSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, headDoRplaca	# [0di]
        bis	$21, $31, $16 	# SP-pop mode, TOS->arg1 [1-]
        ldq	$21, 0($19)	# Reload TOS [1]
        bis	$19, $31, $12 	# Adjust SP [1-]
        br	$31, beginDoRplaca	# [0di]
#ifdef TRACING
        br	$31, headDoRplaca	# [1]
	.byte 0x90
	.asciiz "DoRplacaLP"
#endif
.align 3
DoRplacaLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoRplaca	# [1]
	.byte 0x84
	.asciiz "DoRplacaFP"
#endif
.align 3
DoRplacaFP:	# Entry point for FP relative
.align 3
headDoRplaca:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoRplaca:
/* arg1 has the operand, sign extended if immediate. */
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$21, 4, $1 	# [1-]
        extll	$21, 0, $17 	# Read ARG1, the list [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
/* TagType. */
        and	$1, 63, $3 	# [1]
        subq	$3, TypeList, $4 	# [1]
        bic	$4, 4, $4 	# [1]
        bne	$4, RPLACAEXCEPTION	# [1]
.align 3
RplacStore:
        srl	$16, 32, $2 	# Tag for t2 [1-]
        extll	$16, 0, $16 	# data for t2 [1]
/* Memory Read Internal */
G13928:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13930	# [1-]
G13929:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13932	# [1-]
G13938:
/* Merge cdr-code */
        and	$2, 63, $21 	# [0di]
        and	$20, 192, $20 	# [1]
        bis	$20, $21, $20 	# [1]
        addq	$17, $14, $5 	# [1]
        s4addq	$5, $31, $21 	# [1]
        ldq_u	$7, 0($5)	#  [1-]
        subq	$17, $24, $6 	# Stack cache offset [0di]
        cmpult	$6, $25, $8 	# In range? [1]
        insbl	$20, $5, $6 	# [1]
        mskbl	$7, $5, $7 	# [1]
.align 3
G13940:
        bis	$7, $6, $7 	# [2]
        stq_u	$7, 0($5)	#  [0di]
        stl	$16, 0($21)	#  [1]
        bne	$8, G13939	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13939:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$17, $24, $6 	# Stack cache offset [0di]
        s8addq	$6, $5, $5 	# reconstruct SCA [3]
        stl	$16, 0($5)	# Store in stack [2]
        stl	$20, 4($5)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G13930:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$21, 0($5)	#  [2]
        ldl	$20, 4($5)	# Read from stack cache [1]
        br	$31, G13929	# [1]
.align 3
G13932:
        blbc	$7, G13931	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13928	# [1-]
.align 3
G13931:
        ldq	$8, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $7 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
#ifndef MINIMA
G13935:
#endif
#ifdef MINIMA
.align 3
G13935:
        and	$8, MemoryActionBinding, $7 	# [3]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G13934	# [1-]
        sll	$17, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$21, 4($6)	# Fetch value [1]
        subl	$17, $5, $7 	# Compare [2di]
        bne	$7, G13937	# Trap on miss [1]
        extll	$21, 0, $17 	# Extract the pointer, and indirect [0di]
        br	$31, G13928	# This is another memory read tailcall. [1-]
.align 3
G13937:
	br	$31, DBCACHEMISSTRAP
#endif
G13934:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoRplaca
/* End of Halfword operand from stack instruction - DoRplaca */
.align 5
.globl MemoryReadWrite
.ent MemoryReadWrite 0
.align 3
MemoryReadWrite:
	.frame $30, 0, $0
/* Memory Read Internal */
G13942:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13944	# [1-]
G13943:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        extll	$21, 0, $21 	# [1]
        blbs	$8, G13946	# [0di]
G13951:
        ret	$31, ($0), 1	# [1]
.align 3
MemoryReadWriteDECODE:
        beq	$6, G13945	# [1]
.align 3
G13944:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$21, 0($5)	#  [2]
        ldl	$20, 4($5)	# Read from stack cache [1]
        br	$31, G13943	# [1]
.align 3
G13946:
        blbc	$7, G13945	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13942	# [1-]
.align 3
G13945:
        ldq	$8, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$20, 63, $7 	# Discard the CDR code [0di]
        stq	$17, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
#ifndef MINIMA
G13948:
#endif
#ifdef MINIMA
.align 3
G13948:
        and	$8, MemoryActionBinding, $7 	# [3]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G13947	# [1-]
        sll	$17, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$21, 4($6)	# Fetch value [1]
        subl	$17, $5, $7 	# Compare [2di]
        bne	$7, G13950	# Trap on miss [1]
        extll	$21, 0, $17 	# Extract the pointer, and indirect [0di]
        br	$31, G13942	# This is another memory read tailcall. [1-]
.align 3
G13950:
	br	$31, DBCACHEMISSTRAP
#endif
G13947:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end MemoryReadWrite
.align 5
.globl DoRplacd
.ent DoRplacd 0
/* Halfword operand from stack instruction - DoRplacd */
	.globl DoRplacdFP
	.globl DoRplacdSP
	.globl DoRplacdLP
	.globl DoRplacdIM
.align 3
DoRplacd:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x83
	.asciiz "DoRplacdIM"
#endif
.align 3
DoRplacdIM:	# Entry point for IMMEDIATE mode
/* This sequence only sucks a moderate amount */
        sll	$17, 56, $17 	# sign extend the byte argument. [1]
.align 3
G13962:
        sra	$17, 56, $17 	# Rest of sign extension [2]
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoRplacd	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRplacdSP"
#endif
.align 3
DoRplacdSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, headDoRplacd	# [0di]
        bis	$21, $31, $16 	# SP-pop mode, TOS->arg1 [1-]
        ldq	$21, 0($19)	# Reload TOS [1]
        bis	$19, $31, $12 	# Adjust SP [1-]
        br	$31, beginDoRplacd	# [0di]
#ifdef TRACING
        br	$31, headDoRplacd	# [1]
	.byte 0x90
	.asciiz "DoRplacdLP"
#endif
.align 3
DoRplacdLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoRplacd	# [1]
	.byte 0x84
	.asciiz "DoRplacdFP"
#endif
.align 3
DoRplacdFP:	# Entry point for FP relative
.align 3
headDoRplacd:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoRplacd:
/* arg1 has the operand, sign extended if immediate. */
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$21, 4, $1 	# [1-]
        extll	$21, 0, $17 	# Read ARG1, the list [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
/* TagType. */
        and	$1, 63, $3 	# [1]
        subq	$3, TypeLocative, $4 	# [1]
        beq	$4, RplacStore	# [1]
        subq	$3, TypeList, $4 	# [1]
        bne	$4, RPLACDEXCEPTION	# [1]
/* Memory Read Internal */
G13952:
        addq	$17, $14, $7 	# [1-]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_CDR_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G13954	# [1-]
G13953:
        lda	$7, 192	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G13956	# [1-]
G13961:
/* TagCdr. */
        srl	$20, 6, $20 	# [0di]
        subq	$20, CdrNormal, $20 	# [2]
        bne	$20, RPLACDEXCEPTION	# J. if CDR coded [1]
        addq	$17, 1, $17 	# address of CDR [1-]
        br	$31, RplacStore	# [0di]
.align 3
G13956:
        blbc	$7, G13955	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G13952	# [1-]
.align 3
G13955:
.align 3
G13954:
	bsr	$0, MemoryReadCdrDECODE
        br	$31, G13961	# [1]
.end DoRplacd
/* End of Halfword operand from stack instruction - DoRplacd */
.align 5
.globl DoBranchTrueAndExtraPop
.ent DoBranchTrueAndExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueAndExtraPop */
	.globl DoBranchTrueAndExtraPopFP
	.globl DoBranchTrueAndExtraPopSP
	.globl DoBranchTrueAndExtraPopLP
	.globl DoBranchTrueAndExtraPopIM
.align 3
DoBranchTrueAndExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueAndExtraPop"
#endif
.align 3
DoBranchTrueAndExtraPopIM:
.align 3
DoBranchTrueAndExtraPopSP:
.align 3
DoBranchTrueAndExtraPopLP:
.align 3
DoBranchTrueAndExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, DoBrPopExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrPopExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 16, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueAndExtraPop
/* End of Halfword operand from stack instruction - DoBranchTrueAndExtraPop */
.align 5
.globl DoBranchFalseAndExtraPop
.ent DoBranchFalseAndExtraPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseAndExtraPop */
	.globl DoBranchFalseAndExtraPopFP
	.globl DoBranchFalseAndExtraPopSP
	.globl DoBranchFalseAndExtraPopLP
	.globl DoBranchFalseAndExtraPopIM
.align 3
DoBranchFalseAndExtraPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseAndExtraPop"
#endif
.align 3
DoBranchFalseAndExtraPopIM:
.align 3
DoBranchFalseAndExtraPopSP:
.align 3
DoBranchFalseAndExtraPopLP:
.align 3
DoBranchFalseAndExtraPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, DoBrnPopExtraPop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrnPopExtraPop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 16, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseAndExtraPop
/* End of Halfword operand from stack instruction - DoBranchFalseAndExtraPop */
.align 5
.globl DoBranchTrueAndNoPop
.ent DoBranchTrueAndNoPop 0
/* Halfword 10 bit immediate instruction - DoBranchTrueAndNoPop */
	.globl DoBranchTrueAndNoPopFP
	.globl DoBranchTrueAndNoPopSP
	.globl DoBranchTrueAndNoPopLP
	.globl DoBranchTrueAndNoPopIM
.align 3
DoBranchTrueAndNoPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchTrueAndNoPop"
#endif
.align 3
DoBranchTrueAndNoPopIM:
.align 3
DoBranchTrueAndNoPopSP:
.align 3
DoBranchTrueAndNoPopLP:
.align 3
DoBranchTrueAndNoPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, DoBrElsePop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrElsePop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        addq	$9, $16, $9 	# Update the PC in halfwords [0di]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [1-]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchTrueAndNoPop
/* End of Halfword operand from stack instruction - DoBranchTrueAndNoPop */
.align 5
.globl DoBranchFalseAndNoPop
.ent DoBranchFalseAndNoPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseAndNoPop */
	.globl DoBranchFalseAndNoPopFP
	.globl DoBranchFalseAndNoPopSP
	.globl DoBranchFalseAndNoPopLP
	.globl DoBranchFalseAndNoPopIM
.align 3
DoBranchFalseAndNoPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseAndNoPop"
#endif
.align 3
DoBranchFalseAndNoPopIM:
.align 3
DoBranchFalseAndNoPopSP:
.align 3
DoBranchFalseAndNoPopLP:
.align 3
DoBranchFalseAndNoPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        beq	$1, DoBrnElsePop	# [1]
/* Here if branch not taken.  Pop the argument. */
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        subq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
DoBrnElsePop:	# Here to take the branch
        beq	$16, BranchException	# Can't branch to ourself [1]
        addq	$9, $16, $9 	# Update the PC in halfwords [0di]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [1-]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseAndNoPop
/* End of Halfword operand from stack instruction - DoBranchFalseAndNoPop */
.align 5
.globl DoBranchFalseElseNoPop
.ent DoBranchFalseElseNoPop 0
/* Halfword 10 bit immediate instruction - DoBranchFalseElseNoPop */
	.globl DoBranchFalseElseNoPopFP
	.globl DoBranchFalseElseNoPopSP
	.globl DoBranchFalseElseNoPopLP
	.globl DoBranchFalseElseNoPopIM
.align 3
DoBranchFalseElseNoPop:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA1
	.asciiz "DoBranchFalseElseNoPop"
#endif
.align 3
DoBranchFalseElseNoPopIM:
.align 3
DoBranchFalseElseNoPopSP:
.align 3
DoBranchFalseElseNoPopLP:
.align 3
DoBranchFalseElseNoPopFP:
/* arg1 has signed operand preloaded. */
        extll	$21, 4, $1 	# Check tag of word in TOS. [1-]
#ifndef CACHEMETERING
        ldq	$17, CACHELINE_ANNOTATION($13)	#  [0di]
#endif
        sra	$18, 48, $16 	# Get signed 10-bit immediate arg [1-]
/* TagType. */
        and	$1, 63, $1 	# strip the cdr code off. [1]
        subq	$1, TypeNIL, $1 	# Compare to NIL [1]
        bne	$1, NEXTINSTRUCTION	# [1]
        beq	$16, BranchException	# Can't branch to ourself [1]
        subq	$12, 8, $12 	# [0di]
        addq	$9, $16, $9 	# Update the PC in halfwords [1]
#ifndef CACHEMETERING
        bne	$17, INTERPRETINSTRUCTIONPREDICTED	# [0di]
#endif
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# [1]
.end DoBranchFalseElseNoPop
/* End of Halfword operand from stack instruction - DoBranchFalseElseNoPop */
.align 5
.globl DoEqualNumber
.ent DoEqualNumber 0
/* Halfword operand from stack instruction - DoEqualNumber */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoEqualNumberFP
	.globl DoEqualNumberSP
	.globl DoEqualNumberLP
	.globl DoEqualNumberIM
.align 3
DoEqualNumber:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoEqualNumberSP"
#endif
.align 3
DoEqualNumberSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoEqualNumber	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoEqualNumber	# [0di]
	.byte 0x90
	.asciiz "DoEqualNumberLP"
#endif
.align 3
DoEqualNumberLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoEqualNumber	# [1]
	.byte 0x84
	.asciiz "DoEqualNumberFP"
#endif
.align 3
DoEqualNumberFP:	# Entry point for FP relative
.align 3
beginDoEqualNumber:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        srl	$18, 12, $7 	# [1-]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        extll	$21, 4, $18 	# Get ARG1 tag [1-]
        ldl	$1, 4($16)	# t1 is tag of arg2 [0di]
        lds	$f1, 0($12)	#  [1]
        and	$7, 1, $7 	# [0di]
        ldl	$17, 0($16)	#  [1-]
        addl	$21, $31, $19 	# [0di]
        lds	$f2, 0($16)	#  [1-]
        and	$18, 63, $5 	# Strip off any CDR code bits. [0di]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G13980:
        beq	$6, G13968	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G13972:
        beq	$3, G13963	# [1]
/* Here if argument TypeFixnum */
        subl	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# Pop/No-pop [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmoveq	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G13969:
.align 3
G13968:
        cmpeq	$5, TypeSingleFloat, $6 	# [1-]
.align 3
G13981:
        beq	$6, G13973	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$4, TypeSingleFloat, $3 	# [0di]
.align 3
G13977:
        beq	$3, G13963	# [1]
/* Here if argument TypeSingleFloat */
.align 3
EqualNumberMMExcFLTFLT:
        cmpteq	$f1, $f2, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        stq	$25, 0($12)	#  [1]
        fbne	$f3, CACHEVALID	# [3-]
        stq	$24, 0($12)	# Didn't branch, answer is NIL [0di]
        br	$31, CACHEVALID	# [1]
.align 3
G13974:
.align 3
G13973:
/* Here for all other cases */
.align 3
G13963:
        br	$31, EqualNumberMMExc	# [1]
.align 3
G13967:
#ifdef TRACING
        br	$31, DoEqualNumberIM	# [1]
	.byte 0x82
	.asciiz "DoEqualNumberIM"
#endif
.align 5
.align 3
DoEqualNumberIM:	# Entry point for IMMEDIATE mode
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$17, 56, $17 	# First half of sign extension [0di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        srl	$18, 12, $7 	# [0di]
        extll	$21, 4, $18 	# [1]
        addl	$21, $31, $19 	# [1]
        sra	$17, 56, $17 	# Second half of sign extension [1]
        and	$7, 1, $7 	# [1]
        and	$18, 63, $3 	# Strip off any CDR code bits. [1]
        cmpeq	$3, TypeFixnum, $4 	# [1]
.align 3
G13986:
        beq	$4, G13983	# [1]
/* Here if argument TypeFixnum */
        subl	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmoveq	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G13983:
/* Here for all other cases */
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G13982:
.end DoEqualNumber
/* End of Halfword operand from stack instruction - DoEqualNumber */
.align 5
.globl DoSetToCdrPushCar
.ent DoSetToCdrPushCar 0
/* Halfword operand from stack instruction - DoSetToCdrPushCar */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetToCdrPushCarFP
	.globl DoSetToCdrPushCarSP
	.globl DoSetToCdrPushCarLP
	.globl DoSetToCdrPushCarIM
.align 3
DoSetToCdrPushCar:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetToCdrPushCarSP"
#endif
.align 3
DoSetToCdrPushCarSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetToCdrPushCar	# [0di]
	.byte 0x90
	.asciiz "DoSetToCdrPushCarLP"
#endif
.align 3
DoSetToCdrPushCarLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetToCdrPushCar	# [1]
	.byte 0x84
	.asciiz "DoSetToCdrPushCarFP"
#endif
.align 3
DoSetToCdrPushCarFP:	# Entry point for FP relative
.align 3
beginDoSetToCdrPushCar:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$2, 0($16)	# Get the operand from the stack. [1]
        ldl	$1, 4($16)	#  [1]
        extll	$2, 0, $2 	# [2di]
        and	$1, 192, $3 	# Save the old CDR code [1]
        subq	$1, TypeLocative, $5 	# [1]
        and	$5, 63, $5 	# Strip CDR code [1]
        beq	$5, SETTOCDRPUSHCARLOCATIVE	# [1]
	bsr	$0, CarCdrInternal
/* TagType. */
        and	$20, 63, $20 	# [1-]
        bis	$20, $3, $20 	# Put back the original CDR codes [1]
        stl	$21, 0($16)	#  [1-]
        stl	$20, 4($16)	# write the stack cache [1]
        and	$1, 63, $5 	# set CDR-NEXT [1-]
        stl	$2, 8($12)	#  [0di]
        stl	$5, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetToCdrPushCarIM"
#endif
DoSetToCdrPushCarIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetToCdrPushCar.
.end DoSetToCdrPushCar
/* End of Halfword operand from stack instruction - DoSetToCdrPushCar */
.align 5
.globl DoSub
.ent DoSub 0
/* Halfword operand from stack instruction - DoSub */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSubFP
	.globl DoSubSP
	.globl DoSubLP
	.globl DoSubIM
.align 3
DoSub:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSubSP"
#endif
.align 3
DoSubSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoSub	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoSub	# [0di]
	.byte 0x90
	.asciiz "DoSubLP"
#endif
.align 3
DoSubLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSub	# [1]
	.byte 0x84
	.asciiz "DoSubFP"
#endif
.align 3
DoSubFP:	# Entry point for FP relative
.align 3
beginDoSub:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        lds	$f1, 0($12)	#  [0di]
        extll	$21, 4, $1 	# ARG1 tag [1-]
        ldl	$3, 4($16)	# ARG2 tag [1di]
        addl	$21, $31, $2 	# ARG1 data [1-]
        ldl	$4, 0($16)	# ARG2 data [0di]
        lds	$f2, 0($16)	#  [1]
        and	$1, 63, $22 	# Strip off any CDR code bits. [0di]
        and	$3, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$22, TypeFixnum, $23 	# [1]
.align 3
G14026:
        beq	$23, G13997	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$24, TypeFixnum, $25 	# [0di]
.align 3
G14003:
        beq	$25, G13999	# [1]
/* Here if argument TypeFixnum */
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [0di]
        sublv	$2, $4, $5 	# compute 64-bit result [1-]
        ldq	$7, CACHELINE_NEXTCP($13)	#  [0di]
        trapb			# Force the trap to occur here [3]
        stl	$22, 4($12)	# Semi-cheat, we know temp2 has CDRNext/TypeFixnum [1]
        bis	$6, $31, $9 	# [1-]
        stl	$5, 0($12)	#  [0di]
        bis	$7, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G13999:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14004:
        beq	$25, G14000	# [1]
/* Here if argument TypeSingleFloat */
        cvtlq	$f1, $f1 	# [1]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G13987	# [1]
.align 3
G14000:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G14005:
        beq	$25, G13994	# [1]
/* Here if argument TypeDoubleFloat */
        cvtlq	$f1, $f1 	# [3]
        cvtqt	$f1, $f1 	# [6]
        br	$31, G13990	# [1]
.align 3
G13998:
.align 3
G13997:
        cmpeq	$22, TypeSingleFloat, $23 	# [1-]
.align 3
G14027:
        beq	$23, G14006	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$24, TypeSingleFloat, $25 	# [0di]
.align 3
G14012:
        beq	$25, G14008	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G13987:
        subs	$f1, $f2, $f0 	# [2]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeSingleFloat, $8 	# [1-]
        stl	$8, 4($12)	# write the stack cache [0di]
        sts	$f0, 0($12)	#  [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14008:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14013:
        beq	$25, G14009	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G13987	# [1]
.align 3
G14009:
        cmpeq	$24, TypeDoubleFloat, $25 	# [1-]
.align 3
G14014:
        beq	$25, G13994	# [1]
/* Here if argument TypeDoubleFloat */
.align 3
G13990:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        br	$31, G13991	# [1]
.align 3
G14007:
.align 3
G14006:
        cmpeq	$22, TypeDoubleFloat, $23 	# [1-]
.align 3
G14028:
        beq	$23, G14015	# [1]
/* Here if argument TypeDoubleFloat */
        cmpeq	$24, TypeDoubleFloat, $25 	# [0di]
.align 3
G14021:
        beq	$25, G14017	# [1]
/* Here if argument TypeDoubleFloat */
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [0di]
	bsr	$0, FetchDoubleFloat
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [1-]
.align 3
G13991:
        extll	$4, 0, $17 	# [1-]
	bsr	$0, FetchDoubleFloat
        ldt	$f2, PROCESSORSTATE_FP0($14)	#  [0di]
.align 3
G13988:
        subt	$f1, $f2, $f0 	# [3]
        stt	$f0, PROCESSORSTATE_FP0($14)	#  [0di]
	bsr	$0, ConsDoubleFloat
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeDoubleFloat, $8 	# [1-]
        stl	$17, 0($12)	#  [0di]
        stl	$8, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14017:
        cmpeq	$24, TypeSingleFloat, $25 	# [1-]
.align 3
G14022:
        beq	$25, G14018	# [1]
/* Here if argument TypeSingleFloat */
.align 3
G13989:
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        extll	$2, 0, $17 	# [1-]
	bsr	$0, FetchDoubleFloat
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [0di]
        br	$31, G13988	# [1]
.align 3
G14018:
        cmpeq	$24, TypeFixnum, $25 	# [1-]
.align 3
G14023:
        beq	$25, G13994	# [1]
/* Here if argument TypeFixnum */
        cvtlq	$f2, $f2 	# [1]
        cvtqt	$f2, $f2 	# [6]
        br	$31, G13989	# [1]
.align 3
G14016:
.align 3
G14015:
/* Here for all other cases */
.align 3
G13993:
.align 3
DOSUBOVFL:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
        br	$31, G13995	# [1-]
.align 3
G13994:
        bis	$3, $31, $1 	# [1-]
        br	$31, DOSUBOVFL	# [0di]
.align 3
G13995:
.align 3
G13996:
#ifdef TRACING
        br	$31, DoSubIM	# [1]
	.byte 0x82
	.asciiz "DoSubIM"
#endif
.align 5
.align 3
DoSubIM:	# Entry point for IMMEDIATE mode
        extll	$21, 4, $1 	# [1-]
        addl	$21, $31, $2 	# get ARG1 tag/data [1]
        and	$1, 63, $24 	# Strip off any CDR code bits. [1]
        cmpeq	$24, TypeFixnum, $25 	# [1]
.align 3
G14033:
        beq	$25, G14030	# [1]
/* Here if argument TypeFixnum */
        subq	$2, $17, $3 	# compute 64-bit result [0di]
        ldq	$4, CACHELINE_NEXTPCDATA($13)	#  [1-]
        addl	$3, $31, $23 	# compute 32-bit sign-extended result [0di]
        ldq	$5, CACHELINE_NEXTCP($13)	#  [1-]
        cmpeq	$3, $23, $23 	# is it the same as the 64-bit result? [0di]
        beq	$23, DOSUBOVFL	# if not, we overflowed [1]
        stl	$24, 4($12)	# Semi-cheat, we know temp2 has CDRNext/TypeFixnum [1]
        bis	$4, $31, $9 	# [1-]
        stl	$3, 0($12)	#  [0di]
        bis	$5, $31, $13 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G14030:
/* Here for all other cases */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        bis	$31, $31, $17 	# [1]
        br	$31, beginDoSub	# [0di]
.align 3
G14029:
.end DoSub
/* End of Halfword operand from stack instruction - DoSub */
.align 5
.globl DoTag
.ent DoTag 0
/* Halfword operand from stack instruction - DoTag */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoTagFP
	.globl DoTagSP
	.globl DoTagLP
	.globl DoTagIM
.align 3
DoTag:
/* arg2 has the preloaded 8 bit operand. */
#ifdef TRACING
	.byte 0x82
	.asciiz "DoTagIM"
#endif
.align 3
DoTagIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        lda	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
        bis	$31, $31, $17 	# [1]
        br	$31, beginDoTag	# [0di]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoTagSP"
#endif
.align 3
DoTagSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoTag	# [0di]
	.byte 0x90
	.asciiz "DoTagLP"
#endif
.align 3
DoTagLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoTag	# [1]
	.byte 0x84
	.asciiz "DoTagFP"
#endif
.align 3
DoTagFP:	# Entry point for FP relative
.align 3
beginDoTag:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldl	$16, 4($16)	# Get the tag of the operand [2]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeFixnum, $3 	# [1-]
        stl	$3, 12($12)	# write the stack cache [0di]
        stl	$16, 8($12)	#  [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.end DoTag
/* End of Halfword operand from stack instruction - DoTag */
.align 5
.globl DoEndp
.ent DoEndp 0
/* Halfword operand from stack instruction - DoEndp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoEndpFP
	.globl DoEndpSP
	.globl DoEndpLP
	.globl DoEndpIM
.align 3
DoEndp:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoEndpSP"
#endif
.align 3
DoEndpSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoEndp	# [0di]
	.byte 0x90
	.asciiz "DoEndpLP"
#endif
.align 3
DoEndpLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoEndp	# [1]
	.byte 0x84
	.asciiz "DoEndpFP"
#endif
.align 3
DoEndpFP:	# Entry point for FP relative
.align 3
beginDoEndp:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldl	$17, 4($16)	# Get tag. [2]
        ldq	$2, PROCESSORSTATE_TADDRESS($14)	#  [1]
/* TagType. */
        and	$17, 63, $17 	# [2-]
        subq	$17, TypeNIL, $6 	# Compare [1]
        bne	$6, ENDPNOTNIL	# [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$2, 8($12)	#  [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
ENDPNIL:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stq	$1, 8($12)	#  [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
ENDPNOTNIL:
        subq	$6, 1, $6 	# Now check for list [1-]
        beq	$6, ENDPNIL	# [1]
        subq	$17, TypeListInstance, $6 	# [1]
        beq	$6, ENDPNIL	# [1]
#ifdef TRACING
        br	$31, DoEndpIM	# [1]
	.byte 0x82
	.asciiz "DoEndpIM"
#endif
.align 5
.align 3
DoEndpIM:	# Entry point for IMMEDIATE mode
        bis	$31, 0, $20 	# [1-]
        bis	$31, 64, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoEndp
/* End of Halfword operand from stack instruction - DoEndp */
.align 5
.globl DoMinusp
.ent DoMinusp 0
/* Halfword operand from stack instruction - DoMinusp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMinuspFP
	.globl DoMinuspSP
	.globl DoMinuspLP
	.globl DoMinuspIM
.align 3
DoMinusp:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMinuspSP"
#endif
.align 3
DoMinuspSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoMinusp	# [0di]
	.byte 0x90
	.asciiz "DoMinuspLP"
#endif
.align 3
DoMinuspLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMinusp	# [1]
	.byte 0x84
	.asciiz "DoMinuspFP"
#endif
.align 3
DoMinuspFP:	# Entry point for FP relative
.align 3
beginDoMinusp:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldl	$1, 4($16)	#  [1]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1]
        ldl	$2, 0($16)	#  [1]
        lds	$f1, 0($16)	#  [1]
        and	$1, 63, $4 	# Strip off any CDR code bits. [0di]
        cmpeq	$4, TypeFixnum, $5 	# [1]
.align 3
G14039:
        beq	$5, G14035	# [1]
/* Here if argument TypeFixnum */
        bis	$6, $31, $9 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovlt	$2, $25, $24 	# T if predicate succeeds [0di]
        stq	$24, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
G14035:
        cmpeq	$4, TypeSingleFloat, $5 	# [1-]
.align 3
G14040:
        beq	$5, G14036	# [1]
/* Here if argument TypeSingleFloat */
        bis	$6, $31, $9 	# [0di]
        stq	$25, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        fblt	$f1, CACHEVALID	# [0di]
        stq	$24, 0($12)	# Didn't branch, answer is NIL [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G14036:
/* Here for all other cases */
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, UNARYNUMERICEXCEPTION
.align 3
G14034:
#ifdef TRACING
        br	$31, DoMinuspIM	# [1-]
	.byte 0x82
	.asciiz "DoMinuspIM"
#endif
.align 5
.align 3
DoMinuspIM:	# Entry point for IMMEDIATE mode
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$17, 56, $17 	# Turned into a signed number [0di]
        ldq	$2, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        cmovlt	$17, $2, $1 	# stall 2 then di [1-]
        stq	$1, 0($12)	# yes Virginia, we dual issue with above yahoo [0di]
        br	$31, CACHEVALID	# [1]
.end DoMinusp
/* End of Halfword operand from stack instruction - DoMinusp */
.align 5
.globl DoPlusp
.ent DoPlusp 0
/* Halfword operand from stack instruction - DoPlusp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPluspFP
	.globl DoPluspSP
	.globl DoPluspLP
	.globl DoPluspIM
.align 3
DoPlusp:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPluspSP"
#endif
.align 3
DoPluspSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoPlusp	# [0di]
	.byte 0x90
	.asciiz "DoPluspLP"
#endif
.align 3
DoPluspLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoPlusp	# [1]
	.byte 0x84
	.asciiz "DoPluspFP"
#endif
.align 3
DoPluspFP:	# Entry point for FP relative
.align 3
beginDoPlusp:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        ldq	$6, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldl	$1, 4($16)	#  [1]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1]
        ldl	$2, 0($16)	#  [1]
        lds	$f1, 0($16)	#  [1]
        and	$1, 63, $4 	# Strip off any CDR code bits. [0di]
        cmpeq	$4, TypeFixnum, $5 	# [1]
.align 3
G14046:
        beq	$5, G14042	# [1]
/* Here if argument TypeFixnum */
        bis	$6, $31, $9 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovgt	$2, $25, $24 	# T if predicate succeeds [0di]
        stq	$24, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
G14042:
        cmpeq	$4, TypeSingleFloat, $5 	# [1-]
.align 3
G14047:
        beq	$5, G14043	# [1]
/* Here if argument TypeSingleFloat */
        bis	$6, $31, $9 	# [0di]
        stq	$25, 8($12)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        fbgt	$f1, CACHEVALID	# [0di]
        stq	$24, 0($12)	# Didn't branch, answer is NIL [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G14043:
/* Here for all other cases */
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, UNARYNUMERICEXCEPTION
.align 3
G14041:
#ifdef TRACING
        br	$31, DoPluspIM	# [1-]
	.byte 0x82
	.asciiz "DoPluspIM"
#endif
.align 5
.align 3
DoPluspIM:	# Entry point for IMMEDIATE mode
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$17, 56, $17 	# Turned into a signed number [0di]
        ldq	$2, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        addq	$12, 8, $12 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        cmovgt	$17, $2, $1 	# stall 2 then di [1-]
        stq	$1, 0($12)	# yes Virginia, we dual issue with above yahoo [0di]
        br	$31, CACHEVALID	# [1]
.end DoPlusp
/* End of Halfword operand from stack instruction - DoPlusp */
.align 5
.globl DoLessp
.ent DoLessp 0
/* Halfword operand from stack instruction - DoLessp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoLesspFP
	.globl DoLesspSP
	.globl DoLesspLP
	.globl DoLesspIM
.align 3
DoLessp:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoLesspSP"
#endif
.align 3
DoLesspSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoLessp	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoLessp	# [0di]
	.byte 0x90
	.asciiz "DoLesspLP"
#endif
.align 3
DoLesspLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoLessp	# [1]
	.byte 0x84
	.asciiz "DoLesspFP"
#endif
.align 3
DoLesspFP:	# Entry point for FP relative
.align 3
beginDoLessp:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [0di]
        srl	$18, 12, $7 	# [1-]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        extll	$21, 4, $18 	# Get ARG1 tag [1-]
        ldl	$1, 4($16)	# t1 is tag of arg2 [0di]
        lds	$f1, 0($12)	#  [1]
        and	$7, 1, $7 	# [0di]
        ldl	$17, 0($16)	#  [1-]
        addl	$21, $31, $19 	# [0di]
        lds	$f2, 0($16)	#  [1-]
        and	$18, 63, $5 	# Strip off any CDR code bits. [0di]
        and	$1, 63, $4 	# Strip off any CDR code bits. [1]
        cmpeq	$5, TypeFixnum, $6 	# [1]
.align 3
G14065:
        beq	$6, G14053	# [1]
/* Here if argument TypeFixnum */
        cmpeq	$4, TypeFixnum, $3 	# [0di]
.align 3
G14057:
        beq	$3, G14048	# [1]
/* Here if argument TypeFixnum */
        subq	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# Pop/No-pop [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovlt	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G14054:
.align 3
G14053:
        cmpeq	$5, TypeSingleFloat, $6 	# [1-]
.align 3
G14066:
        beq	$6, G14058	# [1]
/* Here if argument TypeSingleFloat */
        cmpeq	$4, TypeSingleFloat, $3 	# [0di]
.align 3
G14062:
        beq	$3, G14048	# [1]
/* Here if argument TypeSingleFloat */
.align 3
LesspMMExcFLTFLT:
        cmptlt	$f1, $f2, $f3 	# [1]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        stq	$25, 0($12)	#  [1]
        fbne	$f3, CACHEVALID	# [3-]
        stq	$24, 0($12)	# Didn't branch, answer is NIL [0di]
        br	$31, CACHEVALID	# [1]
.align 3
G14059:
.align 3
G14058:
/* Here for all other cases */
.align 3
G14048:
        br	$31, LesspMMExc	# [1]
.align 3
G14052:
#ifdef TRACING
        br	$31, DoLesspIM	# [1]
	.byte 0x82
	.asciiz "DoLesspIM"
#endif
.align 5
.align 3
DoLesspIM:	# Entry point for IMMEDIATE mode
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        sll	$17, 56, $17 	# First half of sign extension [0di]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [1-]
        srl	$18, 12, $7 	# [0di]
        extll	$21, 4, $18 	# [1]
        addl	$21, $31, $19 	# [1]
        sra	$17, 56, $17 	# Second half of sign extension [1]
        and	$7, 1, $7 	# [1]
        and	$18, 63, $3 	# Strip off any CDR code bits. [1]
        cmpeq	$3, TypeFixnum, $4 	# [1]
.align 3
G14071:
        beq	$4, G14068	# [1]
/* Here if argument TypeFixnum */
        subq	$19, $17, $2 	# [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        s8addq	$7, $12, $12 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmovlt	$2, $25, $24 	# T if the test succeeds [0di]
        stq	$24, 0($12)	#  [1-]
        br	$31, CACHEVALID	# [1]
.align 3
G14068:
/* Here for all other cases */
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
G14067:
.end DoLessp
/* End of Halfword operand from stack instruction - DoLessp */
.align 5
.globl DoDecrement
.ent DoDecrement 0
/* Halfword operand from stack instruction - DoDecrement */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoDecrementFP
	.globl DoDecrementSP
	.globl DoDecrementLP
	.globl DoDecrementIM
.align 3
DoDecrement:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoDecrementSP"
#endif
.align 3
DoDecrementSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoDecrement	# [0di]
	.byte 0x90
	.asciiz "DoDecrementLP"
#endif
.align 3
DoDecrementLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoDecrement	# [1]
	.byte 0x84
	.asciiz "DoDecrementFP"
#endif
.align 3
DoDecrementFP:	# Entry point for FP relative
.align 3
beginDoDecrement:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$18, 0($16)	# read tag/data of arg1 [2]
        ldl	$17, 4($16)	#  [1]
        extll	$18, 0, $18 	# [2di]
        and	$17, 63, $1 	# Strip off any CDR code bits. [1]
        cmpeq	$1, TypeFixnum, $2 	# [1]
.align 3
G14077:
        beq	$2, G14073	# [1]
/* Here if argument TypeFixnum */
        ldq	$2, PROCESSORSTATE_MOSTNEGATIVEFIXNUM($14)	#  [1]
        subq	$18, 1, $3 	# [1-]
        cmpeq	$18, $2, $2 	# [2]
        bne	$2, DECREMENTEXCEPTION	# [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$3, 0($16)	#  [1]
        stl	$17, 4($16)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14073:
        cmpeq	$1, TypeSingleFloat, $2 	# [1-]
.align 3
G14078:
        beq	$2, G14074	# [1]
/* Here if argument TypeSingleFloat */
        lds	$f1, 0($16)	# Get the floating data [0di]
        lds	$f2, PROCESSORSTATE_SFP1($14)	# constant 1.0 [1]
        subs	$f1, $f2, $f0 	# [3]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        sts	$f0, 0($16)	# Put the floating result [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14074:
/* Here for all other cases */
        br	$31, DECREMENTEXCEPTION	# [1]
.align 3
G14072:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoDecrementIM"
#endif
DoDecrementIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoDecrement.
.end DoDecrement
/* End of Halfword operand from stack instruction - DoDecrement */
.align 5
.globl DoMergeCdrNoPop
.ent DoMergeCdrNoPop 0
/* Halfword operand from stack instruction - DoMergeCdrNoPop */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMergeCdrNoPopFP
	.globl DoMergeCdrNoPopSP
	.globl DoMergeCdrNoPopLP
	.globl DoMergeCdrNoPopIM
.align 3
DoMergeCdrNoPop:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMergeCdrNoPopSP"
#endif
.align 3
DoMergeCdrNoPopSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoMergeCdrNoPop	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoMergeCdrNoPop	# [0di]
	.byte 0x90
	.asciiz "DoMergeCdrNoPopLP"
#endif
.align 3
DoMergeCdrNoPopLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMergeCdrNoPop	# [1]
	.byte 0x84
	.asciiz "DoMergeCdrNoPopFP"
#endif
.align 3
DoMergeCdrNoPopFP:	# Entry point for FP relative
.align 3
beginDoMergeCdrNoPop:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        ldl	$1, 4($16)	# Get the CDR CODE/TAG of arg2 [1]
        extll	$21, 4, $2 	# Get the CDR CODE/TAG of arg1 [1-]
.align 3
G14079:
        and	$2, 192, $2 	# Get Just the CDR code in position [2]
        and	$1, 63, $1 	# Get the TAG of arg1 [1]
        bis	$1, $2, $3 	# Merge the tag of arg2 with the cdr code of arg1 [1]
        stl	$3, 4($16)	# Replace tag/cdr code no pop [0di]
        br	$31, CACHEVALID	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoMergeCdrNoPopIM"
#endif
DoMergeCdrNoPopIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoMergeCdrNoPop.
.end DoMergeCdrNoPop
/* End of Halfword operand from stack instruction - DoMergeCdrNoPop */
.align 5
.globl DoEqImmediateHandler
.ent DoEqImmediateHandler 0
.align 3
DoEqImmediateHandler:
#ifdef TRACING
        br	$31, DoEqIM	# [1]
	.byte 0x82
	.asciiz "DoEqIM"
#endif
.align 5
.align 3
DoEqIM:	# Entry point for IMMEDIATE mode
        sll	$17, 56, $17 	# [1-]
        ldl	$4, 4($12)	# t4=tag t3=data [0di]
        ldl	$3, 0($12)	#  [1]
        srl	$18, 12, $18 	# [0di]
        ldq	$24, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        sra	$17, 56, $17 	# Sign extension of arg2 is complete [0di]
/* TagType. */
        and	$4, 63, $4 	# [1]
        ldq	$25, PROCESSORSTATE_TADDRESS($14)	#  [0di]
        and	$18, 1, $18 	# 1 if no-pop, 0 if pop [1-]
        subl	$3, $17, $17 	# [1]
        xor	$4, TypeFixnum, $4 	# [1]
        s8addq	$18, $12, $12 	# Either a stack-push or a stack-write [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        bis	$17, $4, $4 	# [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1-]
        cmoveq	$4, $25, $24 	# [0di]
        stq	$24, 0($12)	# Yes Virginia, this does dual issue with above [1-]
        br	$31, CACHEVALID	# [1]
.end DoEqImmediateHandler
.align 5
.globl DoIncrement
.ent DoIncrement 0
/* Halfword operand from stack instruction - DoIncrement */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoIncrementFP
	.globl DoIncrementSP
	.globl DoIncrementLP
	.globl DoIncrementIM
.align 3
DoIncrement:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoIncrementSP"
#endif
.align 3
DoIncrementSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoIncrement	# [0di]
	.byte 0x90
	.asciiz "DoIncrementLP"
#endif
.align 3
DoIncrementLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoIncrement	# [1]
	.byte 0x84
	.asciiz "DoIncrementFP"
#endif
.align 3
DoIncrementFP:	# Entry point for FP relative
.align 3
beginDoIncrement:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$18, 0($16)	# read tag/data of arg1 [2]
        ldl	$17, 4($16)	#  [1]
        extll	$18, 0, $18 	# [2di]
        and	$17, 63, $1 	# Strip off any CDR code bits. [1]
        cmpeq	$1, TypeFixnum, $2 	# [1]
.align 3
G14085:
        beq	$2, G14081	# [1]
/* Here if argument TypeFixnum */
        ldq	$2, PROCESSORSTATE_MOSTPOSITIVEFIXNUM($14)	#  [1]
        addq	$18, 1, $3 	# [1-]
        cmpeq	$18, $2, $2 	# [2]
        bne	$2, INCREMENTEXCEPTION	# [1]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$3, 0($16)	#  [1]
        stl	$17, 4($16)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14081:
        cmpeq	$1, TypeSingleFloat, $2 	# [1-]
.align 3
G14086:
        beq	$2, G14082	# [1]
/* Here if argument TypeSingleFloat */
        lds	$f1, 0($16)	# Get the floating data [0di]
        lds	$f2, PROCESSORSTATE_SFP1($14)	# constant 1.0 [1]
        adds	$f1, $f2, $f0 	# [3]
        trapb			# Force the trap to occur here [4]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        sts	$f0, 0($16)	# Put the floating result [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14082:
/* Here for all other cases */
        br	$31, INCREMENTEXCEPTION	# [1]
.align 3
G14080:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoIncrementIM"
#endif
DoIncrementIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoIncrement.
.end DoIncrement
/* End of Halfword operand from stack instruction - DoIncrement */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifuncom2.as */
