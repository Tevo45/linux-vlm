/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/idouble.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Support for double precision floating point. */
.align 5
.globl FetchDoubleFloat
.ent FetchDoubleFloat 11
.align 3
FetchDoubleFloat:
        lda	$30, -8($30)	#  [1]
	.frame $30, 8, $0
/* Memory Read Internal */
G16002:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G16004	# [0di]
G16003:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G16006	# [1di]
G16013:
        subq	$20, TypeFixnum, $5 	# [1-]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G16001	# [1]
        stl	$21, PROCESSORSTATE_FP0+4($14)	#  [1]
        addq	$17, 1, $17 	# [1-]
/* Memory Read Internal */
G16014:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G16016	# [0di]
G16015:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G16018	# [1di]
G16025:
        subq	$20, TypeFixnum, $5 	# [1-]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, G16001	# [1]
        stl	$21, PROCESSORSTATE_FP0($14)	#  [1]
        lda	$30, 8($30)	#  [1-]
        ret	$31, ($0), 1	# [0di]
.align 3
G16018:
        blbc	$7, G16017	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G16014	# [2-]
.align 3
G16017:
.align 3
G16016:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G16025	# [1]
.align 3
G16006:
        blbc	$7, G16005	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G16002	# [1-]
.align 3
G16005:
.align 3
G16004:
        stq	$0, 0($30)	#  [1]
	bsr	$0, MemoryReadDataDECODE
        ldq	$0, 0($30)	#  [1]
        br	$31, G16013	# [1]
.align 3
G16001:
        bis	$31, TypeDoubleFloat, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.end FetchDoubleFloat
.align 5
.globl ConsDoubleFloat
.ent ConsDoubleFloat 9
.align 3
ConsDoubleFloat:
        lda	$30, -8($30)	#  [1]
	.frame $30, 8, $0
        ldl	$21, PROCESSORSTATE_FP0($14)	#  [0di]
        ldl	$20, PROCESSORSTATE_FP0+4($14)	#  [1]
        ldq	$5, PROCESSORSTATE_LCAREA($14)	#  [1]
        ldq	$8, PROCESSORSTATE_NILADDRESS($14)	#  [1]
        ldl	$6, PROCESSORSTATE_LCLENGTH($14)	#  [1]
        ldq	$17, PROCESSORSTATE_LCADDRESS($14)	# Fetch address [1]
        cmpeq	$5, $8, $7 	# [1di]
        bne	$7, G16026	# Decached area [1]
        subq	$6, 2, $7 	# Effectively an unsigned 32-bit compare [1]
        blt	$7, G16026	# Insufficient cache [1]
        trapb			# Force the trap to occur here [1]
        stl	$7, PROCESSORSTATE_LCLENGTH($14)	# Store remaining length [1]
        extll	$17, 0, $8 	# [0di]
        addq	$8, 2, $8 	# Increment address [2]
        stl	$8, PROCESSORSTATE_LCADDRESS($14)	# Store updated address [0di]
        extll	$17, 0, $17 	# [1-]
        bis	$31, TypeFixnum, $22 	# [1]
        bis	$22, 128, $22 	# [1]
        addq	$17, $14, $5 	# [1]
        s4addq	$5, $31, $8 	# [1]
        ldq_u	$7, 0($5)	#  [1di]
        insbl	$22, $5, $6 	# [1-]
        mskbl	$7, $5, $7 	# [2]
.align 3
G16027:
        bis	$7, $6, $7 	# [2]
        stq_u	$7, 0($5)	#  [0di]
        stl	$20, 0($8)	#  [1]
        addq	$17, 1, $23 	# [0di]
        bis	$31, TypeFixnum, $22 	# [1]
        bis	$22, 64, $22 	# [1]
        addq	$23, $14, $5 	# [1]
        s4addq	$5, $31, $8 	# [1]
        ldq_u	$7, 0($5)	#  [1-]
        insbl	$22, $5, $6 	# [0di]
        mskbl	$7, $5, $7 	# [3]
.align 3
G16028:
        bis	$7, $6, $7 	# [2]
        stq_u	$7, 0($5)	#  [0di]
        stl	$21, 0($8)	#  [1]
        lda	$30, 8($30)	#  [0di]
        ret	$31, ($0), 1	# [1-]
.align 3
G16026:
        bis	$31, TypeDoubleFloat, $21 	# arg6 = tag to dispatch on [3]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 1, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.end ConsDoubleFloat
.align 5
.globl DoDoubleFloatOp
.ent DoDoubleFloatOp 0
/* Halfword operand from stack instruction - DoDoubleFloatOp */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoDoubleFloatOpFP
	.globl DoDoubleFloatOpSP
	.globl DoDoubleFloatOpLP
	.globl DoDoubleFloatOpIM
.align 3
DoDoubleFloatOp:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoDoubleFloatOpIM"
#endif
.align 3
DoDoubleFloatOpIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoDoubleFloatOp	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoDoubleFloatOpSP"
#endif
.align 3
DoDoubleFloatOpSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoDoubleFloatOp	# [0di]
	.byte 0x90
	.asciiz "DoDoubleFloatOpLP"
#endif
.align 3
DoDoubleFloatOpLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoDoubleFloatOp	# [1]
	.byte 0x84
	.asciiz "DoDoubleFloatOpFP"
#endif
.align 3
DoDoubleFloatOpFP:	# Entry point for FP relative
.align 3
headDoDoubleFloatOp:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoDoubleFloatOp:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$18, -24($12)	# X high [1]
        ldl	$19, -16($12)	# X low [1]
        ldl	$20, -8($12)	# Y high [1]
        ldl	$21, 0($12)	# Y low [1]
        sll	$18, 32, $18 	# Get high part up top [1-]
        extll	$19, 0, $19 	# [1]
        sll	$20, 32, $20 	# Get high part up top [1]
        extll	$21, 0, $21 	# [1]
        bis	$18, $19, $18 	# ARG3 is now X [1]
        bis	$20, $21, $20 	# ARG5 is now Y [1]
        stq	$18, PROCESSORSTATE_FP0($14)	#  [1-]
        stq	$20, PROCESSORSTATE_FP1($14)	#  [1]
        srl	$16, 32, $2 	# Immediate tag [1-]
        extll	$16, 0, $1 	# Immediate data [1]
        subq	$2, TypeFixnum, $3 	# [1]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, DOUBLEFLOATIOP	# [1]
        ldt	$f1, PROCESSORSTATE_FP0($14)	#  [0di]
        ldt	$f2, PROCESSORSTATE_FP1($14)	#  [1]
        lda	$3, DoubleFloatOpAdd	#  [0di]
        subq	$1, $3, $3 	# [1]
        bne	$3, G16030	# [1]
/* Here if argument DoubleFloatOpAdd */
        addt	$f1, $f2, $f1 	# [1]
        br	$31, G16029	# [1]
.align 3
G16030:
        lda	$3, DoubleFloatOpSub	#  [1-]
        subq	$1, $3, $3 	# [1]
        bne	$3, G16031	# [1]
/* Here if argument DoubleFloatOpSub */
        subt	$f1, $f2, $f1 	# [2]
        br	$31, G16029	# [1]
.align 3
G16031:
        lda	$3, DoubleFloatOpMultiply	#  [1-]
        subq	$1, $3, $3 	# [1]
        bne	$3, G16032	# [1]
/* Here if argument DoubleFloatOpMultiply */
        mult	$f1, $f2, $f1 	# [2]
        br	$31, G16029	# [1]
.align 3
G16032:
        lda	$3, DoubleFloatOpDivide	#  [1-]
        subq	$1, $3, $3 	# [1]
        bne	$3, G16033	# [1]
/* Here if argument DoubleFloatOpDivide */
        divt	$f1, $f2, $f1 	# [2]
        br	$31, G16029	# [1]
.align 3
G16033:
.align 3
G16029:
        trapb			# Force the trap to occur here [60]
        ldq	$3, PROCESSORSTATE_NILADDRESS($14)	# There was no FP exception [1]
DOUBLEFLOATMERGE:
        stt	$f1, PROCESSORSTATE_FP0($14)	#  [1]
        ldl	$1, PROCESSORSTATE_FP0($14)	#  [1]
        ldl	$2, PROCESSORSTATE_FP0+4($14)	#  [1]
        subq	$12, 32, $12 	# Pop all the operands [0di]
        bis	$31, TypeFixnum, $4 	# [1]
        stl	$2, 8($12)	# Push high result [1di]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$31, TypeFixnum, $4 	# [1]
        stl	$1, 8($12)	# Push low result [1di]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        addq	$12, 8, $12 	# [1]
        sll	$3, 26, $4 	# [1]
        srl	$4, 26, $4 	# [2]
        stq	$4, 0($12)	# Push the exception predicate [0di]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
DOUBLEFLOATEXC:
        ldq	$3, PROCESSORSTATE_TADDRESS($14)	# Indicate an FP exception occurred [1]
        br	$31, DOUBLEFLOATMERGE	# [1]
.align 3
DOUBLEFLOATIOP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 85, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoDoubleFloatOp
/* End of Halfword operand from stack instruction - DoDoubleFloatOp */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/idouble.as */
