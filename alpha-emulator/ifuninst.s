/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuninst.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Instance variable accessors.. */
.align 5
.globl DoPopInstanceVariable
.ent DoPopInstanceVariable 0
/* Halfword 10 bit immediate instruction - DoPopInstanceVariable */
	.globl DoPopInstanceVariableFP
	.globl DoPopInstanceVariableSP
	.globl DoPopInstanceVariableLP
	.globl DoPopInstanceVariableIM
.align 3
DoPopInstanceVariable:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoPopInstanceVariable"
#endif
.align 3
DoPopInstanceVariableIM:
.align 3
DoPopInstanceVariableSP:
.align 3
DoPopInstanceVariableLP:
.align 3
DoPopInstanceVariableFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Mapped */
        ldl	$16, 16($10)	# Map [1]
        ldl	$1, 20($10)	#  [1]
        extll	$16, 0, $16 	# [2di]
        subq	$1, TypeArray, $4 	# [1]
        and	$4, 63, $4 	# Strip CDR code [1]
        bne	$4, IVBADMAP	# [1]
/* Memory Read Internal */
G14349:
        addq	$16, $14, $22 	# [0di]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14351	# [0di]
G14350:
        lda	$22, 64	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        blbs	$23, G14353	# [1di]
G14358:
        and	$2, ArrayLengthMask, $2 	# [1-]
        subq	$2, $17, $5 	# [1]
        ble	$5, IVBADINDEX	# J. if mapping-table-index-out-of-bounds [1]
        addq	$16, $17, $16 	# [0di]
        addq	$16, 1, $16 	# [1]
/* Memory Read Internal */
G14359:
        addq	$16, $14, $22 	# [1]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14361	# [0di]
G14360:
        lda	$22, 240	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$23, G14363	# [1-]
G14370:
        bis	$2, $31, $3 	# [1di]
        subq	$1, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, POPIVIEX	# [1]
        ldl	$16, 24($10)	# Self [0di]
        ldl	$6, 28($10)	#  [1]
        extll	$16, 0, $16 	# [2di]
        subq	$6, TypeInstance, $5 	# [1]
        and	$5, 60, $5 	# Strip CDR code, low bits [1]
        bne	$5, IVBADINST	# [1]
        and	$6, 192, $5 	# Unshifted cdr code [1]
        subq	$5, 64, $5 	# Check for CDR code 1 [1]
        bne	$5, G14348	# J. if CDR code is not 1 [1]
.align 3
G14347:
        addq	$16, $3, $16 	# [1-]
.align 3
G14346:
        ldl	$1, 0($12)	#  [1-]
        ldl	$2, 4($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G14371:
        addq	$16, $14, $8 	# [1-]
        s4addq	$8, $31, $5 	# [1]
        ldq_u	$4, 0($8)	#  [1-]
        subq	$16, $20, $6 	# Stack cache offset [0di]
        ldq	$22, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [1-]
        cmpult	$6, $21, $7 	# In range? [0di]
        ldl	$5, 0($5)	#  [1-]
        extbl	$4, $8, $4 	# [1di]
        bne	$7, G14373	# [1-]
G14372:
        lda	$8, 240	#  [0di]
        srl	$22, $4, $22 	# [1]
        srl	$8, $4, $8 	# [1]
        blbs	$22, G14375	# [1-]
G14381:
/* Merge cdr-code */
        and	$2, 63, $5 	# [0di]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        addq	$16, $14, $6 	# [1]
        s4addq	$6, $31, $5 	# [1]
        ldq_u	$8, 0($6)	#  [1-]
        subq	$16, $20, $7 	# Stack cache offset [0di]
        cmpult	$7, $21, $22 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G14383:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$1, 0($5)	#  [1]
        bne	$22, G14382	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
POPIVIEX:
        lda	$1, 8	#  [1-]
/* SetTag. */
        sll	$1, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $2, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G14382:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        subq	$16, $20, $7 	# Stack cache offset [0di]
        s8addq	$7, $6, $6 	# reconstruct SCA [3]
        stl	$1, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14373:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G14372	# [1]
.align 3
G14375:
        blbc	$8, G14374	# [1]
        extll	$5, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14371	# [1-]
.align 3
G14374:
        ldq	$22, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $8 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $22, $8 	# Adjust for a longword load [2di]
        ldl	$22, 0($8)	# Get the memory action [2]
#ifndef MINIMA
G14378:
#endif
#ifdef MINIMA
.align 3
G14378:
        and	$22, MemoryActionBinding, $8 	# [3]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$8, G14377	# [1-]
        sll	$16, 1, $6 	# [0di]
        ldq	$8, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$6, $7, $6 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$6, $8, $6 	# [1]
        extll	$6, 0, $6 	# Clear sign-extension [1]
        s4addq	$6, $7, $7 	# [2]
        ldl	$6, 0($7)	# Fetch the key [2]
        ldl	$5, 4($7)	# Fetch value [1]
        subl	$16, $6, $8 	# Compare [2di]
        bne	$8, G14380	# Trap on miss [1]
        extll	$5, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14371	# This is another memory read tailcall. [1-]
.align 3
G14380:
	br	$31, DBCACHEMISSTRAP
#endif
G14377:
/* Perform memory action */
        bis	$31, $22, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14361:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14360	# [1]
.align 3
G14363:
        blbc	$22, G14362	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14359	# [1-]
.align 3
G14362:
        ldq	$23, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
.align 3
G14367:
        and	$23, MemoryActionTransform, $22 	# [3]
        beq	$22, G14366	# [1]
        bic	$1, 63, $1 	# [1-]
        bis	$1, TypeExternalValueCellPointer, $1 	# [1]
        br	$31, G14370	# [1-]
#ifndef MINIMA
G14366:
#endif
#ifdef MINIMA
.align 3
G14366:
        and	$23, MemoryActionBinding, $22 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$22, G14365	# [1-]
        sll	$16, 1, $7 	# [0di]
        ldq	$22, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $22, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$2, 4($8)	# Fetch value [1]
        subl	$16, $7, $22 	# Compare [2di]
        bne	$22, G14369	# Trap on miss [1]
        extll	$2, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14359	# This is another memory read tailcall. [1-]
.align 3
G14369:
	br	$31, DBCACHEMISSTRAP
#endif
G14365:
/* Perform memory action */
        bis	$31, $23, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14351:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14350	# [1]
.align 3
G14353:
        blbc	$22, G14352	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14349	# [1-]
.align 3
G14352:
        ldq	$23, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
G14355:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14348:
        bis	$16, $31, $5 	# [1]
/* Memory Read Internal */
G14384:
        addq	$16, $14, $22 	# [1]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14386	# [0di]
G14385:
        lda	$22, 64	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$23, G14388	# [1-]
G14393:
        subq	$5, $16, $5 	# [0di]
        bne	$5, G14347	# [1]
/* TagType. */
        and	$6, 63, $6 	# [0di]
        bis	$6, 64, $6 	# Set CDR code to 1 [1]
        stl	$16, 24($10)	# Update self [0di]
        stl	$6, 28($10)	# write the stack cache [1]
        br	$31, G14347	# [1]
.align 3
G14386:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14385	# [1]
.align 3
G14388:
        blbc	$22, G14387	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14384	# [1-]
.align 3
G14387:
        ldq	$23, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
G14390:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoPopInstanceVariable
/* End of Halfword operand from stack instruction - DoPopInstanceVariable */
.align 5
.globl DoMovemInstanceVariable
.ent DoMovemInstanceVariable 0
/* Halfword 10 bit immediate instruction - DoMovemInstanceVariable */
	.globl DoMovemInstanceVariableFP
	.globl DoMovemInstanceVariableSP
	.globl DoMovemInstanceVariableLP
	.globl DoMovemInstanceVariableIM
.align 3
DoMovemInstanceVariable:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoMovemInstanceVariable"
#endif
.align 3
DoMovemInstanceVariableIM:
.align 3
DoMovemInstanceVariableSP:
.align 3
DoMovemInstanceVariableLP:
.align 3
DoMovemInstanceVariableFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Mapped */
        ldl	$16, 16($10)	# Map [1]
        ldl	$1, 20($10)	#  [1]
        extll	$16, 0, $16 	# [2di]
        subq	$1, TypeArray, $4 	# [1]
        and	$4, 63, $4 	# Strip CDR code [1]
        bne	$4, IVBADMAP	# [1]
/* Memory Read Internal */
G14397:
        addq	$16, $14, $22 	# [0di]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14399	# [0di]
G14398:
        lda	$22, 64	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        blbs	$23, G14401	# [1di]
G14406:
        and	$2, ArrayLengthMask, $2 	# [1-]
        subq	$2, $17, $5 	# [1]
        ble	$5, IVBADINDEX	# J. if mapping-table-index-out-of-bounds [1]
        addq	$16, $17, $16 	# [0di]
        addq	$16, 1, $16 	# [1]
/* Memory Read Internal */
G14407:
        addq	$16, $14, $22 	# [1]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14409	# [0di]
G14408:
        lda	$22, 240	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$23, G14411	# [1-]
G14418:
        bis	$2, $31, $3 	# [1di]
        subq	$1, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, MOVEMIVIEX	# [1]
        ldl	$16, 24($10)	# Self [0di]
        ldl	$6, 28($10)	#  [1]
        extll	$16, 0, $16 	# [2di]
        subq	$6, TypeInstance, $5 	# [1]
        and	$5, 60, $5 	# Strip CDR code, low bits [1]
        bne	$5, IVBADINST	# [1]
        and	$6, 192, $5 	# Unshifted cdr code [1]
        subq	$5, 64, $5 	# Check for CDR code 1 [1]
        bne	$5, G14396	# J. if CDR code is not 1 [1]
.align 3
G14395:
        addq	$16, $3, $16 	# [1-]
.align 3
G14394:
        ldl	$1, 0($12)	#  [1-]
        ldl	$2, 4($12)	#  [1]
        extll	$1, 0, $1 	# [2-]
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G14419:
        addq	$16, $14, $8 	# [0di]
        s4addq	$8, $31, $5 	# [1]
        ldq_u	$4, 0($8)	#  [1di]
        subq	$16, $20, $6 	# Stack cache offset [1-]
        ldq	$22, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [0di]
        cmpult	$6, $21, $7 	# In range? [1-]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $8, $4 	# [1-]
        bne	$7, G14421	# [0di]
G14420:
        lda	$8, 240	#  [1-]
        srl	$22, $4, $22 	# [1]
        srl	$8, $4, $8 	# [1]
        blbs	$22, G14423	# [1di]
G14429:
/* Merge cdr-code */
        and	$2, 63, $5 	# [1-]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        addq	$16, $14, $6 	# [1]
        s4addq	$6, $31, $5 	# [1]
        ldq_u	$8, 0($6)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        cmpult	$7, $21, $22 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G14431:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$1, 0($5)	#  [1]
        bne	$22, G14430	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
MOVEMIVIEX:
        lda	$1, 8	#  [1-]
/* SetTag. */
        sll	$1, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $2, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G14430:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        subq	$16, $20, $7 	# Stack cache offset [0di]
        s8addq	$7, $6, $6 	# reconstruct SCA [3]
        stl	$1, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14421:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G14420	# [1]
.align 3
G14423:
        blbc	$8, G14422	# [1]
        extll	$5, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14419	# [1-]
.align 3
G14422:
        ldq	$22, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $8 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $22, $8 	# Adjust for a longword load [2di]
        ldl	$22, 0($8)	# Get the memory action [2]
#ifndef MINIMA
G14426:
#endif
#ifdef MINIMA
.align 3
G14426:
        and	$22, MemoryActionBinding, $8 	# [3]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$8, G14425	# [1-]
        sll	$16, 1, $6 	# [0di]
        ldq	$8, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$6, $7, $6 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$6, $8, $6 	# [1]
        extll	$6, 0, $6 	# Clear sign-extension [1]
        s4addq	$6, $7, $7 	# [2]
        ldl	$6, 0($7)	# Fetch the key [2]
        ldl	$5, 4($7)	# Fetch value [1]
        subl	$16, $6, $8 	# Compare [2di]
        bne	$8, G14428	# Trap on miss [1]
        extll	$5, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14419	# This is another memory read tailcall. [1-]
.align 3
G14428:
	br	$31, DBCACHEMISSTRAP
#endif
G14425:
/* Perform memory action */
        bis	$31, $22, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14409:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14408	# [1]
.align 3
G14411:
        blbc	$22, G14410	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14407	# [1-]
.align 3
G14410:
        ldq	$23, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
.align 3
G14415:
        and	$23, MemoryActionTransform, $22 	# [3]
        beq	$22, G14414	# [1]
        bic	$1, 63, $1 	# [1-]
        bis	$1, TypeExternalValueCellPointer, $1 	# [1]
        br	$31, G14418	# [1-]
#ifndef MINIMA
G14414:
#endif
#ifdef MINIMA
.align 3
G14414:
        and	$23, MemoryActionBinding, $22 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$22, G14413	# [1-]
        sll	$16, 1, $7 	# [0di]
        ldq	$22, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $22, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$2, 4($8)	# Fetch value [1]
        subl	$16, $7, $22 	# Compare [2di]
        bne	$22, G14417	# Trap on miss [1]
        extll	$2, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14407	# This is another memory read tailcall. [1-]
.align 3
G14417:
	br	$31, DBCACHEMISSTRAP
#endif
G14413:
/* Perform memory action */
        bis	$31, $23, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14399:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14398	# [1]
.align 3
G14401:
        blbc	$22, G14400	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14397	# [1-]
.align 3
G14400:
        ldq	$23, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
G14403:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14396:
        bis	$16, $31, $5 	# [1]
/* Memory Read Internal */
G14432:
        addq	$16, $14, $22 	# [1]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14434	# [0di]
G14433:
        lda	$22, 64	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$23, G14436	# [1-]
G14441:
        subq	$5, $16, $5 	# [0di]
        bne	$5, G14395	# [1]
/* TagType. */
        and	$6, 63, $6 	# [0di]
        bis	$6, 64, $6 	# Set CDR code to 1 [1]
        stl	$16, 24($10)	# Update self [0di]
        stl	$6, 28($10)	# write the stack cache [1]
        br	$31, G14395	# [1]
.align 3
G14434:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14433	# [1]
.align 3
G14436:
        blbc	$22, G14435	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14432	# [1-]
.align 3
G14435:
        ldq	$23, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
G14438:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoMovemInstanceVariable
/* End of Halfword operand from stack instruction - DoMovemInstanceVariable */
.align 5
.globl DoPushAddressInstanceVariable
.ent DoPushAddressInstanceVariable 0
/* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariable */
	.globl DoPushAddressInstanceVariableFP
	.globl DoPushAddressInstanceVariableSP
	.globl DoPushAddressInstanceVariableLP
	.globl DoPushAddressInstanceVariableIM
.align 3
DoPushAddressInstanceVariable:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoPushAddressInstanceVariable"
#endif
.align 3
DoPushAddressInstanceVariableIM:
.align 3
DoPushAddressInstanceVariableSP:
.align 3
DoPushAddressInstanceVariableLP:
.align 3
DoPushAddressInstanceVariableFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Mapped */
        ldl	$16, 16($10)	# Map [1]
        ldl	$1, 20($10)	#  [1]
        extll	$16, 0, $16 	# [2di]
        subq	$1, TypeArray, $4 	# [1]
        and	$4, 63, $4 	# Strip CDR code [1]
        bne	$4, IVBADMAP	# [1]
/* Memory Read Internal */
G14445:
        addq	$16, $14, $22 	# [0di]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14447	# [0di]
G14446:
        lda	$22, 64	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        blbs	$23, G14449	# [1di]
G14454:
        and	$2, ArrayLengthMask, $2 	# [1-]
        subq	$2, $17, $5 	# [1]
        ble	$5, IVBADINDEX	# J. if mapping-table-index-out-of-bounds [1]
        addq	$16, $17, $16 	# [0di]
        addq	$16, 1, $16 	# [1]
/* Memory Read Internal */
G14455:
        addq	$16, $14, $22 	# [1]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14457	# [0di]
G14456:
        lda	$22, 240	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$23, G14459	# [1-]
G14466:
        bis	$2, $31, $3 	# [1di]
        subq	$1, TypeFixnum, $6 	# [1]
        and	$6, 63, $6 	# Strip CDR code [1]
        bne	$6, PUSHADIVIEX	# [1]
        ldl	$16, 24($10)	# Self [0di]
        ldl	$6, 28($10)	#  [1]
        extll	$16, 0, $16 	# [2di]
        subq	$6, TypeInstance, $5 	# [1]
        and	$5, 60, $5 	# Strip CDR code, low bits [1]
        bne	$5, IVBADINST	# [1]
        and	$6, 192, $5 	# Unshifted cdr code [1]
        subq	$5, 64, $5 	# Check for CDR code 1 [1]
        bne	$5, G14444	# J. if CDR code is not 1 [1]
.align 3
G14443:
        addq	$16, $3, $16 	# [1-]
.align 3
G14442:
        bis	$31, TypeLocative, $7 	# [1]
        stl	$16, 8($12)	#  [0di]
        stl	$7, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
PUSHADIVIEX:
        lda	$1, 8	#  [1-]
/* SetTag. */
        sll	$1, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $2, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G14457:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14456	# [1]
.align 3
G14459:
        blbc	$22, G14458	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14455	# [1-]
.align 3
G14458:
        ldq	$23, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
.align 3
G14463:
        and	$23, MemoryActionTransform, $22 	# [3]
        beq	$22, G14462	# [1]
        bic	$1, 63, $1 	# [1-]
        bis	$1, TypeExternalValueCellPointer, $1 	# [1]
        br	$31, G14466	# [1-]
#ifndef MINIMA
G14462:
#endif
#ifdef MINIMA
.align 3
G14462:
        and	$23, MemoryActionBinding, $22 	# [1-]
        ldq	$8, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$22, G14461	# [1-]
        sll	$16, 1, $7 	# [0di]
        ldq	$22, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$7, $8, $7 	# Hash index [1di]
        bis	$31, 1, $8 	# [1]
        sll	$8, IvoryMemoryData, $8 	# [1]
        addl	$7, $22, $7 	# [1]
        extll	$7, 0, $7 	# Clear sign-extension [1]
        s4addq	$7, $8, $8 	# [2]
        ldl	$7, 0($8)	# Fetch the key [2]
        ldl	$2, 4($8)	# Fetch value [1]
        subl	$16, $7, $22 	# Compare [2di]
        bne	$22, G14465	# Trap on miss [1]
        extll	$2, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14455	# This is another memory read tailcall. [1-]
.align 3
G14465:
	br	$31, DBCACHEMISSTRAP
#endif
G14461:
/* Perform memory action */
        bis	$31, $23, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14447:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14446	# [1]
.align 3
G14449:
        blbc	$22, G14448	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14445	# [1-]
.align 3
G14448:
        ldq	$23, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
G14451:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14444:
        bis	$16, $31, $5 	# [1]
/* Memory Read Internal */
G14467:
        addq	$16, $14, $22 	# [1]
        s4addq	$22, $31, $2 	# [1]
        ldq_u	$1, 0($22)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        ldq	$23, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$7, $21, $8 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$1, $22, $1 	# [1-]
        bne	$8, G14469	# [0di]
G14468:
        lda	$22, 64	#  [1-]
        srl	$23, $1, $23 	# [1]
        srl	$22, $1, $22 	# [1]
        extll	$2, 0, $2 	# [1]
        blbs	$23, G14471	# [1-]
G14476:
        subq	$5, $16, $5 	# [0di]
        bne	$5, G14443	# [1]
/* TagType. */
        and	$6, 63, $6 	# [0di]
        bis	$6, 64, $6 	# Set CDR code to 1 [1]
        stl	$16, 24($10)	# Update self [0di]
        stl	$6, 28($10)	# write the stack cache [1]
        br	$31, G14443	# [1]
.align 3
G14469:
        ldq	$8, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$7, $8, $7 	# reconstruct SCA [3]
        ldl	$2, 0($7)	#  [2]
        ldl	$1, 4($7)	# Read from stack cache [1]
        br	$31, G14468	# [1]
.align 3
G14471:
        blbc	$22, G14470	# [1]
        extll	$2, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14467	# [1-]
.align 3
G14470:
        ldq	$23, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$1, 63, $22 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$22, $23, $22 	# Adjust for a longword load [2di]
        ldl	$23, 0($22)	# Get the memory action [2]
G14473:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoPushAddressInstanceVariable
/* End of Halfword operand from stack instruction - DoPushAddressInstanceVariable */
.align 5
.globl DoPushInstanceVariableOrdered
.ent DoPushInstanceVariableOrdered 0
/* Halfword 10 bit immediate instruction - DoPushInstanceVariableOrdered */
	.globl DoPushInstanceVariableOrderedFP
	.globl DoPushInstanceVariableOrderedSP
	.globl DoPushInstanceVariableOrderedLP
	.globl DoPushInstanceVariableOrderedIM
.align 3
DoPushInstanceVariableOrdered:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoPushInstanceVariableOrdered"
#endif
.align 3
DoPushInstanceVariableOrderedIM:
.align 3
DoPushInstanceVariableOrderedSP:
.align 3
DoPushInstanceVariableOrderedLP:
.align 3
DoPushInstanceVariableOrderedFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Unmapped */
        ldl	$2, 24($10)	# self [1]
        ldl	$1, 28($10)	#  [1]
        extll	$2, 0, $2 	# [2di]
        subq	$1, TypeInstance, $3 	# [1]
        and	$3, 60, $3 	# Strip CDR code, low bits [1]
        bne	$3, IVBADINST	# [1]
        addq	$2, $17, $16 	# [0di]
/* Memory Read Internal */
G14477:
        addq	$16, $14, $6 	# [1]
        s4addq	$6, $31, $1 	# [1]
        ldq_u	$2, 0($6)	#  [1-]
        subq	$16, $20, $4 	# Stack cache offset [0di]
        ldq	$7, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$4, $21, $5 	# In range? [0di]
        ldl	$1, 0($1)	#  [1-]
        extbl	$2, $6, $2 	# [1di]
        bne	$5, G14479	# [1-]
G14478:
        lda	$6, 240	#  [0di]
        srl	$7, $2, $7 	# [1]
        srl	$6, $2, $6 	# [1]
        blbs	$7, G14481	# [1-]
G14488:
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [0di]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        and	$2, 63, $7 	# set CDR-NEXT [0di]
        stl	$1, 8($12)	#  [1-]
        stl	$7, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, CACHEVALID	# [0di]
.align 3
G14479:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$4, $5, $4 	# reconstruct SCA [3]
        ldl	$1, 0($4)	#  [2]
        ldl	$2, 4($4)	# Read from stack cache [1]
        br	$31, G14478	# [1]
.align 3
G14481:
        blbc	$6, G14480	# [1]
        extll	$1, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14477	# [1-]
.align 3
G14480:
        ldq	$7, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $7, $6 	# Adjust for a longword load [2di]
        ldl	$7, 0($6)	# Get the memory action [2]
.align 3
G14485:
        and	$7, MemoryActionTransform, $6 	# [3]
        beq	$6, G14484	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G14488	# [1-]
#ifndef MINIMA
G14484:
#endif
#ifdef MINIMA
.align 3
G14484:
        and	$7, MemoryActionBinding, $6 	# [1-]
        ldq	$5, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$6, G14483	# [1-]
        sll	$16, 1, $4 	# [0di]
        ldq	$6, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$4, $5, $4 	# Hash index [1di]
        bis	$31, 1, $5 	# [1]
        sll	$5, IvoryMemoryData, $5 	# [1]
        addl	$4, $6, $4 	# [1]
        extll	$4, 0, $4 	# Clear sign-extension [1]
        s4addq	$4, $5, $5 	# [2]
        ldl	$4, 0($5)	# Fetch the key [2]
        ldl	$1, 4($5)	# Fetch value [1]
        subl	$16, $4, $6 	# Compare [2di]
        bne	$6, G14487	# Trap on miss [1]
        extll	$1, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14477	# This is another memory read tailcall. [1-]
.align 3
G14487:
	br	$31, DBCACHEMISSTRAP
#endif
G14483:
/* Perform memory action */
        bis	$31, $7, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoPushInstanceVariableOrdered
/* End of Halfword operand from stack instruction - DoPushInstanceVariableOrdered */
.align 5
.globl DoPopInstanceVariableOrdered
.ent DoPopInstanceVariableOrdered 0
/* Halfword 10 bit immediate instruction - DoPopInstanceVariableOrdered */
	.globl DoPopInstanceVariableOrderedFP
	.globl DoPopInstanceVariableOrderedSP
	.globl DoPopInstanceVariableOrderedLP
	.globl DoPopInstanceVariableOrderedIM
.align 3
DoPopInstanceVariableOrdered:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoPopInstanceVariableOrdered"
#endif
.align 3
DoPopInstanceVariableOrderedIM:
.align 3
DoPopInstanceVariableOrderedSP:
.align 3
DoPopInstanceVariableOrderedLP:
.align 3
DoPopInstanceVariableOrderedFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Unmapped */
        ldl	$2, 24($10)	# self [1]
        ldl	$1, 28($10)	#  [1]
        extll	$2, 0, $2 	# [2di]
        subq	$1, TypeInstance, $3 	# [1]
        and	$3, 60, $3 	# Strip CDR code, low bits [1]
        bne	$3, IVBADINST	# [1]
        addq	$2, $17, $16 	# [0di]
        ldl	$1, 0($12)	#  [1-]
        ldl	$2, 4($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
/* Memory Read Internal */
G14489:
        addq	$16, $14, $8 	# [1]
        s4addq	$8, $31, $5 	# [1]
        ldq_u	$4, 0($8)	#  [1-]
        subq	$16, $20, $6 	# Stack cache offset [0di]
        ldq	$22, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [1-]
        cmpult	$6, $21, $7 	# In range? [0di]
        ldl	$5, 0($5)	#  [1-]
        extbl	$4, $8, $4 	# [1di]
        bne	$7, G14491	# [1-]
G14490:
        lda	$8, 240	#  [0di]
        srl	$22, $4, $22 	# [1]
        srl	$8, $4, $8 	# [1]
        blbs	$22, G14493	# [1-]
G14499:
/* Merge cdr-code */
        and	$2, 63, $5 	# [0di]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        addq	$16, $14, $6 	# [1]
        s4addq	$6, $31, $5 	# [1]
        ldq_u	$8, 0($6)	#  [1-]
        subq	$16, $20, $7 	# Stack cache offset [0di]
        cmpult	$7, $21, $22 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G14501:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$1, 0($5)	#  [1]
        bne	$22, G14500	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14500:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$16, $20, $7 	# Stack cache offset [0di]
        s8addq	$7, $6, $6 	# reconstruct SCA [3]
        stl	$1, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14491:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G14490	# [1]
.align 3
G14493:
        blbc	$8, G14492	# [1]
        extll	$5, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14489	# [1-]
.align 3
G14492:
        ldq	$22, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $8 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $22, $8 	# Adjust for a longword load [2di]
        ldl	$22, 0($8)	# Get the memory action [2]
#ifndef MINIMA
G14496:
#endif
#ifdef MINIMA
.align 3
G14496:
        and	$22, MemoryActionBinding, $8 	# [3]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$8, G14495	# [1-]
        sll	$16, 1, $6 	# [0di]
        ldq	$8, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$6, $7, $6 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$6, $8, $6 	# [1]
        extll	$6, 0, $6 	# Clear sign-extension [1]
        s4addq	$6, $7, $7 	# [2]
        ldl	$6, 0($7)	# Fetch the key [2]
        ldl	$5, 4($7)	# Fetch value [1]
        subl	$16, $6, $8 	# Compare [2di]
        bne	$8, G14498	# Trap on miss [1]
        extll	$5, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14489	# This is another memory read tailcall. [1-]
.align 3
G14498:
	br	$31, DBCACHEMISSTRAP
#endif
G14495:
/* Perform memory action */
        bis	$31, $22, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoPopInstanceVariableOrdered
/* End of Halfword operand from stack instruction - DoPopInstanceVariableOrdered */
.align 5
.globl DoMovemInstanceVariableOrdered
.ent DoMovemInstanceVariableOrdered 0
/* Halfword 10 bit immediate instruction - DoMovemInstanceVariableOrdered */
	.globl DoMovemInstanceVariableOrderedFP
	.globl DoMovemInstanceVariableOrderedSP
	.globl DoMovemInstanceVariableOrderedLP
	.globl DoMovemInstanceVariableOrderedIM
.align 3
DoMovemInstanceVariableOrdered:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoMovemInstanceVariableOrdered"
#endif
.align 3
DoMovemInstanceVariableOrderedIM:
.align 3
DoMovemInstanceVariableOrderedSP:
.align 3
DoMovemInstanceVariableOrderedLP:
.align 3
DoMovemInstanceVariableOrderedFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
        ldq	$20, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$21, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Instance Variable Unmapped */
        ldl	$2, 24($10)	# self [1]
        ldl	$1, 28($10)	#  [1]
        extll	$2, 0, $2 	# [2di]
        subq	$1, TypeInstance, $3 	# [1]
        and	$3, 60, $3 	# Strip CDR code, low bits [1]
        bne	$3, IVBADINST	# [1]
        addq	$2, $17, $16 	# [0di]
        ldl	$1, 0($12)	#  [1-]
        ldl	$2, 4($12)	#  [1]
        extll	$1, 0, $1 	# [2-]
/* Memory Read Internal */
G14502:
        addq	$16, $14, $8 	# [1]
        s4addq	$8, $31, $5 	# [1]
        ldq_u	$4, 0($8)	#  [1di]
        subq	$16, $20, $6 	# Stack cache offset [1-]
        ldq	$22, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [0di]
        cmpult	$6, $21, $7 	# In range? [1-]
        ldl	$5, 0($5)	#  [0di]
        extbl	$4, $8, $4 	# [1-]
        bne	$7, G14504	# [0di]
G14503:
        lda	$8, 240	#  [1-]
        srl	$22, $4, $22 	# [1]
        srl	$8, $4, $8 	# [1]
        blbs	$22, G14506	# [1di]
G14512:
/* Merge cdr-code */
        and	$2, 63, $5 	# [1-]
        and	$4, 192, $4 	# [1]
        bis	$4, $5, $4 	# [1]
        addq	$16, $14, $6 	# [1]
        s4addq	$6, $31, $5 	# [1]
        ldq_u	$8, 0($6)	#  [1di]
        subq	$16, $20, $7 	# Stack cache offset [1-]
        cmpult	$7, $21, $22 	# In range? [1]
        insbl	$4, $6, $7 	# [1]
        mskbl	$8, $6, $8 	# [1]
.align 3
G14514:
        bis	$8, $7, $8 	# [2]
        stq_u	$8, 0($6)	#  [0di]
        stl	$1, 0($5)	#  [1]
        bne	$22, G14513	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14513:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$16, $20, $7 	# Stack cache offset [0di]
        s8addq	$7, $6, $6 	# reconstruct SCA [3]
        stl	$1, 0($6)	# Store in stack [2]
        stl	$4, 4($6)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14504:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$6, $7, $6 	# reconstruct SCA [3]
        ldl	$5, 0($6)	#  [2]
        ldl	$4, 4($6)	# Read from stack cache [1]
        br	$31, G14503	# [1]
.align 3
G14506:
        blbc	$8, G14505	# [1]
        extll	$5, 0, $16 	# Do the indirect thing [0di]
        br	$31, G14502	# [1-]
.align 3
G14505:
        ldq	$22, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $8 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$8, $22, $8 	# Adjust for a longword load [2di]
        ldl	$22, 0($8)	# Get the memory action [2]
#ifndef MINIMA
G14509:
#endif
#ifdef MINIMA
.align 3
G14509:
        and	$22, MemoryActionBinding, $8 	# [3]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$8, G14508	# [1-]
        sll	$16, 1, $6 	# [0di]
        ldq	$8, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$6, $7, $6 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$6, $8, $6 	# [1]
        extll	$6, 0, $6 	# Clear sign-extension [1]
        s4addq	$6, $7, $7 	# [2]
        ldl	$6, 0($7)	# Fetch the key [2]
        ldl	$5, 4($7)	# Fetch value [1]
        subl	$16, $6, $8 	# Compare [2di]
        bne	$8, G14511	# Trap on miss [1]
        extll	$5, 0, $16 	# Extract the pointer, and indirect [0di]
        br	$31, G14502	# This is another memory read tailcall. [1-]
.align 3
G14511:
	br	$31, DBCACHEMISSTRAP
#endif
G14508:
/* Perform memory action */
        bis	$31, $22, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoMovemInstanceVariableOrdered
/* End of Halfword operand from stack instruction - DoMovemInstanceVariableOrdered */
.align 5
.globl DoPushAddressInstanceVariableOrdered
.ent DoPushAddressInstanceVariableOrdered 0
/* Halfword 10 bit immediate instruction - DoPushAddressInstanceVariableOrdered */
	.globl DoPushAddressInstanceVariableOrderedFP
	.globl DoPushAddressInstanceVariableOrderedSP
	.globl DoPushAddressInstanceVariableOrderedLP
	.globl DoPushAddressInstanceVariableOrderedIM
.align 3
DoPushAddressInstanceVariableOrdered:
/* Actually only one entry point, but simulate others for dispatch */
#ifdef TRACING
	.byte 0xA0
	.asciiz "DoPushAddressInstanceVariableOrdered"
#endif
.align 3
DoPushAddressInstanceVariableOrderedIM:
.align 3
DoPushAddressInstanceVariableOrderedSP:
.align 3
DoPushAddressInstanceVariableOrderedLP:
.align 3
DoPushAddressInstanceVariableOrderedFP:
        extwl	$18, 4, $16 	# [1]
/* arg1 has operand preloaded. */
/* Locate Instance Variable Unmapped */
        ldl	$2, 24($10)	# self [0di]
        ldl	$1, 28($10)	#  [1]
        extll	$2, 0, $2 	# [2di]
        subq	$1, TypeInstance, $3 	# [1]
        and	$3, 60, $3 	# Strip CDR code, low bits [1]
        bne	$3, IVBADINST	# [1]
        addq	$2, $17, $16 	# [0di]
        bis	$31, TypeLocative, $7 	# [1]
        stl	$16, 8($12)	#  [0di]
        stl	$7, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
IVBADMAP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 68, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
IVBADINDEX:
        bis	$31, 0, $20 	# [1]
        bis	$31, 53, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
IVBADINST:
        bis	$31, 0, $20 	# [1]
        bis	$31, 69, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoPushAddressInstanceVariableOrdered
/* End of Halfword operand from stack instruction - DoPushAddressInstanceVariableOrdered */
.align 5
.globl DoInstanceRef
.ent DoInstanceRef 0
/* Halfword operand from stack instruction - DoInstanceRef */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoInstanceRefFP
	.globl DoInstanceRefSP
	.globl DoInstanceRefLP
	.globl DoInstanceRefIM
.align 3
DoInstanceRef:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoInstanceRefIM"
#endif
.align 3
DoInstanceRefIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoInstanceRef	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoInstanceRefSP"
#endif
.align 3
DoInstanceRefSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoInstanceRef	# [0di]
	.byte 0x90
	.asciiz "DoInstanceRefLP"
#endif
.align 3
DoInstanceRefLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoInstanceRef	# [1]
	.byte 0x84
	.asciiz "DoInstanceRefFP"
#endif
.align 3
DoInstanceRefFP:	# Entry point for FP relative
.align 3
headDoInstanceRef:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoInstanceRef:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	#  [1]
        ldl	$18, 4($12)	#  [1]
        extll	$19, 0, $19 	# [2-]
        srl	$16, 32, $17 	# [1]
        extll	$16, 0, $16 	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Arbitrary Instance Variable */
        subq	$18, TypeInstance, $1 	# [0di]
        and	$1, 60, $1 	# Strip CDR code, low bits [1]
        bne	$1, IVREFBADINST	# [1]
        subq	$17, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, IVREFBADOFFSET	# [1]
/* Memory Read Internal */
G14515:
        addq	$19, $14, $7 	# [0di]
        s4addq	$7, $31, $1 	# [1]
        ldq_u	$2, 0($7)	#  [1di]
        subq	$19, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$1, 0($1)	#  [0di]
        extbl	$2, $7, $2 	# [1-]
        bne	$6, G14517	# [0di]
G14516:
        lda	$7, 64	#  [1-]
        srl	$8, $2, $8 	# [1]
        srl	$7, $2, $7 	# [1]
        extll	$1, 0, $1 	# [1]
        blbs	$8, G14519	# [1-]
G14524:
        subq	$1, 1, $1 	# [1di]
/* Memory Read Internal */
G14525:
        addq	$1, $14, $7 	# [1]
        s4addq	$7, $31, $2 	# [1]
        ldq_u	$4, 0($7)	#  [1-]
        subq	$1, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$2, 0($2)	#  [1-]
        extbl	$4, $7, $4 	# [1di]
        bne	$6, G14527	# [1-]
G14526:
        lda	$7, 240	#  [0di]
        srl	$8, $4, $8 	# [1]
        srl	$7, $4, $7 	# [1]
        blbs	$8, G14529	# [1-]
G14536:
        subq	$4, TypeFixnum, $5 	# [0di]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, IVREFBADOFFSET	# [1]
        blt	$16, IVREFBADOFFSET	# J. if offset <0 [1]
        subq	$16, $2, $4 	# [0di]
        bge	$4, IVREFBADOFFSET	# J. if offset out of bounds [1]
        addq	$16, $19, $20 	# [0di]
/* Memory Read Internal */
G14537:
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$20, $14, $6 	# [0di]
        ldl	$5, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$6, $31, $1 	# [0di]
        ldq_u	$2, 0($6)	#  [1-]
        subq	$20, $4, $4 	# Stack cache offset [1di]
        ldq	$7, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$4, $5, $5 	# In range? [0di]
        ldl	$1, 0($1)	#  [1-]
        extbl	$2, $6, $2 	# [0di]
        bne	$5, G14539	# [1-]
G14538:
        lda	$6, 240	#  [0di]
        srl	$7, $2, $7 	# [1]
        srl	$6, $2, $6 	# [1]
        blbs	$7, G14541	# [1-]
G14548:
        and	$2, 63, $2 	# set CDR-NEXT [0di]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        stl	$1, 0($12)	#  [1]
        stl	$2, 4($12)	# write the stack cache [1]
        br	$31, CACHEVALID	# [1]
.align 3
G14539:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$4, $5, $4 	# reconstruct SCA [3]
        ldl	$1, 0($4)	#  [2]
        ldl	$2, 4($4)	# Read from stack cache [1]
        br	$31, G14538	# [1]
.align 3
G14541:
        blbc	$6, G14540	# [1]
        extll	$1, 0, $20 	# Do the indirect thing [0di]
        br	$31, G14537	# [1-]
.align 3
G14540:
        ldq	$7, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$20, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $7, $6 	# Adjust for a longword load [2di]
        ldl	$7, 0($6)	# Get the memory action [2]
.align 3
G14545:
        and	$7, MemoryActionTransform, $6 	# [3]
        beq	$6, G14544	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G14548	# [1-]
#ifndef MINIMA
G14544:
#endif
#ifdef MINIMA
.align 3
G14544:
        and	$7, MemoryActionBinding, $6 	# [1-]
        ldq	$5, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$6, G14543	# [1-]
        sll	$20, 1, $4 	# [0di]
        ldq	$6, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$4, $5, $4 	# Hash index [1di]
        bis	$31, 1, $5 	# [1]
        sll	$5, IvoryMemoryData, $5 	# [1]
        addl	$4, $6, $4 	# [1]
        extll	$4, 0, $4 	# Clear sign-extension [1]
        s4addq	$4, $5, $5 	# [2]
        ldl	$4, 0($5)	# Fetch the key [2]
        ldl	$1, 4($5)	# Fetch value [1]
        subl	$20, $4, $6 	# Compare [2di]
        bne	$6, G14547	# Trap on miss [1]
        extll	$1, 0, $20 	# Extract the pointer, and indirect [0di]
        br	$31, G14537	# This is another memory read tailcall. [1-]
.align 3
G14547:
	br	$31, DBCACHEMISSTRAP
#endif
G14543:
/* Perform memory action */
        bis	$31, $7, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14527:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$2, 0($5)	#  [2]
        ldl	$4, 4($5)	# Read from stack cache [1]
        br	$31, G14526	# [1]
.align 3
G14529:
        blbc	$7, G14528	# [1]
        extll	$2, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14525	# [1-]
.align 3
G14528:
        ldq	$8, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $7 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
.align 3
G14533:
        and	$8, MemoryActionTransform, $7 	# [3]
        beq	$7, G14532	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G14536	# [1-]
#ifndef MINIMA
G14532:
#endif
#ifdef MINIMA
.align 3
G14532:
        and	$8, MemoryActionBinding, $7 	# [1-]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G14531	# [1-]
        sll	$1, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$2, 4($6)	# Fetch value [1]
        subl	$1, $5, $7 	# Compare [2di]
        bne	$7, G14535	# Trap on miss [1]
        extll	$2, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14525	# This is another memory read tailcall. [1-]
.align 3
G14535:
	br	$31, DBCACHEMISSTRAP
#endif
G14531:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14517:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$1, 0($5)	#  [2]
        ldl	$2, 4($5)	# Read from stack cache [1]
        br	$31, G14516	# [1]
.align 3
G14519:
        blbc	$7, G14518	# [1]
        extll	$1, 0, $19 	# Do the indirect thing [0di]
        br	$31, G14515	# [1-]
.align 3
G14518:
        ldq	$8, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $7 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G14521:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoInstanceRef
/* End of Halfword operand from stack instruction - DoInstanceRef */
.align 5
.globl DoInstanceSet
.ent DoInstanceSet 0
/* Halfword operand from stack instruction - DoInstanceSet */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoInstanceSetFP
	.globl DoInstanceSetSP
	.globl DoInstanceSetLP
	.globl DoInstanceSetIM
.align 3
DoInstanceSet:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoInstanceSetIM"
#endif
.align 3
DoInstanceSetIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoInstanceSet	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoInstanceSetSP"
#endif
.align 3
DoInstanceSetSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoInstanceSet	# [0di]
	.byte 0x90
	.asciiz "DoInstanceSetLP"
#endif
.align 3
DoInstanceSetLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoInstanceSet	# [1]
	.byte 0x84
	.asciiz "DoInstanceSetFP"
#endif
.align 3
DoInstanceSetFP:	# Entry point for FP relative
.align 3
headDoInstanceSet:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoInstanceSet:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	#  [1]
        ldl	$18, 4($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$19, 0, $19 	# [1]
        srl	$16, 32, $17 	# [1]
        extll	$16, 0, $16 	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Arbitrary Instance Variable */
        subq	$18, TypeInstance, $1 	# [1-]
        and	$1, 60, $1 	# Strip CDR code, low bits [1]
        bne	$1, IVREFBADINST3	# [1]
        subq	$17, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, IVREFBADOFFSET	# [1]
/* Memory Read Internal */
G14549:
        addq	$19, $14, $7 	# [1-]
        s4addq	$7, $31, $1 	# [1]
        ldq_u	$2, 0($7)	#  [1-]
        subq	$19, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$1, 0($1)	#  [1-]
        extbl	$2, $7, $2 	# [1di]
        bne	$6, G14551	# [1-]
G14550:
        lda	$7, 64	#  [0di]
        srl	$8, $2, $8 	# [1]
        srl	$7, $2, $7 	# [1]
        extll	$1, 0, $1 	# [1]
        blbs	$8, G14553	# [0di]
G14558:
        subq	$1, 1, $1 	# [2-]
/* Memory Read Internal */
G14559:
        addq	$1, $14, $7 	# [1]
        s4addq	$7, $31, $2 	# [1]
        ldq_u	$4, 0($7)	#  [1di]
        subq	$1, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$2, 0($2)	#  [0di]
        extbl	$4, $7, $4 	# [1-]
        bne	$6, G14561	# [0di]
G14560:
        lda	$7, 240	#  [1-]
        srl	$8, $4, $8 	# [1]
        srl	$7, $4, $7 	# [1]
        blbs	$8, G14563	# [1di]
G14570:
        subq	$4, TypeFixnum, $5 	# [1-]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, IVREFBADOFFSET	# [1]
        blt	$16, IVREFBADOFFSET	# J. if offset <0 [1]
        subq	$16, $2, $4 	# [1-]
        bge	$4, IVREFBADOFFSET	# J. if offset out of bounds [1]
        addq	$16, $19, $20 	# [1-]
        ldl	$1, 0($12)	#  [0di]
        ldl	$2, 4($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$1, 0, $1 	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Memory Read Internal */
G14571:
        addq	$20, $14, $7 	# [0di]
        s4addq	$7, $31, $4 	# [1]
        ldq_u	$3, 0($7)	#  [1di]
        subq	$20, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAWRITE_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$4, 0($4)	#  [0di]
        extbl	$3, $7, $3 	# [1-]
        bne	$6, G14573	# [0di]
G14572:
        lda	$7, 240	#  [1-]
        srl	$8, $3, $8 	# [1]
        srl	$7, $3, $7 	# [1]
        blbs	$8, G14575	# [1di]
G14581:
/* Merge cdr-code */
        and	$2, 63, $4 	# [1-]
        and	$3, 192, $3 	# [1]
        bis	$3, $4, $3 	# [1]
        addq	$20, $14, $5 	# [1]
        s4addq	$5, $31, $4 	# [1]
        ldq_u	$7, 0($5)	#  [1di]
        subq	$20, $24, $6 	# Stack cache offset [1-]
        cmpult	$6, $25, $8 	# In range? [1]
        insbl	$3, $5, $6 	# [1]
        mskbl	$7, $5, $7 	# [1]
.align 3
G14583:
        bis	$7, $6, $7 	# [2]
        stq_u	$7, 0($5)	#  [0di]
        stl	$1, 0($4)	#  [1]
        bne	$8, G14582	# J. if in cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
IVREFBADINST3:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 4, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14582:
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        subq	$20, $24, $6 	# Stack cache offset [0di]
        s8addq	$6, $5, $5 	# reconstruct SCA [3]
        stl	$1, 0($5)	# Store in stack [2]
        stl	$3, 4($5)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14573:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$4, 0($5)	#  [2]
        ldl	$3, 4($5)	# Read from stack cache [1]
        br	$31, G14572	# [1]
.align 3
G14575:
        blbc	$7, G14574	# [1]
        extll	$4, 0, $20 	# Do the indirect thing [0di]
        br	$31, G14571	# [1-]
.align 3
G14574:
        ldq	$8, PROCESSORSTATE_DATAWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$3, 63, $7 	# Discard the CDR code [0di]
        stq	$20, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
#ifndef MINIMA
G14578:
#endif
#ifdef MINIMA
.align 3
G14578:
        and	$8, MemoryActionBinding, $7 	# [3]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G14577	# [1-]
        sll	$20, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$4, 4($6)	# Fetch value [1]
        subl	$20, $5, $7 	# Compare [2di]
        bne	$7, G14580	# Trap on miss [1]
        extll	$4, 0, $20 	# Extract the pointer, and indirect [0di]
        br	$31, G14571	# This is another memory read tailcall. [1-]
.align 3
G14580:
	br	$31, DBCACHEMISSTRAP
#endif
G14577:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 1, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14561:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$2, 0($5)	#  [2]
        ldl	$4, 4($5)	# Read from stack cache [1]
        br	$31, G14560	# [1]
.align 3
G14563:
        blbc	$7, G14562	# [1]
        extll	$2, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14559	# [1-]
.align 3
G14562:
        ldq	$8, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $7 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
.align 3
G14567:
        and	$8, MemoryActionTransform, $7 	# [3]
        beq	$7, G14566	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G14570	# [1-]
#ifndef MINIMA
G14566:
#endif
#ifdef MINIMA
.align 3
G14566:
        and	$8, MemoryActionBinding, $7 	# [1-]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G14565	# [1-]
        sll	$1, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$2, 4($6)	# Fetch value [1]
        subl	$1, $5, $7 	# Compare [2di]
        bne	$7, G14569	# Trap on miss [1]
        extll	$2, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14559	# This is another memory read tailcall. [1-]
.align 3
G14569:
	br	$31, DBCACHEMISSTRAP
#endif
G14565:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14551:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$1, 0($5)	#  [2]
        ldl	$2, 4($5)	# Read from stack cache [1]
        br	$31, G14550	# [1]
.align 3
G14553:
        blbc	$7, G14552	# [1]
        extll	$1, 0, $19 	# Do the indirect thing [0di]
        br	$31, G14549	# [1-]
.align 3
G14552:
        ldq	$8, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $7 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G14555:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoInstanceSet
/* End of Halfword operand from stack instruction - DoInstanceSet */
.align 5
.globl DoInstanceLoc
.ent DoInstanceLoc 0
/* Halfword operand from stack instruction - DoInstanceLoc */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoInstanceLocFP
	.globl DoInstanceLocSP
	.globl DoInstanceLocLP
	.globl DoInstanceLocIM
.align 3
DoInstanceLoc:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoInstanceLocIM"
#endif
.align 3
DoInstanceLocIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoInstanceLoc	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoInstanceLocSP"
#endif
.align 3
DoInstanceLocSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoInstanceLoc	# [0di]
	.byte 0x90
	.asciiz "DoInstanceLocLP"
#endif
.align 3
DoInstanceLocLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoInstanceLoc	# [1]
	.byte 0x84
	.asciiz "DoInstanceLocFP"
#endif
.align 3
DoInstanceLocFP:	# Entry point for FP relative
.align 3
headDoInstanceLoc:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoInstanceLoc:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$19, 0($12)	#  [1]
        ldl	$18, 4($12)	#  [1]
        extll	$19, 0, $19 	# [2-]
        srl	$16, 32, $17 	# [1]
        extll	$16, 0, $16 	# [1]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
/* Locate Arbitrary Instance Variable */
        subq	$18, TypeInstance, $1 	# [0di]
        and	$1, 60, $1 	# Strip CDR code, low bits [1]
        bne	$1, IVREFBADINST	# [1]
        subq	$17, TypeFixnum, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, IVREFBADOFFSET	# [1]
/* Memory Read Internal */
G14584:
        addq	$19, $14, $7 	# [0di]
        s4addq	$7, $31, $1 	# [1]
        ldq_u	$2, 0($7)	#  [1di]
        subq	$19, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_HEADER_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$1, 0($1)	#  [0di]
        extbl	$2, $7, $2 	# [1-]
        bne	$6, G14586	# [0di]
G14585:
        lda	$7, 64	#  [1-]
        srl	$8, $2, $8 	# [1]
        srl	$7, $2, $7 	# [1]
        extll	$1, 0, $1 	# [1]
        blbs	$8, G14588	# [1-]
G14593:
        subq	$1, 1, $1 	# [1di]
/* Memory Read Internal */
G14594:
        addq	$1, $14, $7 	# [1]
        s4addq	$7, $31, $2 	# [1]
        ldq_u	$4, 0($7)	#  [1-]
        subq	$1, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$2, 0($2)	#  [1-]
        extbl	$4, $7, $4 	# [1di]
        bne	$6, G14596	# [1-]
G14595:
        lda	$7, 240	#  [0di]
        srl	$8, $4, $8 	# [1]
        srl	$7, $4, $7 	# [1]
        blbs	$8, G14598	# [1-]
G14605:
        subq	$4, TypeFixnum, $5 	# [0di]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, IVREFBADOFFSET	# [1]
        blt	$16, IVREFBADOFFSET	# J. if offset <0 [1]
        subq	$16, $2, $4 	# [0di]
        bge	$4, IVREFBADOFFSET	# J. if offset out of bounds [1]
        addq	$16, $19, $20 	# [0di]
        bis	$31, TypeLocative, $7 	# [1]
        stl	$20, 0($12)	#  [0di]
        stl	$7, 4($12)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
IVREFBADINST:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 3, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
IVREFBADOFFSET:
        bis	$31, 0, $20 	# [1]
        bis	$31, 49, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14596:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$2, 0($5)	#  [2]
        ldl	$4, 4($5)	# Read from stack cache [1]
        br	$31, G14595	# [1]
.align 3
G14598:
        blbc	$7, G14597	# [1]
        extll	$2, 0, $1 	# Do the indirect thing [0di]
        br	$31, G14594	# [1-]
.align 3
G14597:
        ldq	$8, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$4, 63, $7 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
.align 3
G14602:
        and	$8, MemoryActionTransform, $7 	# [3]
        beq	$7, G14601	# [1]
        bic	$4, 63, $4 	# [1-]
        bis	$4, TypeExternalValueCellPointer, $4 	# [1]
        br	$31, G14605	# [1-]
#ifndef MINIMA
G14601:
#endif
#ifdef MINIMA
.align 3
G14601:
        and	$8, MemoryActionBinding, $7 	# [1-]
        ldq	$6, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$7, G14600	# [1-]
        sll	$1, 1, $5 	# [0di]
        ldq	$7, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$5, $6, $5 	# Hash index [1di]
        bis	$31, 1, $6 	# [1]
        sll	$6, IvoryMemoryData, $6 	# [1]
        addl	$5, $7, $5 	# [1]
        extll	$5, 0, $5 	# Clear sign-extension [1]
        s4addq	$5, $6, $6 	# [2]
        ldl	$5, 0($6)	# Fetch the key [2]
        ldl	$2, 4($6)	# Fetch value [1]
        subl	$1, $5, $7 	# Compare [2di]
        bne	$7, G14604	# Trap on miss [1]
        extll	$2, 0, $1 	# Extract the pointer, and indirect [0di]
        br	$31, G14594	# This is another memory read tailcall. [1-]
.align 3
G14604:
	br	$31, DBCACHEMISSTRAP
#endif
G14600:
/* Perform memory action */
        bis	$31, $8, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G14586:
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$5, $6, $5 	# reconstruct SCA [3]
        ldl	$1, 0($5)	#  [2]
        ldl	$2, 4($5)	# Read from stack cache [1]
        br	$31, G14585	# [1]
.align 3
G14588:
        blbc	$7, G14587	# [1]
        extll	$1, 0, $19 	# Do the indirect thing [0di]
        br	$31, G14584	# [1-]
.align 3
G14587:
        ldq	$8, PROCESSORSTATE_HEADER($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $7 	# Discard the CDR code [0di]
        stq	$19, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$7, $8, $7 	# Adjust for a longword load [2di]
        ldl	$8, 0($7)	# Get the memory action [2]
G14590:
/* Perform memory action */
        bis	$31, $8, $16 	# [3]
        bis	$31, 6, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end DoInstanceLoc
/* End of Halfword operand from stack instruction - DoInstanceLoc */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifuninst.as */
