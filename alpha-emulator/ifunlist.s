/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunlist.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* List Operations. */
.align 5
.globl DoSetToCar
.ent DoSetToCar 0
/* Halfword operand from stack instruction - DoSetToCar */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetToCarFP
	.globl DoSetToCarSP
	.globl DoSetToCarLP
	.globl DoSetToCarIM
.align 3
DoSetToCar:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetToCarSP"
#endif
.align 3
DoSetToCarSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetToCar	# [0di]
	.byte 0x90
	.asciiz "DoSetToCarLP"
#endif
.align 3
DoSetToCarLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetToCar	# [1]
	.byte 0x84
	.asciiz "DoSetToCarFP"
#endif
.align 3
DoSetToCarFP:	# Entry point for FP relative
.align 3
beginDoSetToCar:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$20, 4($16)	# Get the operand from the stack. [1]
        ldl	$21, 0($16)	#  [1]
        and	$20, 192, $2 	# Save the old CDR code [2di]
	bsr	$0, CarInternal
/* TagType. */
        and	$20, 63, $20 	# [1]
        bis	$20, $2, $20 	# Put back the original CDR codes [1]
        stl	$21, 0($16)	#  [1-]
        stl	$20, 4($16)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetToCarIM"
#endif
DoSetToCarIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetToCar.
.end DoSetToCar
/* End of Halfword operand from stack instruction - DoSetToCar */
.align 5
.globl DoSetToCdr
.ent DoSetToCdr 0
/* Halfword operand from stack instruction - DoSetToCdr */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoSetToCdrFP
	.globl DoSetToCdrSP
	.globl DoSetToCdrLP
	.globl DoSetToCdrIM
.align 3
DoSetToCdr:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoSetToCdrSP"
#endif
.align 3
DoSetToCdrSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoSetToCdr	# [0di]
	.byte 0x90
	.asciiz "DoSetToCdrLP"
#endif
.align 3
DoSetToCdrLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoSetToCdr	# [1]
	.byte 0x84
	.asciiz "DoSetToCdrFP"
#endif
.align 3
DoSetToCdrFP:	# Entry point for FP relative
.align 3
beginDoSetToCdr:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        ldl	$20, 4($16)	# Get the operand from the stack. [1]
        ldl	$21, 0($16)	#  [1]
        and	$20, 192, $2 	# Save the old CDR code [2di]
	bsr	$0, CdrInternal
/* TagType. */
        and	$20, 63, $20 	# [1]
        bis	$20, $2, $20 	# Put back the original CDR codes [1]
        stl	$21, 0($16)	#  [1-]
        stl	$20, 4($16)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoSetToCdrIM"
#endif
DoSetToCdrIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoSetToCdr.
.end DoSetToCdr
/* End of Halfword operand from stack instruction - DoSetToCdr */
.align 5
.globl SetToCdrPushCarLocative
.ent SetToCdrPushCarLocative 0
.align 3
SetToCdrPushCarLocative:
.align 3
SETTOCDRPUSHCARLOCATIVE:
        bis	$31, $2, $17 	# [1-]
/* Memory Read Internal */
G14306:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1di]
        subq	$17, $24, $5 	# Stack cache offset [1-]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$5, $25, $6 	# In range? [1-]
        ldl	$21, 0($21)	#  [0di]
        extbl	$20, $7, $20 	# [1-]
        bne	$6, G14308	# [0di]
G14307:
        lda	$7, 240	#  [1-]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G14310	# [1di]
G14317:
/* TagType. */
        and	$1, 63, $1 	# [1-]
        stl	$21, 8($12)	#  [0di]
        stl	$20, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$1, $3, $1 	# Put back the original CDR codes [1]
        stl	$21, 0($16)	#  [0di]
        stl	$20, 4($16)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14310:
        blbc	$7, G14309	# [1]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G14306	# [1-]
.align 3
G14309:
.align 3
G14308:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G14317	# [1]
.end SetToCdrPushCarLocative
.align 5
.globl DoAssoc
.ent DoAssoc 0
/* Halfword operand from stack instruction - DoAssoc */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoAssocFP
	.globl DoAssocSP
	.globl DoAssocLP
	.globl DoAssocIM
.align 3
DoAssoc:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoAssocSP"
#endif
.align 3
DoAssocSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoAssoc	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoAssoc	# [0di]
	.byte 0x90
	.asciiz "DoAssocLP"
#endif
.align 3
DoAssocLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoAssoc	# [1]
	.byte 0x84
	.asciiz "DoAssocFP"
#endif
.align 3
DoAssocFP:	# Entry point for FP relative
.align 3
beginDoAssoc:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        lda	$5, -2048	#  [0di]
        ldah	$5, 1($5)	#  [1]
        extll	$21, 4, $18 	# [1]
        extll	$21, 0, $19 	# [1]
        ldl	$1, 4($16)	#  [0di]
        ldl	$2, 0($16)	#  [1]
/* TagType. */
        and	$18, 63, $18 	# Get the object type bits [0di]
        srl	$5, $18, $5 	# Low bit will set iff EQ-NOT-EQL [1]
/* TagType. */
        and	$1, 63, $1 	# Strip cdr code [1]
        extll	$2, 0, $2 	# Remove sign-extension [1]
        blbs	$5, ASSOCEXC	# [0di]
        bis	$31, $31, $6 	# [1-]
        br	$31, G14319	# [0di]
.align 3
ASSOCCDR:
        ldq	$6, PROCESSORSTATE_STOP_INTERPRETER($14)	# Have we been asked to stop or trap? [1]
/* Move cdr to car for next carcdr-internal */
/* TagType. */
        and	$20, 63, $1 	# [0di]
        bis	$21, $31, $2 	# [1]
.align 3
G14319:
        subq	$1, TypeNIL, $5 	# [1]
        bne	$6, G14318	# Asked to stop, check for sequence break [1di]
        beq	$5, G14320	# [1]
	bsr	$0, CarCdrInternal
        and	$1, 63, $7 	# Strip off any CDR code bits. [0di]
        cmpeq	$7, TypeList, $8 	# [1]
.align 3
G14338:
        beq	$8, G14322	# [1]
/* Here if argument TypeList */
        bis	$2, $31, $17 	# [0di]
        bis	$20, $31, $3 	# [1]
        bis	$21, $31, $16 	# [1]
/* Memory Read Internal */
G14323:
        addq	$17, $14, $7 	# [1]
        s4addq	$7, $31, $21 	# [1]
        ldq_u	$20, 0($7)	#  [1-]
        subq	$17, $24, $5 	# Stack cache offset [0di]
        ldq	$8, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$5, $25, $6 	# In range? [0di]
        ldl	$21, 0($21)	#  [1-]
        extbl	$20, $7, $20 	# [1di]
        bne	$6, G14325	# [1-]
G14324:
        lda	$7, 240	#  [0di]
        srl	$8, $20, $8 	# [1]
        srl	$7, $20, $7 	# [1]
        blbs	$8, G14327	# [1-]
G14334:
/* TagType. */
        and	$20, 63, $5 	# [0di]
        bis	$3, $31, $20 	# [1]
        subl	$19, $21, $6 	# t6=0 if data same [1]
        bis	$16, $31, $21 	# [1]
        bne	$6, ASSOCCDR	# J. if different [0di]
        subq	$18, $5, $5 	# t5 zero if same tag [1-]
        bne	$5, ASSOCCDR	# J. if tags different [1]
/* we found a match! */
/* TagType. */
        and	$1, 63, $1 	# [1-]
        stl	$2, 0($12)	#  [0di]
        stl	$1, 4($12)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14322:
        cmpeq	$7, TypeNIL, $8 	# [1-]
.align 3
G14339:
        beq	$8, G14335	# [1]
/* Here if argument TypeNIL */
        br	$31, ASSOCCDR	# [1]
.align 3
G14335:
/* Here for all other cases */
/* SetTag. */
        sll	$19, 32, $1 	# [1-]
        bis	$20, $1, $1 	# [2]
        bis	$31, $1, $20 	# [1]
        bis	$31, 14, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G14321:
.align 3
G14320:
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	# Return NIL [1-]
        stq	$1, 0($12)	# push the data [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
ASSOCEXC:
        bis	$31, 0, $18 	# arg3 = stackp [1-]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G14327:
        blbc	$7, G14326	# [1-]
        extll	$21, 0, $17 	# Do the indirect thing [0di]
        br	$31, G14323	# [1-]
.align 3
G14326:
.align 3
G14325:
	bsr	$0, MemoryReadDataDECODE
        br	$31, G14334	# [1]
.align 3
G14318:
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1]
        br	$31, INTERPRETINSTRUCTION	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoAssocIM"
#endif
DoAssocIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoAssoc.
.end DoAssoc
/* End of Halfword operand from stack instruction - DoAssoc */
.align 5
.globl DoMember
.ent DoMember 0
/* Halfword operand from stack instruction - DoMember */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMemberFP
	.globl DoMemberSP
	.globl DoMemberLP
	.globl DoMemberIM
.align 3
DoMember:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMemberSP"
#endif
.align 3
DoMemberSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoMember	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoMember	# [0di]
	.byte 0x90
	.asciiz "DoMemberLP"
#endif
.align 3
DoMemberLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMember	# [1]
	.byte 0x84
	.asciiz "DoMemberFP"
#endif
.align 3
DoMemberFP:	# Entry point for FP relative
.align 3
beginDoMember:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        lda	$5, -2048	#  [0di]
        ldah	$5, 1($5)	#  [1]
        extll	$21, 4, $18 	# [1]
        extll	$21, 0, $19 	# [1]
        ldl	$1, 4($16)	#  [0di]
        ldl	$2, 0($16)	#  [1]
/* TagType. */
        and	$18, 63, $18 	# Get the object type bits [0di]
        srl	$5, $18, $5 	# Low bit will set iff EQ-NOT-EQL [1]
/* TagType. */
        and	$1, 63, $1 	# Strip cdr code [1]
        extll	$2, 0, $2 	# Remove sign-extension [1]
        blbs	$5, MEMBEREXC	# [0di]
        bis	$31, $31, $6 	# [1-]
        br	$31, G14341	# [0di]
.align 3
MEMBERCDR:
        ldq	$6, PROCESSORSTATE_STOP_INTERPRETER($14)	# Have we been asked to stop or trap? [1]
/* Move cdr to car for next carcdr-internal */
/* TagType. */
        and	$20, 63, $1 	# [0di]
        bis	$21, $31, $2 	# [1]
.align 3
G14341:
/* TagType. */
        and	$1, 63, $3 	# [1]
        bis	$2, $31, $16 	# [1]
        subq	$1, TypeNIL, $5 	# [1]
        bne	$6, G14340	# Asked to stop, check for sequence break [0di]
        beq	$5, G14342	# [1]
	bsr	$0, CarCdrInternal
/* TagType. */
        and	$1, 63, $5 	# [1]
        subq	$19, $2, $7 	# t7=0 if data same [1]
        bne	$7, MEMBERCDR	# J. if different [1]
        subq	$18, $5, $6 	# t6 zero if same tag [1-]
        bne	$6, MEMBERCDR	# J. if tags different [1]
/* we found a match! */
        stl	$16, 0($12)	#  [1]
        stl	$3, 4($12)	# write the stack cache [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
G14342:
        ldq	$1, PROCESSORSTATE_NILADDRESS($14)	# Return NIL [1]
        stq	$1, 0($12)	# push the data [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
MEMBEREXC:
        bis	$31, 0, $18 	# arg3 = stackp [1-]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G14340:
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1-]
        br	$31, INTERPRETINSTRUCTION	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoMemberIM"
#endif
DoMemberIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoMember.
.end DoMember
/* End of Halfword operand from stack instruction - DoMember */
.align 5
.globl DoRgetf
.ent DoRgetf 0
/* Halfword operand from stack instruction - DoRgetf */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoRgetfFP
	.globl DoRgetfSP
	.globl DoRgetfLP
	.globl DoRgetfIM
.align 3
DoRgetf:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoRgetfSP"
#endif
.align 3
DoRgetfSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        bne	$17, beginDoRgetf	# [0di]
        ldq	$21, 0($19)	# SP-pop, Reload TOS [1-]
        bis	$12, $31, $16 	# SP-pop mode [0di]
        bis	$19, $31, $12 	# Adjust SP [1]
#ifdef TRACING
        br	$31, beginDoRgetf	# [0di]
	.byte 0x90
	.asciiz "DoRgetfLP"
#endif
.align 3
DoRgetfLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoRgetf	# [1]
	.byte 0x84
	.asciiz "DoRgetfFP"
#endif
.align 3
DoRgetfFP:	# Entry point for FP relative
.align 3
beginDoRgetf:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldl	$25, PROCESSORSTATE_SCOVLIMIT($14)	# Size of the stack cache (words) [1]
        lda	$5, -2048	#  [0di]
        ldah	$5, 1($5)	#  [1]
        extll	$21, 4, $18 	# [1]
        extll	$21, 0, $19 	# [1]
        ldl	$1, 4($16)	#  [0di]
        ldl	$2, 0($16)	#  [1]
/* TagType. */
        and	$18, 63, $18 	# Get the object type bits [0di]
        srl	$5, $18, $5 	# Low bit will set iff EQ-NOT-EQL [1]
/* TagType. */
        and	$1, 63, $1 	# Strip cdr code [1]
        extll	$2, 0, $2 	# Remove sign-extension [1]
        blbs	$5, RGETFEXC	# [0di]
        bis	$31, $31, $6 	# [1-]
        br	$31, G14344	# [0di]
.align 3
RGETFCDR:
	bsr	$0, CdrInternal
        ldq	$6, PROCESSORSTATE_STOP_INTERPRETER($14)	# Have we been asked to stop or trap? [1]
/* Move cdr to car for next carcdr-internal */
/* TagType. */
        and	$20, 63, $1 	# [0di]
        bis	$21, $31, $2 	# [1]
.align 3
G14344:
        subq	$1, TypeNIL, $5 	# [1]
        bne	$6, G14343	# Asked to stop, check for sequence break [1di]
        beq	$5, G14345	# [1]
	bsr	$0, CarCdrInternal
/* TagType. */
        and	$1, 63, $5 	# [1]
        subq	$19, $2, $7 	# t7=0 if data same [1]
        bne	$7, RGETFCDR	# J. if different [1]
        subq	$18, $5, $6 	# t6 zero if same tag [1-]
        bne	$6, RGETFCDR	# J. if tags different [1]
/* we found a match! */
/* TagType. */
        and	$20, 63, $1 	# Strip CDR code [1-]
        subq	$1, TypeNIL, $5 	# t5=0 if end of list [1]
        beq	$5, RGETFEXC	# after all this effort we lose! [1]
        bis	$21, $31, $2 	# [0di]
	bsr	$0, CarInternal
/* TagType. */
        and	$20, 63, $20 	# Strip the CDR code [1]
        stl	$21, 0($12)	#  [0di]
        stl	$20, 4($12)	# write the stack cache [1]
        and	$1, 63, $17 	# set CDR-NEXT [0di]
        stl	$2, 8($12)	# Push the second result [1-]
        stl	$17, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
G14345:
        ldq	$17, PROCESSORSTATE_NILADDRESS($14)	# Return NIL [1]
        stq	$17, 0($12)	#  [1]
        stq	$17, 8($12)	# push the data [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, NEXTINSTRUCTION	# [1-]
.align 3
RGETFEXC:
        bis	$31, 0, $18 	# arg3 = stackp [1-]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
G14343:
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1-]
        br	$31, INTERPRETINSTRUCTION	# [1]
#ifdef TRACING
	.byte 0x82
	.asciiz "DoRgetfIM"
#endif
DoRgetfIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoRgetf.
.end DoRgetf
/* End of Halfword operand from stack instruction - DoRgetf */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunlist.as */
