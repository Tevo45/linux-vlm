/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifungene.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Generic dispatching an method lookup */
.align 5
.globl DoMessageDispatch
.ent DoMessageDispatch 0
/* Halfword operand from stack instruction - DoMessageDispatch */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoMessageDispatchFP
	.globl DoMessageDispatchSP
	.globl DoMessageDispatchLP
	.globl DoMessageDispatchIM
.align 3
DoMessageDispatch:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoMessageDispatchSP"
#endif
.align 3
DoMessageDispatchSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoMessageDispatch	# [0di]
	.byte 0x90
	.asciiz "DoMessageDispatchLP"
#endif
.align 3
DoMessageDispatchLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoMessageDispatch	# [1]
	.byte 0x84
	.asciiz "DoMessageDispatchFP"
#endif
.align 3
DoMessageDispatchFP:	# Entry point for FP relative
.align 3
beginDoMessageDispatch:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$17, PROCESSORSTATE_CONTROL($14)	#  [1]
        ldl	$16, 28($10)	# get message tag and data [1]
        ldl	$1, 24($10)	#  [1]
        and	$17, 255, $20 	# get number of arguments [1-]
        ldl	$18, 20($10)	# get instance tag and data [0di]
        ldl	$19, 16($10)	#  [1]
        subq	$20, 4, $20 	# done if 2 or more arguments (plus 2 extra words) [0di]
        blt	$20, VerifyGenericArity	# [1]
        extll	$1, 0, $1 	# [0di]
        extll	$19, 0, $19 	# [2]
	bsr	$0, LookupHandler
        ldq	$19, 16($10)	# clobbered by |LookupHandler| [1]
        subq	$4, TypeEvenPC, $3 	# [1-]
        and	$3, 62, $3 	# Strip CDR code, low bits [1]
        bne	$3, G14089	# [1]
        and	$6, 63, $3 	# Strip CDR code [1]
        subq	$3, TypeNIL, $3 	# [1]
        beq	$3, G14087	# [1]
        stl	$7, 16($10)	#  [1]
        stl	$6, 20($10)	# write the stack cache [1]
        br	$31, G14088	# [1]
.align 3
G14087:
        stl	$1, 16($10)	# swap message/instance in the frame [1]
        stl	$16, 20($10)	# write the stack cache [1]
.align 3
G14088:
        stq	$19, 24($10)	#  [1]
/* Convert real continuation to PC. */
        and	$4, 1, $9 	# [0di]
        addq	$22, $9, $9 	# [1]
        addq	$22, $9, $9 	# [1]
        br	$31, INTERPRETINSTRUCTIONFORJUMP	# [1-]
.align 3
G14089:
/* Convert stack cache address to VMA */
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        ldq	$3, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $2, $2 	# stack cache base relative offset [2-]
        srl	$2, 3, $2 	# convert byte address to word address [1]
        addq	$2, $3, $3 	# reconstruct VMA [2]
        bis	$31, $3, $20 	# [1]
        bis	$31, 37, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
	.byte 0x82
	.asciiz "DoMessageDispatchIM"
#endif
DoMessageDispatchIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoMessageDispatch.
.end DoMessageDispatch
/* End of Halfword operand from stack instruction - DoMessageDispatch */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifungene.as */
