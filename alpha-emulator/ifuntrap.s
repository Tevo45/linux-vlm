/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifuntrap.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

#include "traps.s"
.align 5
.globl DECODEFAULT
.ent DECODEFAULT 0
.align 3
DECODEFAULT:
/* We come here when a memory access faults to figure out why */
        ldq	$1, PROCESSORSTATE_VMA($14)	# retrieve the trapping VMA [1]
        ldq	$3, PROCESSORSTATE_VMATTRIBUTETABLE($14)	# Per-page attributes table [1]
        srl	$1, MemoryPageAddressShift, $2 	# Index into the attributes table [2-]
        addq	$2, $3, $3 	# Address of the page's attributes [2]
        ldq_u	$2, 0($3)	# Get the quadword with the page's attributes [2]
        stq	$1, PROCESSORSTATE_VMA($14)	# Stash the VMA [1]
        extbl	$2, $3, $2 	# Extract the page's attributes [2-]
        beq	$2, PAGENOTRESIDENT	# Non-existent page [2]
        and	$2, VMAttributeAccessFault, $3 	# [1-]
        bne	$3, PAGEFAULTREQUESTHANDLER	# Access fault [1]
        and	$2, VMAttributeTransportFault, $3 	# [1]
        bne	$3, TRANSPORTTRAP	# Transport fault [1]
        and	$2, VMAttributeWriteFault, $3 	# [1]
        bne	$3, PAGEWRITEFAULT	# Write fault [1]
	br	$31, BUSERROR
.end DECODEFAULT
.align 5
.globl HANDLEUNWINDPROTECT
.ent HANDLEUNWINDPROTECT 0
.align 3
HANDLEUNWINDPROTECT:
        ldl	$4, PROCESSORSTATE_CATCHBLOCK($14)	#  [1-]
        extll	$4, 0, $4 	# [3]
/* Convert VMA to stack cache address */
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$4, $2, $2 	# stack cache base relative offset [2-]
        s8addq	$2, $3, $3 	# reconstruct SCA [1]
        ldl	$6, 16($3)	#  [2]
        ldl	$5, 20($3)	#  [1]
        extll	$6, 0, $6 	# [2-]
        ldl	$2, 8($3)	#  [0di]
        ldl	$1, 12($3)	#  [1]
        extll	$2, 0, $2 	# [2di]
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	# Restore SP [1-]
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
#ifdef MINIMA
        srl	$1, 32, $4 	# [3]
#endif
        subl	$1, $2, $3 	# [1]
        beq	$3, G15864	# J. if binding level= binding stack [1]
#ifdef MINIMA
/* BSP not a locative -> Deep-bound */
        subq	$4, TypeLocative, $3 	# [1]
        and	$3, 63, $3 	# Strip CDR code [1]
        bne	$3, DBUNWINDFRAMETRAP	# [1]
#endif
.align 3
G15865:
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1]
        extll	$1, 0, $1 	# vma only [2-]
        ldah	$16, 512	#  [1]
        subq	$1, 1, $5 	# [1]
        and	$4, $16, $3 	# [1]
        bic	$4, $16, $4 	# Turn off the bit [1]
        bne	$3, G15866	# [0di]
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# Get the SP, ->op2 [1-]
        bis	$31, 0, $20 	# [0di]
        bis	$31, 20, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15866:
/* Memory Read Internal */
G15867:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1-]
        addq	$1, $14, $23 	# [0di]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$23, $31, $6 	# [0di]
        ldq_u	$7, 0($23)	#  [1-]
        subq	$1, $8, $8 	# Stack cache offset [1di]
        ldq	$24, PROCESSORSTATE_BINDREAD_MASK($14)	#  [1-]
        cmpult	$8, $22, $22 	# In range? [0di]
        ldl	$6, 0($6)	#  [1-]
        extbl	$7, $23, $7 	# [0di]
        bne	$22, G15869	# [1-]
G15868:
        lda	$23, 224	#  [0di]
        srl	$24, $7, $24 	# [1]
        srl	$23, $7, $23 	# [1]
        blbs	$24, G15871	# [1-]
G15876:
/* Memory Read Internal */
G15877:
        ldq	$8, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$5, $14, $23 	# [1-]
        ldl	$22, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$23, $31, $16 	# [1-]
        ldq_u	$3, 0($23)	#  [1di]
        subq	$5, $8, $8 	# Stack cache offset [1-]
        ldq	$24, PROCESSORSTATE_BINDREAD_MASK($14)	#  [0di]
        cmpult	$8, $22, $22 	# In range? [1-]
        ldl	$16, 0($16)	#  [0di]
        extbl	$3, $23, $3 	# [1-]
        bne	$22, G15879	# [0di]
G15878:
        lda	$23, 224	#  [1-]
        srl	$24, $3, $24 	# [1]
        srl	$23, $3, $23 	# [1]
        extll	$16, 0, $16 	# [1]
        blbs	$24, G15881	# [1-]
G15886:
/* Memory Read Internal */
G15887:
        ldq	$23, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [0di]
        addq	$16, $14, $25 	# [1-]
        ldl	$24, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$25, $31, $22 	# [1-]
        ldq_u	$8, 0($25)	#  [1di]
        subq	$16, $23, $23 	# Stack cache offset [1-]
        cmpult	$23, $24, $24 	# In range? [1]
        ldl	$22, 0($22)	#  [1-]
        extbl	$8, $25, $8 	# [0di]
        bne	$24, G15889	# [1-]
G15888:
        ldq	$23, PROCESSORSTATE_BINDWRITE_MASK($14)	#  [0di]
        lda	$25, 224	#  [1-]
        srl	$23, $8, $23 	# [2]
        srl	$25, $8, $25 	# [1]
        blbs	$23, G15891	# [1di]
G15896:
/* Merge cdr-code */
        and	$7, 63, $22 	# [1-]
        and	$8, 192, $8 	# [1]
        bis	$8, $22, $8 	# [1]
        addq	$16, $14, $23 	# [1]
        s4addq	$23, $31, $22 	# [1]
        ldq_u	$25, 0($23)	#  [1di]
        insbl	$8, $23, $24 	# [1-]
        mskbl	$25, $23, $25 	# [2]
.align 3
G15899:
        bis	$25, $24, $25 	# [2]
        ldq	$24, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        stq_u	$25, 0($23)	#  [1]
        ldl	$23, PROCESSORSTATE_SCOVLIMIT($14)	#  [1]
        subq	$16, $24, $24 	# Stack cache offset [1-]
        cmpult	$24, $23, $23 	# In range? [2]
        stl	$6, 0($22)	#  [1-]
        bne	$23, G15898	# J. if in cache [1]
G15897:
        and	$3, 64, $3 	# Get the old cleanup-bindings bit [1-]
        sll	$3, 19, $3 	# [1]
        subq	$1, 2, $1 	# [1]
        stl	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	# vma only [0di]
        bis	$4, $3, $4 	# [1-]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [0di]
        ldq	$1, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1]
        subl	$1, $2, $3 	# [3]
        bne	$3, G15865	# J. if binding level/= binding stack [1]
        ldl	$2, PROCESSORSTATE_INTERRUPTREG($14)	#  [0di]
        and	$2, 2, $3 	# [3]
        cmpeq	$3, 2, $3 	# [1]
        bis	$2, $3, $2 	# [2]
        stl	$2, PROCESSORSTATE_INTERRUPTREG($14)	#  [0di]
        beq	$2, G15864	# [1]
        stq	$2, PROCESSORSTATE_STOP_INTERPRETER($14)	#  [1]
.align 3
G15864:	# Push PC with cleanup bits in CDR
/* Convert PC to a real continuation. */
        and	$9, 1, $3 	# [1-]
        srl	$9, 1, $1 	# convert PC to a real word address. [1]
        lda	$3, TypeEvenPC($3)	#  [1]
        ldl	$16, PROCESSORSTATE_CONTROL($14)	#  [0di]
        srl	$16, 17, $2 	# [3]
        bis	$2, 128, $2 	# [2]
        and	$2, 192, $2 	# [1]
/* TagType. */
        and	$3, 63, $3 	# [1]
        bis	$3, $2, $3 	# [1]
        stl	$1, 8($12)	#  [0di]
        stl	$3, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
/* Load catch-block PC */
        ldl	$4, PROCESSORSTATE_CATCHBLOCK($14)	#  [1-]
        extll	$4, 0, $4 	# [3]
/* Convert VMA to stack cache address */
        ldq	$2, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1-]
        ldq	$3, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$4, $2, $2 	# stack cache base relative offset [2-]
        s8addq	$2, $3, $3 	# reconstruct SCA [1]
        ldl	$6, 0($3)	#  [2]
        ldl	$5, 4($3)	#  [1]
        extll	$6, 0, $6 	# [2-]
/* Convert real continuation to PC. */
        and	$5, 1, $9 	# [1]
        addq	$6, $9, $9 	# [1]
        addq	$6, $9, $9 	# [1]
        ldah	$1, 128	#  [1]
        bis	$16, $1, $16 	# [1]
        ldl	$23, 16($3)	#  [1-]
        ldl	$5, 20($3)	#  [1]
        extll	$23, 0, $23 	# [2-]
        and	$5, 128, $6 	# This is the  extra-arg bit [1]
        ldl	$8, PROCESSORSTATE_EXTRAANDCATCH($14)	#  [1-]
        and	$5, 64, $7 	# This is the  cleanup-catch bit [0di]
        sll	$6, 1, $6 	# Shift bit into place for cr [1]
        sll	$7, 20, $7 	# Shift extra arg bit into place for cr [1]
        bic	$16, $8, $16 	# [1]
        bis	$6, $7, $6 	# [1]
        bis	$16, $6, $16 	# update the bits extra-arg/cleanupcatch [1]
        stl	$16, PROCESSORSTATE_CONTROL($14)	#  [0di]
/* TagType. */
        and	$5, 63, $5 	# [1-]
        sll	$5, 32, $5 	# [1]
        bis	$5, $23, $5 	# [2]
        stq	$5, PROCESSORSTATE_CATCHBLOCK($14)	#  [0di]
        br	$31, INTERPRETINSTRUCTIONFORBRANCH	# Execute cleanup [1]
#ifdef MINIMA
.align 3
DBUNWINDFRAMETRAP:
	br	$31, DBUNWINDFRAMETRAP	# Tail call for deep-bound trap
#endif
.align 3
G15898:
        ldq	$23, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$24, $23, $23 	# reconstruct SCA [3]
        stl	$6, 0($23)	# Store in stack [2]
        stl	$8, 4($23)	# write the stack cache [1]
        br	$31, G15897	# [1]
.align 3
G15889:
        ldq	$24, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$23, $24, $23 	# reconstruct SCA [3]
        ldl	$22, 0($23)	#  [2]
        ldl	$8, 4($23)	# Read from stack cache [1]
        br	$31, G15888	# [1]
.align 3
G15891:
        blbc	$25, G15890	# [1]
        extll	$22, 0, $16 	# Do the indirect thing [0di]
        br	$31, G15887	# [1-]
.align 3
G15890:
        ldq	$23, PROCESSORSTATE_BINDWRITE($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$8, 63, $25 	# Discard the CDR code [0di]
        stq	$16, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$25, $23, $25 	# Adjust for a longword load [2di]
        ldl	$23, 0($25)	# Get the memory action [2]
G15893:
/* Perform memory action */
        bis	$31, $23, $16 	# [3]
        bis	$31, 3, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15879:
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $22, $8 	# reconstruct SCA [3]
        ldl	$16, 0($8)	#  [2]
        ldl	$3, 4($8)	# Read from stack cache [1]
        br	$31, G15878	# [1]
.align 3
G15881:
        blbc	$23, G15880	# [1]
        extll	$16, 0, $5 	# Do the indirect thing [0di]
        br	$31, G15877	# [1-]
.align 3
G15880:
        ldq	$24, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$3, 63, $23 	# Discard the CDR code [0di]
        stq	$5, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
G15883:
/* Perform memory action */
        bis	$31, $24, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15869:
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        s8addq	$8, $22, $8 	# reconstruct SCA [3]
        ldl	$6, 0($8)	#  [2]
        ldl	$7, 4($8)	# Read from stack cache [1]
        br	$31, G15868	# [1]
.align 3
G15871:
        blbc	$23, G15870	# [1]
        extll	$6, 0, $1 	# Do the indirect thing [0di]
        br	$31, G15867	# [1-]
.align 3
G15870:
        ldq	$24, PROCESSORSTATE_BINDREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$7, 63, $23 	# Discard the CDR code [0di]
        stq	$1, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$23, $24, $23 	# Adjust for a longword load [2di]
        ldl	$24, 0($23)	# Get the memory action [2]
G15873:
/* Perform memory action */
        bis	$31, $24, $16 	# [3]
        bis	$31, 2, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.end HANDLEUNWINDPROTECT
.align 5
.globl PERFORMMEMORYACTION
.ent PERFORMMEMORYACTION 0
.align 3
PERFORMMEMORYACTION:
/* We get here when a memory action that will trap is detected. */
/* ARG1 contains the memory action code with the Transport bit removed. */
/* ARG2 contains the memory cycle so we can generate the proper microstate. */
        cmpeq	$16, MemoryActionTrap, $1 	# [1]
.align 3
G15928:
        beq	$1, G15901	# [1]
/* Here if argument MemoryActionTrap */
        ldq	$1, PROCESSORSTATE_VMA($14)	# Get the failing VMA [1]
        cmpeq	$17, CycleDataRead, $2 	# [1-]
.align 3
G15915:
        beq	$2, G15903	# [1]
/* Here if argument CycleDataRead */
        bis	$31, $1, $20 	# [1di]
        bis	$31, 57, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15903:
        cmpeq	$17, CycleDataWrite, $2 	# [1]
.align 3
G15916:
        beq	$2, G15904	# [1]
/* Here if argument CycleDataWrite */
        bis	$31, $1, $20 	# [0di]
        bis	$31, 58, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15904:
        cmpeq	$17, CycleBindRead, $2 	# [1]
.align 3
G15917:
        bne	$2, G15906	# [1]
        cmpeq	$17, CycleBindReadNoMonitor, $2 	# [1]
.align 3
G15918:
        beq	$2, G15905	# [1]
.align 3
G15906:
/* Here if argument (CycleBindRead CycleBindReadNoMonitor) */
        bis	$31, $1, $20 	# [1-]
        bis	$31, 54, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15905:
        cmpeq	$17, CycleBindWrite, $2 	# [1]
.align 3
G15919:
        bne	$2, G15908	# [1]
        cmpeq	$17, CycleBindWriteNoMonitor, $2 	# [1]
.align 3
G15920:
        beq	$2, G15907	# [1]
.align 3
G15908:
/* Here if argument (CycleBindWrite CycleBindWriteNoMonitor) */
        bis	$31, $1, $20 	# [1-]
        bis	$31, 55, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15907:
        cmpeq	$17, CycleHeader, $2 	# [1]
.align 3
G15921:
        bne	$2, G15910	# [1]
        cmpeq	$17, CycleStructureOffset, $2 	# [1]
.align 3
G15922:
        beq	$2, G15909	# [1]
.align 3
G15910:
/* Here if argument (CycleHeader CycleStructureOffset) */
        bis	$31, $1, $20 	# [1-]
        bis	$31, 59, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15909:
        cmpeq	$17, CycleScavenge, $2 	# [1]
.align 3
G15923:
        bne	$2, G15912	# [1]
        cmpeq	$17, CycleGCCopy, $2 	# [1]
.align 3
G15924:
        beq	$2, G15911	# [1]
.align 3
G15912:
/* Here if argument (CycleScavenge CycleGCCopy) */
        bis	$31, $1, $20 	# [1-]
        bis	$31, 60, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15911:
        cmpeq	$17, CycleCdr, $2 	# [1]
.align 3
G15925:
        beq	$2, G15902	# [1]
/* Here if argument CycleCdr */
        bis	$31, $1, $20 	# [0di]
        bis	$31, 56, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15902:
.align 3
G15901:
        cmpeq	$16, MemoryActionMonitor, $1 	# [1]
.align 3
G15929:
        beq	$1, G15900	# [1]
/* Here if argument MemoryActionMonitor */
	br	$31, MONITORTRAP
.align 3
G15900:
.end PERFORMMEMORYACTION
.align 5
.globl OutOfLineExceptions
.ent OutOfLineExceptions 0
.align 3
OutOfLineExceptions:
.align 3
LDBEXCEPTION:
        bis	$31, $18, $21 	# arg6 = tag to dispatch on [1-]
        bis	$31, 1, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, NUMERICEXCEPTION
.align 3
RPLACAEXCEPTION:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LISTEXCEPTION
.align 3
RPLACDEXCEPTION:
        bis	$31, $1, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 2, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, LISTEXCEPTION
.align 3
PUSHIVEXCEPTION:
        lda	$1, 8	#  [1]
/* SetTag. */
        sll	$1, 32, $1 	# [1]
        bis	$17, $1, $1 	# [2]
        bis	$31, $2, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, EXCEPTION
.align 3
INCREMENTEXCEPTION:
        bis	$31, $17, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, UNARYNUMERICEXCEPTION
.align 3
DECREMENTEXCEPTION:
        bis	$31, $17, $21 	# arg6 = tag to dispatch on [1]
        bis	$31, 0, $18 	# arg3 = stackp [1]
        bis	$31, 1, $16 	# arg1 = instruction arity [1]
        bis	$31, 0, $19 	# arg4 = arithmeticp [1]
	br	$31, UNARYNUMERICEXCEPTION
.end OutOfLineExceptions
.align 5
.globl NUMERICEXCEPTION
.ent NUMERICEXCEPTION 0
.align 3
NUMERICEXCEPTION:
        subq	$21, TypeFixnum, $1 	# [1]
        and	$1, 56, $1 	# Strip CDR code, low bits [1]
        bne	$1, NOTNUMERIC	# [1]
	br	$31, EXCEPTION	# Numeric
.align 3
NOTNUMERIC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 16, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end NUMERICEXCEPTION
.align 5
.globl UNARYNUMERICEXCEPTION
.ent UNARYNUMERICEXCEPTION 0
.align 3
UNARYNUMERICEXCEPTION:
        subq	$21, TypeFixnum, $1 	# [1]
        and	$1, 56, $1 	# Strip CDR code, low bits [1]
        bne	$1, UNARYNOTNUMERIC	# [1]
	br	$31, EXCEPTION	# Numeric
.align 3
UNARYNOTNUMERIC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 81, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end UNARYNUMERICEXCEPTION
.align 5
.globl LISTEXCEPTION
.ent LISTEXCEPTION 0
.align 3
LISTEXCEPTION:
        subq	$21, TypeList, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, NOTLIST1	# [1]
	br	$31, EXCEPTION	# List
.align 3
NOTLIST1:
        subq	$21, TypeListInstance, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, NOTLIST2	# [1]
	br	$31, EXCEPTION	# List Instance
.align 3
NOTLIST2:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 26, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end LISTEXCEPTION
.align 5
.globl ARRAYEXCEPTION
.ent ARRAYEXCEPTION 0
.align 3
ARRAYEXCEPTION:
        subq	$21, TypeArray, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, NOTARRAY1	# [1]
	br	$31, EXCEPTION	# Array
.align 3
NOTARRAY1:
        subq	$21, TypeArrayInstance, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, NOTARRAY2	# [1]
	br	$31, EXCEPTION	# Array Instance
.align 3
NOTARRAY2:
	br	$31, SPAREEXCEPTION
.end ARRAYEXCEPTION
.align 5
.globl SPAREEXCEPTION
.ent SPAREEXCEPTION 0
.align 3
SPAREEXCEPTION:
        subq	$21, TypeSparePointer1, $1 	# [1]
        and	$1, 62, $1 	# Strip CDR code, low bits [1]
        bne	$1, NOTSPARE1	# [1]
	br	$31, EXCEPTION	# Spare Pointer
.align 3
NOTSPARE1:
.align 3
NOTSPARE2:
        subq	$21, TypeSpareNumber, $1 	# [1]
        and	$1, 63, $1 	# Strip CDR code [1]
        bne	$1, NOTSPARE3	# [1]
	br	$31, EXCEPTION	# Spare Number
.align 3
NOTSPARE3:
	br	$31, ILLEGALOPERAND	# Must be illegal op after all
.end SPAREEXCEPTION
.align 5
.globl EXCEPTION
.ent EXCEPTION 0
.align 3
EXCEPTION:
        bne	$19, ARITHMETICEXCEPTION	# J. if arithmetic exception [1]
        ldq	$2, PROCESSORSTATE_LINKAGE($14)	#  [0di]
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	# fix the stack pointer [1]
        ldq	$17, CACHELINE_INSTRUCTION($13)	# fetch the real opcode [1]
        bne	$2, NativeException	# [1-]
        bne	$18, G15931	# J. if arguments stacked [1]
        extwl	$17, 4, $1 	# Get original operand [1-]
        cmpeq	$1, 512, $3 	# t3 is non-zero iff SP|POP operand [2]
        bne	$3, G15931	# SP|POP operand recovered by restoring SP [1]
        lda	$20, 0($10)	# Assume FP mode [0di]
        lda	$3, -2040($12)	# SP mode constant [1]
        extbl	$17, 5, $4 	# Get the mode bits [1]
        extbl	$17, 4, $2 	# Extract (8-bit, unsigned) operand [1]
        subq	$4, 2, $4 	# t4 = -2 FP, -1 LP, 0 SP, 1 Imm [1]
        cmovlbs	$4, $11, $20 	# LP or Immediate mode [1]
        cmoveq	$4, $3, $20 	# SP mode [1]
        s8addq	$2, $20, $20 	# Compute operand address [2]
        ble	$4, G15932	# Not immediate mode [0di]
        sll	$2, 56, $1 	# [1-]
        srl	$17, 16, $3 	# [1]
        sra	$1, 56, $1 	# [1]
        lda	$20, PROCESSORSTATE_IMMEDIATE_ARG($14)	# Immediate mode constant [1]
        cmovlbc	$3, $1, $2 	# Signed immediate [1]
        stl	$2, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [0di]
.align 3
G15932:
        lda	$1, -32768	#  [1-]
        ldah	$1, 2($1)	#  [1]
        and	$17, $1, $2 	# [1]
        cmpeq	$1, $2, $3 	# [1]
        beq	$3, G15933	# J. if not address-format operand [1]
/* Convert stack cache address to VMA */
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$20, $2, $2 	# stack cache base relative offset [2di]
        srl	$2, 3, $2 	# convert byte address to word address [1]
        addq	$2, $1, $1 	# reconstruct VMA [2]
        bis	$31, TypeLocative, $2 	# [1]
/* SetTag. */
        sll	$2, 32, $20 	# [1]
        bis	$1, $20, $20 	# [2]
        br	$31, G15934	# [0di]
.align 3
G15933:
        ldq	$20, 0($20)	# Fetch the arg [2]
.align 3
G15934:
        stq	$20, 8($12)	#  [1]
        addq	$12, 8, $12 	# [0di]
.align 3
G15931:
        srl	$17, 10, $17 	# Shift opcode into position [1]
        and	$17, 255, $17 	# Just 8-bits of opcode [2]
        lda	$24, TrapVectorInstructionException($17)	#  [1]
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [0di]
        lda	$2, TrapVectorInstructionException	# get the vector index [1-]
        s8addq	$2, $1, $1 	# [2]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [1-]
#endif
        ldq	$25, CACHELINE_NEXTPCDATA($13)	#  [1]
        br	$31, HandleException	# [1]
.end EXCEPTION
.align 5
.globl ARITHMETICEXCEPTION
.ent ARITHMETICEXCEPTION 0
.align 3
ARITHMETICEXCEPTION:
        ldq	$2, PROCESSORSTATE_LINKAGE($14)	#  [1]
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	# fix the stack pointer [1]
        ldq	$17, CACHELINE_INSTRUCTION($13)	# fetch the real opcode [1]
        bne	$2, NativeException	# [1di]
        srl	$17, 10, $17 	# get opcode into low byte [2-]
        and	$17, 255, $17 	# low byte only [2]
        cmpeq	$17, OpcodeDoubleFloatOp, $17 	# is it DoubleFloatOp ? [1]
        beq	$17, G15941	# not a doublefloat [1]
	br	$31, DOUBLEFLOATEXC	# it's a double float exc
.align 3
G15941:
        ldq	$17, CACHELINE_INSTRUCTION($13)	# fetch the real opcode again [1]
        extwl	$17, 4, $1 	# Get original operand [3]
        cmpeq	$1, 512, $3 	# t3 is non-zero iff SP|POP operand [2]
        bne	$3, G15937	# SP|POP operand recovered by restoring SP [1]
        lda	$20, 0($10)	# Assume FP mode [1-]
        lda	$3, -2040($12)	# SP mode constant [1]
        extbl	$17, 5, $4 	# Get the mode bits [1]
        extbl	$17, 4, $2 	# Extract (8-bit, unsigned) operand [1]
        subq	$4, 2, $4 	# t4 = -2 FP, -1 LP, 0 SP, 1 Imm [1]
        cmovlbs	$4, $11, $20 	# LP or Immediate mode [1]
        cmoveq	$4, $3, $20 	# SP mode [1]
        s8addq	$2, $20, $20 	# Compute operand address [2]
        ble	$4, G15938	# Not immediate mode [1-]
        sll	$2, 56, $1 	# [0di]
        srl	$17, 16, $3 	# [1]
        sra	$1, 56, $1 	# [1]
        lda	$20, PROCESSORSTATE_IMMEDIATE_ARG($14)	# Immediate mode constant [1]
        cmovlbc	$3, $1, $2 	# Signed immediate [1]
        stl	$2, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
.align 3
G15938:
        lda	$1, -32768	#  [1-]
        ldah	$1, 2($1)	#  [1]
        and	$17, $1, $2 	# [1]
        cmpeq	$1, $2, $3 	# [1]
        beq	$3, G15939	# J. if not address-format operand [1]
/* Convert stack cache address to VMA */
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$20, $2, $2 	# stack cache base relative offset [2di]
        srl	$2, 3, $2 	# convert byte address to word address [1]
        addq	$2, $1, $1 	# reconstruct VMA [2]
        bis	$31, TypeLocative, $2 	# [1]
/* SetTag. */
        sll	$2, 32, $20 	# [1]
        bis	$1, $20, $20 	# [2]
        br	$31, G15940	# [0di]
.align 3
G15939:
        ldq	$20, 0($20)	# Fetch the arg [2]
.align 3
G15940:
        stq	$20, 8($12)	#  [1]
        addq	$12, 8, $12 	# [0di]
.align 3
G15937:
        srl	$17, 17, $4 	# Get unary/nary bit of opcode [1]
        bis	$31, 1, $16 	# Assume unary [1]
        bis	$31, $31, $24 	# [1]
        bis	$12, $31, $2 	# [1]
        blbc	$4, G15936	# J. if not binary arithmetic dispatch [1-]
        bis	$31, 2, $16 	# Nary -> Binary [0di]
        ldl	$24, 4($12)	#  [1-]
        subq	$2, 8, $2 	# [0di]
        and	$24, 7, $24 	# low three bits has opcode tag for op2 [3]
.align 3
G15936:
        srl	$17, 4, $17 	# Shift opcode into position [1]
        ldl	$2, 4($2)	#  [0di]
        and	$17, 1984, $17 	# five bits from the opcode [2-]
        and	$2, 7, $2 	# [1]
        s8addq	$2, $24, $24 	# [1]
        bis	$17, $24, $24 	# [1]
        lda	$24, TrapVectorArithmeticInstructionException($24)	#  [1]
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [0di]
        lda	$2, TrapVectorArithmeticInstructionException	# get the vector index [1-]
        s8addq	$2, $1, $1 	# [2]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [1-]
#endif
        ldq	$25, CACHELINE_NEXTPCDATA($13)	#  [1]
        br	$31, HandleException	# [1]
.end ARITHMETICEXCEPTION
.align 5
.globl LOOPEXCEPTION
.ent LOOPEXCEPTION 0
.align 3
LOOPEXCEPTION:
        ldq	$2, PROCESSORSTATE_LINKAGE($14)	#  [1]
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	# fix the stack pointer [1]
        ldq	$17, CACHELINE_INSTRUCTION($13)	# fetch the real opcode [1]
        bne	$2, NativeException	# [1di]
        bne	$18, G15943	# J. if arguments stacked [1]
        extwl	$17, 4, $1 	# Get original operand [1di]
        cmpeq	$1, 512, $3 	# t3 is non-zero iff SP|POP operand [2]
        bne	$3, G15943	# SP|POP operand recovered by restoring SP [1]
        lda	$20, 0($10)	# Assume FP mode [1-]
        lda	$3, -2040($12)	# SP mode constant [1]
        extbl	$17, 5, $4 	# Get the mode bits [1]
        extbl	$17, 4, $2 	# Extract (8-bit, unsigned) operand [1]
        subq	$4, 2, $4 	# t4 = -2 FP, -1 LP, 0 SP, 1 Imm [1]
        cmovlbs	$4, $11, $20 	# LP or Immediate mode [1]
        cmoveq	$4, $3, $20 	# SP mode [1]
        s8addq	$2, $20, $20 	# Compute operand address [2]
        ble	$4, G15944	# Not immediate mode [1-]
        sll	$2, 56, $1 	# [0di]
        srl	$17, 16, $3 	# [1]
        sra	$1, 56, $1 	# [1]
        lda	$20, PROCESSORSTATE_IMMEDIATE_ARG($14)	# Immediate mode constant [1]
        cmovlbc	$3, $1, $2 	# Signed immediate [1]
        stl	$2, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
.align 3
G15944:
        lda	$1, -32768	#  [1-]
        ldah	$1, 2($1)	#  [1]
        and	$17, $1, $2 	# [1]
        cmpeq	$1, $2, $3 	# [1]
        beq	$3, G15945	# J. if not address-format operand [1]
/* Convert stack cache address to VMA */
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$1, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$20, $2, $2 	# stack cache base relative offset [2di]
        srl	$2, 3, $2 	# convert byte address to word address [1]
        addq	$2, $1, $1 	# reconstruct VMA [2]
        bis	$31, TypeLocative, $2 	# [1]
/* SetTag. */
        sll	$2, 32, $20 	# [1]
        bis	$1, $20, $20 	# [2]
        br	$31, G15946	# [0di]
.align 3
G15945:
        ldq	$20, 0($20)	# Fetch the arg [2]
.align 3
G15946:
        stq	$20, 8($12)	#  [1]
        addq	$12, 8, $12 	# [0di]
.align 3
G15943:
        srl	$17, 10, $17 	# Shift opcode into position [1]
        and	$17, 255, $17 	# Just 8-bits of opcode [2]
        lda	$24, TrapVectorInstructionException($17)	#  [1]
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [0di]
        lda	$2, TrapVectorInstructionException	# get the vector index [1-]
        s8addq	$2, $1, $1 	# [2]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [1-]
#endif
        bis	$20, $31, $25 	# [0di]
        br	$31, HandleException	# [1-]
.end LOOPEXCEPTION
.align 5
.globl HandleException
.ent HandleException 3
.align 3
HandleException:
        bis	$10, $31, $1 	# save old frame pointer [1-]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [0di]
        ldq	$22, PROCESSORSTATE_FEPMODETRAPVECADDRESS($14)	#  [1]
        ldq	$8, PROCESSORSTATE_TRAPVECBASE($14)	#  [1]
        ldah	$5, -16384	#  [1-]
        srl	$4, 30, $6 	# [1]
        bis	$4, $5, $5 	# Set trap mode to 3 [1]
        and	$6, 3, $6 	# [1]
        stl	$5, PROCESSORSTATE_CONTROL($14)	#  [1-]
        subq	$6, 3, $7 	# [0di]
        addq	$8, $24, $8 	# [1]
        cmoveq	$7, $22, $8 	# [1]
        stq	$8, PROCESSORSTATE_TVI($14)	# Record TVI for tracing (if enabled) [1-]
/* Memory Read Internal */
G15951:
        ldq	$22, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1]
        addq	$8, $14, $6 	# [1-]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [0di]
        s4addq	$6, $31, $3 	# [1-]
        ldq_u	$2, 0($6)	#  [1di]
        subq	$8, $22, $22 	# Stack cache offset [1-]
        ldq	$5, PROCESSORSTATE_DATAREAD_MASK($14)	#  [0di]
        cmpult	$22, $7, $7 	# In range? [1-]
        ldl	$3, 0($3)	#  [0di]
        extbl	$2, $6, $2 	# [1-]
        bne	$7, G15953	# [0di]
G15952:
        lda	$6, 240	#  [1-]
        srl	$5, $2, $5 	# [1]
        srl	$6, $2, $6 	# [1]
        extll	$3, 0, $3 	# [1]
        blbs	$5, G15955	# [1-]
G15962:
        subq	$2, TypeEvenPC, $5 	# [1]
        and	$5, 62, $5 	# Strip CDR code, low bits [1]
        bne	$5, G15950	# [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	# Restore the cr [1]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [1]
        lda	$5, 128	#  [1-]
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [0di]
        addq	$5, 8, $5 	# Account for what we're about to push [1-]
        s8addq	$5, $12, $5 	# SCA of desired end of cache [1]
        s8addq	$8, $6, $6 	# SCA of current end of cache [1]
        cmple	$5, $6, $8 	# [1]
        beq	$8, G15963	# We're done if new SCA is within bounds [1]
        s8addq	$16, $31, $10 	# [0di]
        subq	$12, $10, $10 	# [1]
        addq	$10, 8, $10 	# [1]
        beq	$16, G15948	# [1-]
        ldq	$5, 0($12)	#  [0di]
        stq	$5, 32($12)	#  [1]
        subq	$16, 1, $16 	# [0di]
        beq	$16, G15948	# [1]
        ldq	$5, -8($12)	#  [0di]
        stq	$5, 24($12)	#  [1]
        subq	$16, 1, $16 	# [0di]
        beq	$16, G15948	# [1]
        ldq	$5, -16($12)	#  [0di]
        stq	$5, 16($12)	#  [1]
        subq	$16, 1, $16 	# [0di]
        beq	$16, G15948	# [1]
        ldq	$5, -24($12)	#  [0di]
        stq	$5, 8($12)	#  [1]
        subq	$16, 1, $16 	# [0di]
.align 3
G15948:
        addq	$12, 32, $12 	# [1]
        ldl	$5, PROCESSORSTATE_CONTINUATION($14)	#  [0di]
        ldl	$7, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        extll	$5, 0, $5 	# [2di]
        ldah	$8, 8192	#  [1]
        extll	$4, 0, $4 	# [1]
        bis	$7, 192, $7 	# [1]
        stl	$5, 0($10)	#  [0di]
        stl	$7, 4($10)	# write the stack cache [1]
        and	$4, $8, $8 	# [0di]
        srl	$8, 2, $8 	# [1]
        bis	$31, TypeFixnum+0xC0, $6 	# [1]
        bis	$4, $8, $8 	# [1]
        stl	$8, 8($10)	#  [0di]
        stl	$6, 12($10)	# write the stack cache [1]
        addq	$12, 8, $11 	# [0di]
        bis	$31, TypeFixnum, $6 	# [1]
        bis	$31, $24, $8 	# [1]
        stl	$8, 16($10)	#  [1-]
        stl	$6, 20($10)	# write the stack cache [1]
/* Convert PC to a real continuation. */
        and	$9, 1, $6 	# [1]
        srl	$9, 1, $8 	# convert PC to a real word address. [1]
        lda	$6, TypeEvenPC($6)	#  [1]
        stl	$8, 24($10)	#  [0di]
        stl	$6, 28($10)	# write the stack cache [1]
        ldq	$7, PROCESSORSTATE_FCCRTRAPMASK($14)	# Get CR mask [1]
        ldah	$5, ValueDispositionValue*4	# 1<<18! [1-]
        subq	$11, $10, $6 	# Arg size [1]
        subq	$10, $1, $8 	# Caller Frame Size [1]
        srl	$6, 3, $6 	# Arg size in words [1]
        sll	$8, 6, $8 	# Caller Frame Size in words in place [1]
        bis	$5, $6, $5 	# [1]
        bis	$5, $8, $5 	# [1]
/* TagCdr. */
        srl	$2, 6, $22 	# [1]
        srl	$4, 30, $6 	# [1]
        subq	$22, $6, $8 	# [2]
        cmovge	$8, $22, $6 	# [1]
        sll	$6, 30, $6 	# [2]
        and	$4, $7, $4 	# Mask off unwanted bits [1]
        bis	$4, $6, $4 	# Add trap mode [1]
        bis	$4, $5, $4 	# Add argsize, apply, disposition, caller FS [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [0di]
/* Convert PC to a real continuation. */
        and	$25, 1, $6 	# [1-]
        srl	$25, 1, $8 	# convert PC to a real word address. [1]
        lda	$6, TypeEvenPC($6)	#  [1]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [0di]
        stl	$6, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        stl	$8, PROCESSORSTATE_CONTINUATION($14)	#  [1]
/* Convert real continuation to PC. */
        and	$2, 1, $9 	# [1-]
        addq	$3, $9, $9 	# [1]
        addq	$3, $9, $9 	# [1]
        srl	$4, 30, $6 	# Save current trap mode [1]
        srl	$4, 30, $4 	# Isolate trap mode [1]
        ldl	$8, PROCESSORSTATE_CSLIMIT($14)	# Limit for emulator mode [0di]
        ldl	$22, PROCESSORSTATE_CSEXTRALIMIT($14)	# Limit for extra stack and higher modes [1]
        cmovne	$4, $22, $8 	# Get the right limit for the current trap mode [3]
        extll	$8, 0, $8 	# Might have been sign extended [2]
/* Convert stack cache address to VMA */
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $22, $22 	# stack cache base relative offset [2di]
        srl	$22, 3, $22 	# convert byte address to word address [1]
        addq	$22, $4, $4 	# reconstruct VMA [2]
        cmplt	$4, $8, $22 	# Check for overflow [1]
        beq	$22, G15949	# Jump if overflow [1]
/* Convert a halfword address into a CP pointer. */
        srl	$9, CacheLineRShift, $13 	# Get third byte into bottom [1-]
        ldq	$22, PROCESSORSTATE_ICACHEBASE($14)	# get the base of the icache [0di]
        lda	$8, -1	#  [1-]
        ldah	$8, 4($8)	#  [1]
        sll	$13, CacheLineLShift, $13 	# Now third byte is zero-shifted [1]
        addq	$9, $13, $13 	# [2]
        and	$13, $8, $13 	# [1]
        sll	$13, 5, $8 	# temp=cpos*32 [1]
        sll	$13, 4, $13 	# cpos=cpos*16 [1]
        addq	$22, $8, $22 	# temp2=base+cpos*32 [1]
        addq	$22, $13, $13 	# cpos=base+cpos*48 [1]
        br	$31, CACHEVALID	# [0di]
.align 3
G15949:
        beq	$6, STACKOVERFLOW	# Take the overflow if in emulator mode [1]
	br	$31, FATALSTACKOVERFLOW
.align 3
G15963:
        bis	$31, 8, $17 	# [1-]
        br	$31, StackCacheOverflowHandler	# [0di]
.align 3
G15953:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$22, $7, $22 	# reconstruct SCA [3]
        ldl	$3, 0($22)	#  [2]
        ldl	$2, 4($22)	# Read from stack cache [1]
        br	$31, G15952	# [1]
.align 3
G15955:
        blbc	$6, G15954	# [1]
        extll	$3, 0, $8 	# Do the indirect thing [0di]
        br	$31, G15951	# [1-]
.align 3
G15954:
        ldq	$5, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$8, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $5, $6 	# Adjust for a longword load [2di]
        ldl	$5, 0($6)	# Get the memory action [2]
.align 3
G15959:
        and	$5, MemoryActionTransform, $6 	# [3]
        beq	$6, G15958	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G15962	# [1-]
#ifndef MINIMA
G15958:
#endif
#ifdef MINIMA
.align 3
G15958:
        and	$5, MemoryActionBinding, $6 	# [1-]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$6, G15957	# [1-]
        sll	$8, 1, $22 	# [0di]
        ldq	$6, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$22, $7, $22 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$22, $6, $22 	# [1]
        extll	$22, 0, $22 	# Clear sign-extension [1]
        s4addq	$22, $7, $7 	# [2]
        ldl	$22, 0($7)	# Fetch the key [2]
        ldl	$3, 4($7)	# Fetch value [1]
        subl	$8, $22, $6 	# Compare [2di]
        bne	$6, G15961	# Trap on miss [1]
        extll	$3, 0, $8 	# Extract the pointer, and indirect [0di]
        br	$31, G15951	# This is another memory read tailcall. [1-]
.align 3
G15961:
	br	$31, DBCACHEMISSTRAP
#endif
G15957:
/* Perform memory action */
        bis	$31, $5, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15950:
	br	$31, ILLEGALTRAPVECTOR
.end HandleException
.align 5
.globl STACKOVERFLOW
.ent STACKOVERFLOW 0
.align 3
STACKOVERFLOW:
        stq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1-]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
        ldq	$22, PROCESSORSTATE_FEPMODETRAPVECADDRESS($14)	#  [1]
        ldq	$8, PROCESSORSTATE_TRAPVECBASE($14)	#  [1]
        ldah	$5, -16384	#  [0di]
        srl	$4, 30, $6 	# [1]
        bis	$4, $5, $5 	# Set trap mode to 3 [1]
        and	$6, 3, $6 	# [1]
        stl	$5, PROCESSORSTATE_CONTROL($14)	#  [0di]
        subq	$6, 3, $7 	# [1-]
        addq	$8, TrapVectorStackOverflow, $8 	# [1]
        cmoveq	$7, $22, $8 	# [1]
        stq	$8, PROCESSORSTATE_TVI($14)	# Record TVI for tracing (if enabled) [0di]
/* Memory Read Internal */
G15967:
        ldq	$22, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1]
        addq	$8, $14, $6 	# [1di]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$6, $31, $3 	# [0di]
        ldq_u	$2, 0($6)	#  [1-]
        subq	$8, $22, $22 	# Stack cache offset [0di]
        ldq	$5, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$22, $7, $7 	# In range? [1di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$2, $6, $2 	# [0di]
        bne	$7, G15969	# [1-]
G15968:
        lda	$6, 240	#  [0di]
        srl	$5, $2, $5 	# [1]
        srl	$6, $2, $6 	# [1]
        extll	$3, 0, $3 	# [1]
        blbs	$5, G15971	# [0di]
G15978:
        subq	$2, TypeEvenPC, $5 	# [1]
        and	$5, 62, $5 	# Strip CDR code, low bits [1]
        bne	$5, G15966	# [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	# Restore the cr [1]
        ldl	$8, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [1]
        lda	$5, 128	#  [0di]
        ldq	$6, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1-]
        addq	$5, 8, $5 	# Account for what we're about to push [0di]
        s8addq	$5, $12, $5 	# SCA of desired end of cache [1]
        s8addq	$8, $6, $6 	# SCA of current end of cache [2]
        cmple	$5, $6, $8 	# [1]
        beq	$8, G15979	# We're done if new SCA is within bounds [1]
        s8addq	$31, $31, $10 	# [1-]
        subq	$12, $10, $10 	# [1]
        addq	$10, 8, $10 	# [1]
        beq	$31, G15964	# [0di]
        ldq	$5, 0($12)	#  [1-]
        stq	$5, 32($12)	#  [1]
        subq	$31, 1, $31 	# [1-]
        beq	$31, G15964	# [1]
        ldq	$5, -8($12)	#  [1-]
        stq	$5, 24($12)	#  [1]
        subq	$31, 1, $31 	# [1-]
        beq	$31, G15964	# [1]
        ldq	$5, -16($12)	#  [1-]
        stq	$5, 16($12)	#  [1]
        subq	$31, 1, $31 	# [1-]
        beq	$31, G15964	# [1]
        ldq	$5, -24($12)	#  [1-]
        stq	$5, 8($12)	#  [1]
        subq	$31, 1, $31 	# [1-]
.align 3
G15964:
        addq	$12, 32, $12 	# [1]
        ldl	$5, PROCESSORSTATE_CONTINUATION($14)	#  [0di]
        ldl	$7, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        extll	$5, 0, $5 	# [2di]
        ldah	$8, 8192	#  [1]
        extll	$4, 0, $4 	# [1]
        bis	$7, 192, $7 	# [1]
        stl	$5, 0($10)	#  [0di]
        stl	$7, 4($10)	# write the stack cache [1]
        and	$4, $8, $8 	# [0di]
        srl	$8, 2, $8 	# [1]
        bis	$31, TypeFixnum+0xC0, $6 	# [1]
        bis	$4, $8, $8 	# [1]
        stl	$8, 8($10)	#  [0di]
        stl	$6, 12($10)	# write the stack cache [1]
        addq	$12, 8, $11 	# [0di]
        bis	$31, TypeFixnum, $6 	# [1]
        bis	$31, TrapVectorStackOverflow, $8 	# [1]
        stl	$8, 16($10)	#  [1-]
        stl	$6, 20($10)	# write the stack cache [1]
/* Convert PC to a real continuation. */
        and	$9, 1, $6 	# [1]
        srl	$9, 1, $8 	# convert PC to a real word address. [1]
        lda	$6, TypeEvenPC($6)	#  [1]
        stl	$8, 24($10)	#  [0di]
        stl	$6, 28($10)	# write the stack cache [1]
        ldq	$7, PROCESSORSTATE_FCCRTRAPMASK($14)	# Get CR mask [1]
        ldah	$5, ValueDispositionValue*4	# 1<<18! [1-]
        subq	$11, $10, $6 	# Arg size [1]
        subq	$10, $1, $8 	# Caller Frame Size [1]
        srl	$6, 3, $6 	# Arg size in words [1]
        sll	$8, 6, $8 	# Caller Frame Size in words in place [1]
        bis	$5, $6, $5 	# [1]
        bis	$5, $8, $5 	# [1]
/* TagCdr. */
        srl	$2, 6, $22 	# [1]
        srl	$4, 30, $6 	# [1]
        subq	$22, $6, $8 	# [2]
        cmovge	$8, $22, $6 	# [1]
        sll	$6, 30, $6 	# [2]
        and	$4, $7, $4 	# Mask off unwanted bits [1]
        bis	$4, $6, $4 	# Add trap mode [1]
        bis	$4, $5, $4 	# Add argsize, apply, disposition, caller FS [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	#  [0di]
/* Convert PC to a real continuation. */
        and	$9, 1, $6 	# [1-]
        srl	$9, 1, $8 	# convert PC to a real word address. [1]
        lda	$6, TypeEvenPC($6)	#  [1]
        stq	$31, PROCESSORSTATE_CONTINUATIONCP($14)	#  [0di]
        stl	$6, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        stl	$8, PROCESSORSTATE_CONTINUATION($14)	#  [1]
/* Convert real continuation to PC. */
        and	$2, 1, $9 	# [1-]
        addq	$3, $9, $9 	# [1]
        addq	$3, $9, $9 	# [1]
        srl	$4, 30, $6 	# Save current trap mode [1]
        srl	$4, 30, $4 	# Isolate trap mode [1]
        ldl	$8, PROCESSORSTATE_CSLIMIT($14)	# Limit for emulator mode [0di]
        ldl	$22, PROCESSORSTATE_CSEXTRALIMIT($14)	# Limit for extra stack and higher modes [1]
        cmovne	$4, $22, $8 	# Get the right limit for the current trap mode [3]
        extll	$8, 0, $8 	# Might have been sign extended [2]
/* Convert stack cache address to VMA */
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [0di]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $22, $22 	# stack cache base relative offset [2di]
        srl	$22, 3, $22 	# convert byte address to word address [1]
        addq	$22, $4, $4 	# reconstruct VMA [2]
        cmplt	$4, $8, $22 	# Check for overflow [1]
        beq	$22, G15965	# Jump if overflow [1]
/* Convert a halfword address into a CP pointer. */
        srl	$9, CacheLineRShift, $13 	# Get third byte into bottom [1-]
        ldq	$22, PROCESSORSTATE_ICACHEBASE($14)	# get the base of the icache [0di]
        lda	$8, -1	#  [1-]
        ldah	$8, 4($8)	#  [1]
        sll	$13, CacheLineLShift, $13 	# Now third byte is zero-shifted [1]
        addq	$9, $13, $13 	# [2]
        and	$13, $8, $13 	# [1]
        sll	$13, 5, $8 	# temp=cpos*32 [1]
        sll	$13, 4, $13 	# cpos=cpos*16 [1]
        addq	$22, $8, $22 	# temp2=base+cpos*32 [1]
        addq	$22, $13, $13 	# cpos=base+cpos*48 [1]
        br	$31, CACHEVALID	# [0di]
.align 3
G15965:
        beq	$6, STACKOVERFLOW	# Take the overflow if in emulator mode [1]
	br	$31, FATALSTACKOVERFLOW
.align 3
G15979:
        bis	$31, 8, $17 	# [1-]
        br	$31, StackCacheOverflowHandler	# [0di]
.align 3
G15969:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$22, $7, $22 	# reconstruct SCA [3]
        ldl	$3, 0($22)	#  [2]
        ldl	$2, 4($22)	# Read from stack cache [1]
        br	$31, G15968	# [1]
.align 3
G15971:
        blbc	$6, G15970	# [1]
        extll	$3, 0, $8 	# Do the indirect thing [0di]
        br	$31, G15967	# [1-]
.align 3
G15970:
        ldq	$5, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$8, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $5, $6 	# Adjust for a longword load [2di]
        ldl	$5, 0($6)	# Get the memory action [2]
.align 3
G15975:
        and	$5, MemoryActionTransform, $6 	# [3]
        beq	$6, G15974	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G15978	# [1-]
#ifndef MINIMA
G15974:
#endif
#ifdef MINIMA
.align 3
G15974:
        and	$5, MemoryActionBinding, $6 	# [1-]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$6, G15973	# [1-]
        sll	$8, 1, $22 	# [0di]
        ldq	$6, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$22, $7, $22 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$22, $6, $22 	# [1]
        extll	$22, 0, $22 	# Clear sign-extension [1]
        s4addq	$22, $7, $7 	# [2]
        ldl	$22, 0($7)	# Fetch the key [2]
        ldl	$3, 4($7)	# Fetch value [1]
        subl	$8, $22, $6 	# Compare [2di]
        bne	$6, G15977	# Trap on miss [1]
        extll	$3, 0, $8 	# Extract the pointer, and indirect [0di]
        br	$31, G15967	# This is another memory read tailcall. [1-]
.align 3
G15977:
	br	$31, DBCACHEMISSTRAP
#endif
G15973:
/* Perform memory action */
        bis	$31, $5, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15966:
	br	$31, ILLEGALTRAPVECTOR
.end STACKOVERFLOW
.align 5
.globl StartPreTrap
.ent StartPreTrap 0
.align 3
StartPreTrap:
        ldq	$2, PROCESSORSTATE_LINKAGE($14)	#  [1-]
        bne	$2, NativeException	# [3]
        ldl	$4, PROCESSORSTATE_CONTROL($14)	#  [1-]
        ldq	$22, PROCESSORSTATE_FEPMODETRAPVECADDRESS($14)	#  [1]
        ldq	$8, PROCESSORSTATE_TRAPVECBASE($14)	#  [1]
        ldah	$5, -16384	#  [0di]
        srl	$4, 30, $6 	# [1]
        bis	$4, $5, $5 	# Set trap mode to 3 [1]
        and	$6, 3, $6 	# [1]
        stl	$5, PROCESSORSTATE_CONTROL($14)	#  [0di]
        subq	$6, 3, $7 	# [1-]
        addq	$8, $23, $8 	# [1]
        cmoveq	$7, $22, $8 	# [1]
        stq	$8, PROCESSORSTATE_TVI($14)	# Record TVI for tracing (if enabled) [0di]
/* Memory Read Internal */
G15981:
        ldq	$22, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of stack cache [1]
        addq	$8, $14, $6 	# [1di]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	#  [1-]
        s4addq	$6, $31, $3 	# [0di]
        ldq_u	$2, 0($6)	#  [1-]
        subq	$8, $22, $22 	# Stack cache offset [0di]
        ldq	$5, PROCESSORSTATE_DATAREAD_MASK($14)	#  [1-]
        cmpult	$22, $7, $7 	# In range? [1di]
        ldl	$3, 0($3)	#  [1-]
        extbl	$2, $6, $2 	# [0di]
        bne	$7, G15983	# [1-]
G15982:
        lda	$6, 240	#  [0di]
        srl	$5, $2, $5 	# [1]
        srl	$6, $2, $6 	# [1]
        extll	$3, 0, $3 	# [1]
        blbs	$5, G15985	# [0di]
G15992:
        subq	$2, TypeEvenPC, $5 	# [1]
        and	$5, 62, $5 	# Strip CDR code, low bits [1]
        bne	$5, G15980	# [1]
        stl	$4, PROCESSORSTATE_CONTROL($14)	# Restore the cr [1]
        ldq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1]
        ldl	$7, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [1]
        lda	$4, 128	#  [1-]
        ldq	$5, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [0di]
        addq	$4, 8, $4 	# Account for what we're about to push [1-]
        s8addq	$4, $12, $4 	# SCA of desired end of cache [1]
        s8addq	$7, $5, $5 	# SCA of current end of cache [1]
        cmple	$4, $5, $7 	# [1]
        beq	$7, G15993	# We're done if new SCA is within bounds [1]
        ldl	$5, PROCESSORSTATE_CONTINUATION($14)	#  [0di]
        ldl	$4, PROCESSORSTATE_CONTINUATION+4($14)	#  [1]
        extll	$5, 0, $5 	# [2di]
        ldl	$7, PROCESSORSTATE_CONTROL($14)	#  [1-]
        extll	$7, 0, $7 	# [3]
        bis	$4, 192, $4 	# [1]
        stl	$5, 8($12)	#  [0di]
        stl	$4, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$31, TypeFixnum+0xC0, $6 	# [1]
        stl	$7, 8($12)	#  [1di]
        stl	$6, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$31, $23, $6 	# [1]
        bis	$31, TypeFixnum, $8 	# [1]
        stl	$6, 8($12)	#  [1-]
        stl	$8, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
/* Convert PC to a real continuation. */
        and	$9, 1, $6 	# [1]
        srl	$9, 1, $8 	# convert PC to a real word address. [1]
        lda	$6, TypeEvenPC($6)	#  [1]
        stl	$6, PROCESSORSTATE_CONTINUATION+4($14)	#  [1-]
        stl	$8, PROCESSORSTATE_CONTINUATION($14)	#  [1]
        stq	$13, PROCESSORSTATE_CONTINUATIONCP($14)	#  [1]
        and	$6, 63, $22 	# set CDR-NEXT [0di]
        stl	$8, 8($12)	#  [1-]
        stl	$22, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        ret	$31, ($0), 1	# [0di]
.align 3
G15993:
        bis	$31, 8, $17 	# [3]
        br	$31, StackCacheOverflowHandler	# [0di]
.align 3
G15983:
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        s8addq	$22, $7, $22 	# reconstruct SCA [3]
        ldl	$3, 0($22)	#  [2]
        ldl	$2, 4($22)	# Read from stack cache [1]
        br	$31, G15982	# [1]
.align 3
G15985:
        blbc	$6, G15984	# [1]
        extll	$3, 0, $8 	# Do the indirect thing [0di]
        br	$31, G15981	# [1-]
.align 3
G15984:
        ldq	$5, PROCESSORSTATE_DATAREAD($14)	# Load the memory action table for cycle [1]
/* TagType. */
        and	$2, 63, $6 	# Discard the CDR code [0di]
        stq	$8, PROCESSORSTATE_VMA($14)	# stash the VMA for the (likely) trap [1-]
        s4addq	$6, $5, $6 	# Adjust for a longword load [2di]
        ldl	$5, 0($6)	# Get the memory action [2]
.align 3
G15989:
        and	$5, MemoryActionTransform, $6 	# [3]
        beq	$6, G15988	# [1]
        bic	$2, 63, $2 	# [1-]
        bis	$2, TypeExternalValueCellPointer, $2 	# [1]
        br	$31, G15992	# [1-]
#ifndef MINIMA
G15988:
#endif
#ifdef MINIMA
.align 3
G15988:
        and	$5, MemoryActionBinding, $6 	# [1-]
        ldq	$7, PROCESSORSTATE_DBCMASK($14)	#  [0di]
        beq	$6, G15987	# [1-]
        sll	$8, 1, $22 	# [0di]
        ldq	$6, PROCESSORSTATE_DBCBASE($14)	#  [1-]
        and	$22, $7, $22 	# Hash index [1di]
        bis	$31, 1, $7 	# [1]
        sll	$7, IvoryMemoryData, $7 	# [1]
        addl	$22, $6, $22 	# [1]
        extll	$22, 0, $22 	# Clear sign-extension [1]
        s4addq	$22, $7, $7 	# [2]
        ldl	$22, 0($7)	# Fetch the key [2]
        ldl	$3, 4($7)	# Fetch value [1]
        subl	$8, $22, $6 	# Compare [2di]
        bne	$6, G15991	# Trap on miss [1]
        extll	$3, 0, $8 	# Extract the pointer, and indirect [0di]
        br	$31, G15981	# This is another memory read tailcall. [1-]
.align 3
G15991:
	br	$31, DBCACHEMISSTRAP
#endif
G15987:
/* Perform memory action */
        bis	$31, $5, $16 	# [1-]
        bis	$31, 0, $17 	# [1]
	br	$31, PERFORMMEMORYACTION
.align 3
G15980:
	br	$31, ILLEGALTRAPVECTOR
.end StartPreTrap
.align 5
.globl FinishPreTrap
.ent FinishPreTrap 0
.align 3
FinishPreTrap:
        ldq	$10, PROCESSORSTATE_RESTARTSP($14)	#  [1-]
        addq	$10, 8, $10 	# iFP now points to the start of our new frame [3]
        addq	$12, 8, $11 	# Points beyond the last argument [1]
        ldq	$4, PROCESSORSTATE_FCCRTRAPMASK($14)	# Get CR mask [0di]
        ldah	$5, ValueDispositionValue*4	# 1<<18! [1-]
        subq	$11, $10, $6 	# Arg size [1]
        subq	$10, $1, $8 	# Caller Frame Size [1]
        srl	$6, 3, $6 	# Arg size in words [1]
        sll	$8, 6, $8 	# Caller Frame Size in words in place [1]
        bis	$5, $6, $5 	# [1]
        bis	$5, $8, $5 	# [1]
/* TagCdr. */
        srl	$2, 6, $22 	# [1]
        srl	$7, 30, $6 	# [1]
        subq	$22, $6, $8 	# [2]
        cmovge	$8, $22, $6 	# [1]
        sll	$6, 30, $6 	# [2]
        and	$7, $4, $7 	# Mask off unwanted bits [1]
        bis	$7, $6, $7 	# Add trap mode [1]
        bis	$7, $5, $7 	# Add argsize, apply, disposition, caller FS [1]
        stl	$7, PROCESSORSTATE_CONTROL($14)	#  [0di]
/* Convert real continuation to PC. */
        and	$2, 1, $9 	# [1-]
        addq	$3, $9, $9 	# [1]
        addq	$3, $9, $9 	# [1]
/* Check for stack overflow */
        srl	$7, 30, $7 	# Isolate trap mode [1]
        ldl	$8, PROCESSORSTATE_CSLIMIT($14)	# Limit for emulator mode [1-]
        ldl	$22, PROCESSORSTATE_CSEXTRALIMIT($14)	# Limit for extra stack and higher modes [1]
        cmovne	$7, $22, $8 	# Get the right limit for the current trap mode [3]
        extll	$8, 0, $8 	# Might have been sign extended [2]
/* Convert stack cache address to VMA */
        ldq	$22, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1-]
        ldq	$7, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [1]
        subq	$12, $22, $22 	# stack cache base relative offset [2-]
        srl	$22, 3, $22 	# convert byte address to word address [1]
        addq	$22, $7, $7 	# reconstruct VMA [2]
        cmplt	$7, $8, $22 	# Check for overflow [1]
        beq	$22, STACKOVERFLOW	# Jump if overflow [1]
/* Convert a halfword address into a CP pointer. */
        srl	$9, CacheLineRShift, $13 	# Get third byte into bottom [0di]
        ldq	$22, PROCESSORSTATE_ICACHEBASE($14)	# get the base of the icache [1-]
        lda	$8, -1	#  [0di]
        ldah	$8, 4($8)	#  [1]
        sll	$13, CacheLineLShift, $13 	# Now third byte is zero-shifted [1]
        addq	$9, $13, $13 	# [2]
        and	$13, $8, $13 	# [1]
        sll	$13, 5, $8 	# temp=cpos*32 [1]
        sll	$13, 4, $13 	# cpos=cpos*16 [1]
        addq	$22, $8, $22 	# temp2=base+cpos*32 [1]
        addq	$22, $13, $13 	# cpos=base+cpos*48 [1]
        br	$31, CACHEVALID	# [1-]
.end FinishPreTrap
.align 5
.globl ILLEGALOPERAND
.ent ILLEGALOPERAND 0
.align 3
ILLEGALOPERAND:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterError	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorError, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeFixnum, $24 	# [1]
        stl	$17, 8($12)	#  [0di]
        stl	$24, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        bis	$31, TypeLocative, $24 	# [1]
        stl	$20, 8($12)	#  [1di]
        stl	$24, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, FinishPreTrap	# [1-]
.end ILLEGALOPERAND
.align 5
.globl RESETTRAP
.ent RESETTRAP 0
.align 3
RESETTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorReset	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorReset, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        br	$31, FinishPreTrap	# [1-]
.end RESETTRAP
.align 5
.globl PULLAPPLYARGSTRAP
.ent PULLAPPLYARGSTRAP 0
.align 3
PULLAPPLYARGSTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorPullApplyArgs	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldl	$25, 0($12)	#  [1]
        ldl	$24, 4($12)	#  [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$25, 0, $25 	# [1]
        stq	$12, PROCESSORSTATE_RESTARTSP($14)	#  [1-]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorPullApplyArgs, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeFixnum, $17 	# [1]
        stl	$16, 8($12)	#  [1-]
        stl	$17, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        and	$24, 63, $17 	# set CDR-NEXT [1]
        stl	$25, 8($12)	#  [1-]
        stl	$17, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end PULLAPPLYARGSTRAP
.align 5
.globl TRACETRAP
.ent TRACETRAP 0
.align 3
TRACETRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorTrace	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorTrace, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        br	$31, FinishPreTrap	# [1-]
.end TRACETRAP
.align 5
.globl PREEMPTREQUESTTRAP
.ent PREEMPTREQUESTTRAP 0
.align 3
PREEMPTREQUESTTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorPreemptRequest	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorPreemptRequest, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        br	$31, FinishPreTrap	# [1-]
.end PREEMPTREQUESTTRAP
.align 5
.globl HIGHPRIORITYSEQUENCEBREAK
.ent HIGHPRIORITYSEQUENCEBREAK 0
.align 3
HIGHPRIORITYSEQUENCEBREAK:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorHighPrioritySequenceBreak	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorHighPrioritySequenceBreak, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        br	$31, FinishPreTrap	# [1-]
.end HIGHPRIORITYSEQUENCEBREAK
.align 5
.globl LOWPRIORITYSEQUENCEBREAK
.ent LOWPRIORITYSEQUENCEBREAK 0
.align 3
LOWPRIORITYSEQUENCEBREAK:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorLowPrioritySequenceBreak	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorLowPrioritySequenceBreak, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        br	$31, FinishPreTrap	# [1-]
.end LOWPRIORITYSEQUENCEBREAK
.align 5
.globl DBUNWINDFRAMETRAP
.ent DBUNWINDFRAMETRAP 0
.align 3
DBUNWINDFRAMETRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorDBUnwindFrame	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorDBUnwindFrame, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        ldq	$24, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        bis	$31, TypeLocative, $25 	# [0di]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end DBUNWINDFRAMETRAP
.align 5
.globl DBUNWINDCATCHTRAP
.ent DBUNWINDCATCHTRAP 0
.align 3
DBUNWINDCATCHTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapVectorDBUnwindCatch	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        bis	$10, $31, $1 	# save old frame pointer [1-]
        bis	$31, TrapVectorDBUnwindCatch, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        ldq	$24, PROCESSORSTATE_BINDINGSTACKPOINTER($14)	#  [1-]
        bis	$31, TypeLocative, $25 	# [0di]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end DBUNWINDCATCHTRAP
.align 5
.globl TRANSPORTTRAP
.ent TRANSPORTTRAP 0
.align 3
TRANSPORTTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterTransport	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorTransport, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end TRANSPORTTRAP
.align 5
.globl MONITORTRAP
.ent MONITORTRAP 0
.align 3
MONITORTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterMonitor	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorMonitor, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end MONITORTRAP
.align 5
.globl PAGENOTRESIDENT
.ent PAGENOTRESIDENT 0
.align 3
PAGENOTRESIDENT:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterPageNotResident	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorPageNotResident, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end PAGENOTRESIDENT
.align 5
.globl PAGEFAULTREQUESTHANDLER
.ent PAGEFAULTREQUESTHANDLER 0
.align 3
PAGEFAULTREQUESTHANDLER:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterPageFaultRequest	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorPageFaultRequest, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end PAGEFAULTREQUESTHANDLER
.align 5
.globl PAGEWRITEFAULT
.ent PAGEWRITEFAULT 0
.align 3
PAGEWRITEFAULT:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterPageWriteFault	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorPageWriteFault, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end PAGEWRITEFAULT
#ifdef MINIMA
.align 5
.globl DBCACHEMISSTRAP
.ent DBCACHEMISSTRAP 0
.align 3
DBCACHEMISSTRAP:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterDBCacheMiss	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorDBCacheMiss, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end DBCACHEMISSTRAP
#endif
/* The following handlers should never be invoked. */
.align 12
        and	$31, $31, $31 	# [1]
.align 12
.align 5
.globl UNCORRECTABLEMEMORYERROR
.ent UNCORRECTABLEMEMORYERROR 0
.align 3
UNCORRECTABLEMEMORYERROR:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1-]
        lda	$2, TrapMeterUncorrectableMemoryError	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorUncorrectableMemoryError, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end UNCORRECTABLEMEMORYERROR
.align 5
.globl BUSERROR
.ent BUSERROR 0
.align 3
BUSERROR:
#ifdef TRAPMETERING
        ldq	$1, PROCESSORSTATE_TRAPMETERDATA($14)	# pointer to trap data vector [1]
        lda	$2, TrapMeterMemoryBusError	# get the vector index [0di]
        s8addq	$2, $1, $1 	# [3]
        ldq	$2, 0($1)	# get the old value [2]
        lda	$2, 1($2)	# increment it [3]
        stq	$2, 0($1)	# and store it back [0di]
#endif
        ldq	$24, PROCESSORSTATE_VMA($14)	# Preserve VMA against reading trap vector [1]
        bis	$10, $31, $1 	# save old frame pointer [0di]
        bis	$31, TrapVectorMemoryBusError, $23 	# save the trap vector index [1]
	bsr	$0, StartPreTrap
        bis	$31, TypeLocative, $25 	# [1]
        stl	$24, 8($12)	#  [1-]
        stl	$25, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [1-]
        br	$31, FinishPreTrap	# [0di]
.end BUSERROR
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifuntrap.as */
