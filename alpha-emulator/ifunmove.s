/************************************************************************
 * WARNING: DO NOT EDIT THIS FILE.  THIS FILE WAS AUTOMATICALLY GENERATED
 * FROM ../alpha-emulator/ifunmove.as. ANY CHANGES MADE TO THIS FILE WILL BE LOST
 ************************************************************************/

/* Data movement. */
.align 5
.globl DoPushNNils
.ent DoPushNNils 0
/* Halfword operand from stack instruction - DoPushNNils */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPushNNilsFP
	.globl DoPushNNilsSP
	.globl DoPushNNilsLP
	.globl DoPushNNilsIM
.align 3
DoPushNNils:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPushNNilsSP"
#endif
.align 3
DoPushNNilsSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoPushNNils	# [0di]
	.byte 0x90
	.asciiz "DoPushNNilsLP"
#endif
.align 3
DoPushNNilsLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoPushNNils	# [1]
	.byte 0x84
	.asciiz "DoPushNNilsFP"
#endif
.align 3
DoPushNNilsFP:	# Entry point for FP relative
.align 3
headDoPushNNils:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoPushNNils:
/* arg1 has the operand, not sign extended if immediate. */
        extll	$16, 0, $17 	# Get the data [3]
        srl	$16, 32, $1 	# and the tag [1]
        subq	$1, TypeFixnum, $5 	# [2]
        and	$5, 63, $5 	# Strip CDR code [1]
        bne	$5, PUSHNNBADOP	# [1]
#ifdef TRACING
        br	$31, DoPushNNilsIM	# [1]
	.byte 0x82
	.asciiz "DoPushNNilsIM"
#endif
.align 5
.align 3
DoPushNNilsIM:	# Entry point for IMMEDIATE mode
        ldl	$4, PROCESSORSTATE_SCOVLIMIT($14)	# Current stack cache limit (words) [1]
        lda	$1, 128	#  [0di]
        ldq	$2, PROCESSORSTATE_STACKCACHEDATA($14)	# Alpha base of stack cache [1-]
        addq	$1, $17, $1 	# Account for what we're about to push [0di]
        s8addq	$1, $12, $1 	# SCA of desired end of cache [1]
        s8addq	$4, $2, $2 	# SCA of current end of cache [2]
        cmple	$1, $2, $4 	# [1]
        beq	$4, StackCacheOverflowHandler	# We're done if new SCA is within bounds [1]
        ldq	$21, PROCESSORSTATE_NILADDRESS($14)	#  [1-]
        br	$31, PUSHNNILSL2	# [1]
.align 3
PUSHNNILSL1:
        stq	$21, 8($12)	# Push NIL [1]
        addq	$12, 8, $12 	# [0di]
        subq	$17, 1, $17 	# [1]
PUSHNNILSL2:
        bgt	$17, PUSHNNILSL1	# [1]
        br	$31, NEXTINSTRUCTION	# [1]
.align 3
PUSHNNBADOP:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoPushNNils
/* End of Halfword operand from stack instruction - DoPushNNils */
.align 5
.globl DoPushAddressSpRelative
.ent DoPushAddressSpRelative 0
/* Halfword operand from stack instruction - DoPushAddressSpRelative */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoPushAddressSpRelativeFP
	.globl DoPushAddressSpRelativeSP
	.globl DoPushAddressSpRelativeLP
	.globl DoPushAddressSpRelativeIM
.align 3
DoPushAddressSpRelative:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoPushAddressSpRelativeIM"
#endif
.align 3
DoPushAddressSpRelativeIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoPushAddressSpRelative	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoPushAddressSpRelativeSP"
#endif
.align 3
DoPushAddressSpRelativeSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoPushAddressSpRelative	# [0di]
	.byte 0x90
	.asciiz "DoPushAddressSpRelativeLP"
#endif
.align 3
DoPushAddressSpRelativeLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoPushAddressSpRelative	# [1]
	.byte 0x84
	.asciiz "DoPushAddressSpRelativeFP"
#endif
.align 3
DoPushAddressSpRelativeFP:	# Entry point for FP relative
.align 3
headDoPushAddressSpRelative:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoPushAddressSpRelative:
/* arg1 has the operand, not sign extended if immediate. */
        ldq	$4, PROCESSORSTATE_RESTARTSP($14)	# SP before any popping [1]
        srl	$16, 32, $1 	# [2di]
        extll	$16, 0, $16 	# [1]
        ldq	$6, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of the stack cache [0di]
        ldq	$7, PROCESSORSTATE_STACKCACHEDATA($14)	# THe stack cache data block [1]
        and	$1, 63, $2 	# Strip off any CDR code bits. [0di]
        cmpeq	$2, TypeFixnum, $3 	# [1]
.align 3
G15111:
        beq	$3, G15108	# [1]
/* Here if argument TypeFixnum */
        s8addq	$16, 8, $16 	# [0di]
        subq	$4, $16, $5 	# Compute stack relative pointer [1]
        subq	$5, $7, $5 	# Index into stack data [1]
        srl	$5, 3, $5 	# Convert to word index [1]
        addq	$6, $5, $5 	# Convert to an ivory word address [2]
        ldq	$9, CACHELINE_NEXTPCDATA($13)	#  [1-]
        ldq	$13, CACHELINE_NEXTCP($13)	#  [1]
        bis	$31, TypeLocative, $6 	# [1-]
        stl	$5, 8($12)	#  [0di]
        stl	$6, 12($12)	# write the stack cache [1]
        addq	$12, 8, $12 	# [0di]
        br	$31, CACHEVALID	# [1-]
.align 3
G15108:
/* Here for all other cases */
        bis	$31, 0, $20 	# [1-]
        bis	$31, 63, $17 	# [1]
	br	$31, ILLEGALOPERAND
.align 3
G15107:
.end DoPushAddressSpRelative
/* End of Halfword operand from stack instruction - DoPushAddressSpRelative */
.align 5
.globl DoStackBlt
.ent DoStackBlt 0
/* Halfword operand from stack instruction - DoStackBlt */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoStackBltFP
	.globl DoStackBltSP
	.globl DoStackBltLP
	.globl DoStackBltIM
.align 3
DoStackBlt:
#ifdef TRACING
	.byte 0x82
	.asciiz "DoStackBltIM"
#endif
.align 3
DoStackBltIM:	# Entry point for IMMEDIATE mode
/* This sequence is lukewarm */
        stl	$17, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1-]
        ldq	$16, PROCESSORSTATE_IMMEDIATE_ARG($14)	#  [1]
        br	$31, beginDoStackBlt	# [1]
#ifdef TRACING
	.byte 0x88
	.asciiz "DoStackBltSP"
#endif
.align 3
DoStackBltSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1-]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, headDoStackBlt	# [0di]
	.byte 0x90
	.asciiz "DoStackBltLP"
#endif
.align 3
DoStackBltLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, headDoStackBlt	# [1]
	.byte 0x84
	.asciiz "DoStackBltFP"
#endif
.align 3
DoStackBltFP:	# Entry point for FP relative
.align 3
headDoStackBlt:
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldq	$16, 0($16)	# Get the operand [2]
.align 3
beginDoStackBlt:
/* arg1 has the operand, not sign extended if immediate. */
        ldl	$3, 0($12)	# Destination locative [1]
        ldl	$2, 4($12)	# Destination locative [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$3, 0, $3 	# [1]
        extll	$16, 0, $1 	# [1]
/* Convert VMA to stack cache address */
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	#  [0di]
        ldq	$16, PROCESSORSTATE_STACKCACHEDATA($14)	#  [1]
        subq	$1, $4, $4 	# stack cache base relative offset [2di]
        s8addq	$4, $16, $16 	# reconstruct SCA [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of the stack cache [1]
        ldq	$5, PROCESSORSTATE_STACKCACHETOPVMA($14)	# End ofthe stack cache [1]
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	# THe stack cache data block [1]
        subq	$3, $4, $6 	# BAse of Stack Cache. [1-]
        subq	$3, $5, $7 	# Top of Stack Cache. [1]
        blt	$6, STKBLTEXC	# J. if vma below stack cache [1-]
        bge	$7, STKBLTEXC	# J. if vma above stack cache [1]
        s8addq	$6, $1, $6 	# Compute the stackcache address [1-]
        br	$31, STKBLTLOOPEND	# [0di]
.align 3
STKBLTLOOP:
        addq	$16, 8, $16 	# Advance Source [1-]
        addq	$6, 8, $6 	# Advance destination [1]
STKBLTLOOPEND:
        ldq	$1, 0($16)	# Read a word from the source [1-]
        subq	$16, $12, $4 	# [0di]
        stq	$1, 0($6)	# copy the word [1-]
        bne	$4, STKBLTLOOP	# J. if sourse not stack top [1]
        bis	$6, $31, $12 	# Update the SP to point at the last written location [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
STKBLTEXC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 73, $17 	# [1]
	br	$31, ILLEGALOPERAND
.end DoStackBlt
/* End of Halfword operand from stack instruction - DoStackBlt */
.align 5
.globl DoStackBltAddress
.ent DoStackBltAddress 0
/* Halfword operand from stack instruction - DoStackBltAddress */
/* arg2 has the preloaded 8 bit operand. */
	.globl DoStackBltAddressFP
	.globl DoStackBltAddressSP
	.globl DoStackBltAddressLP
	.globl DoStackBltAddressIM
.align 3
DoStackBltAddress:
#ifdef TRACING
	.byte 0x88
	.asciiz "DoStackBltAddressSP"
#endif
.align 3
DoStackBltAddressSP:	# Entry point for SP relative
        bis	$20, $31, $16 	# Assume SP mode [1]
        cmoveq	$17, $12, $16 	# SP-pop mode [1]
        cmoveq	$17, $19, $12 	# Adjust SP if SP-pop mode [1]
#ifdef TRACING
        br	$31, beginDoStackBltAddress	# [0di]
	.byte 0x90
	.asciiz "DoStackBltAddressLP"
#endif
.align 3
DoStackBltAddressLP:	# Entry point for LP relative
#ifdef TRACING
        br	$31, beginDoStackBltAddress	# [1]
	.byte 0x84
	.asciiz "DoStackBltAddressFP"
#endif
.align 3
DoStackBltAddressFP:	# Entry point for FP relative
.align 3
beginDoStackBltAddress:
/* arg1 has the operand address. */
        s8addq	$17, $16, $16 	# Compute operand address [1-]
        ldl	$3, 0($12)	# Destination locative [0di]
        ldl	$2, 4($12)	# Destination locative [1]
        subq	$12, 8, $12 	# Pop Stack. [1]
        extll	$3, 0, $3 	# [1]
        ldq	$4, PROCESSORSTATE_STACKCACHEBASEVMA($14)	# Base of the stack cache [0di]
        ldq	$5, PROCESSORSTATE_STACKCACHETOPVMA($14)	# End ofthe stack cache [1]
        ldq	$1, PROCESSORSTATE_STACKCACHEDATA($14)	# THe stack cache data block [1]
        subq	$3, $4, $6 	# Base of Stack Cache. [1-]
        subq	$3, $5, $7 	# Top of Stack Cache. [1]
        blt	$6, STKBLTADREXC	# J. if vma below stack cache [1-]
        bge	$7, STKBLTADREXC	# J. if vma above stack cache [1]
        s8addq	$6, $1, $6 	# Compute the stackcache address [1-]
        br	$31, STKBLTADDLOOPEND	# [0di]
.align 3
STKBLTADDLOOP:
        addq	$16, 8, $16 	# Advance Source [1-]
        addq	$6, 8, $6 	# Advance destination [1]
STKBLTADDLOOPEND:
        ldq	$1, 0($16)	# Read a word from the source [1-]
        subq	$16, $12, $4 	# [0di]
        stq	$1, 0($6)	# copy the word [1-]
        bne	$4, STKBLTADDLOOP	# J. if sourse not stack top [1]
        bis	$6, $31, $12 	# Update the SP to point at the last written location [1-]
        br	$31, NEXTINSTRUCTION	# [0di]
.align 3
STKBLTADREXC:
        bis	$31, 0, $20 	# [1-]
        bis	$31, 73, $17 	# [1]
	br	$31, ILLEGALOPERAND
#ifdef TRACING
	.byte 0x82
	.asciiz "DoStackBltAddressIM"
#endif
DoStackBltAddressIM:	# Entry point for IMMEDIATE mode
	br	$31, DoIStageError	# IMMEDIATE mode not legal in DoStackBltAddress.
.end DoStackBltAddress
/* End of Halfword operand from stack instruction - DoStackBltAddress */
/* Fin. */


/* End of file automatically generated from ../alpha-emulator/ifunmove.as */
