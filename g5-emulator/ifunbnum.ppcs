;;; -*- Mode: LISP; Syntax: Common-Lisp; Package: ALPHA-AXP-INTERNALS; Base: 10; Lowercase: T -*-

;(include-header "aihead.s")
;(include-header "aistat.s")
;(include-header "ifunhead.s")

(comment "Bignums.")

;;; no stack level change
(define-instruction |DoAddBignumStep| :operand-from-stack-immediate ()
    (LWA arg2 4 (isp) "Get arg2")
    (LWA t2 0 (isp) "and its tag")
    (srdi t3 arg1 32)
    (clrldi arg1 arg1 32 "Strip type from arg3")
    (CheckDataType t3 |TypeFixnum| addbignumsteplose t4)
    (LWA arg3 -4 (isp) "Get arg1")
    (LWA t1 -8 (isp) "and its tag")
    (clrldi arg2 arg2 32 "Clear sign extension from arg2")
    (CheckDataType t2 |TypeFixnum| addbignumsteplose t4)
    (clrldi arg3 arg3 32 "Clear sign extension")
    (CheckDataType t1 |TypeFixnum| addbignumsteplose t4)
    (ADD arg4 arg1 arg2)
    (ADD arg5 arg3 arg4)
    (srdi arg6 arg5 32 "Shift the carry into arg6")
    ;; T1 has |TypeFixnum| in it here
    (GetNextPCandCP)
    (stack-write2-disp iSP -8 t1 arg5 "Store fixnum result")
    (stack-write2 iSP t1 arg6 "Store the carry if any")
    (ContinueToNextInstruction-NoStall)
  (label addbignumsteplose)
    (illegal-operand three-operand-fixnum-type-error))

;;; no stack level change
(define-instruction |DoSubBignumStep| :operand-from-stack-immediate ()
    (LWA arg2 4 (isp) "Get arg2")
    (LWA t2 0 (isp) "and its tag")
    (srdi t3 arg1 32)
    (clrldi arg1 arg1 32 "Strip type from arg3")
    (CheckDataType t3 |TypeFixnum| subbignumsteplose t4)
    (LWA arg3 -4 (isp) "Get arg1")
    (LWA t1 -8 (isp) "and its tag")
    (clrldi arg2 arg2 32 "Clear sign extension from arg2")
    (CheckDataType t2 |TypeFixnum| subbignumsteplose t4)
    (clrldi arg3 arg3 32 "Clear sign extension")
    (CheckDataType t1 |TypeFixnum| subbignumsteplose t4)
    (SUBF arg4 arg2 arg3 "arg1-arg2")
    (srdi arg6 arg4 63 "arg6=1 if we borrowed in 1st step")
    (clrldi arg4 arg4 32 "Truncate 1st step to 32-bits")
    (SUBF arg5 arg1 arg4 "(arg1-arg2)-arg3")
    (srdi t6 arg5 63 "t6=1 if we borrowed in 2nd step")
    ;; T1 has |TypeFixnum| in it here
    (GetNextPCandCP)
    (stack-write2-disp iSP -8 t1 arg5 "Store fixnum result")
    (ADD arg6 arg6 t6 "Compute borrow")
    (stack-write2 iSP t1 arg6 "Store the borrow if any")
    (ContinueToNextInstruction-NoStall)
  (label subbignumsteplose)
    (illegal-operand three-operand-fixnum-type-error))

(define-instruction |DoMultiplyBignumStep| :operand-from-stack-immediate ()
    (LWA arg2 4 (isp) "Get arg1")
    (LWA t1 0 (isp))
    (srdi t2 arg1 32)
    (clrldi arg1 arg1 32 "Strip type from arg2")
    (CheckDataType t2 |TypeFixnum| multbignumsteplose t4)
    (clrldi arg2 arg2 32)
    (CheckDataType t1 |TypeFixnum| multbignumsteplose t4)
    (MULLD arg3 arg2 arg1 "arg1*arg2")
    (srdi arg6 arg3 32 "arg6=high order word") ;+++
    ;; T1 has |TypeFixnum| in it here
    (GetNextPCandCP)
    (stack-write2 iSP t1 arg3 "Store fixnum result ls word")
    (stack-push2-with-cdr t1 arg6 "Store ms word")
    (ContinueToNextInstruction-NoStall)
  (label multbignumsteplose)
    (illegal-operand two-operand-fixnum-type-error))

;;+++ Needs to signal DIVIDE-OVERFLOW if final carry is non-zero
(define-instruction |DoDivideBignumStep| :operand-from-stack-immediate ()
    (LWA arg2 4 (isp) "Get arg2")
    (LWA t1 0 (isp))
    (srdi t2 arg1 32)
    (clrldi arg1 arg1 32)				;this is an unsigned divide
    (CheckDataType t2 |TypeFixnum| divbignumsteplose1 t4)
    (branch-if-zero arg1 divbignumsteplose2 "J. if division by zero")
    (clrldi arg2 arg2 32)
    (LWA arg3 -4 (isp) "Get arg1")
    (LWA t3 -8 (isp))
    (CheckDataType t1 |TypeFixnum| divbignumsteplose1 t4)
    (sldi arg2 arg2 32 "arg2=(ash arg2 32)")
    (clrldi arg3 arg3 32)
    (CheckDataType t3 |TypeFixnum| divbignumsteplose1 t4)
    (OR arg4 arg3 arg2 "arg1+(ash arg2 32)")
    (DIVDU t1 arg4 arg1 "t1 is now the quotient")
    (MULLD t2 t1 arg1)
    (SUBF t2 t2 arg4 "t2 is now the remainder")
    (STW t1 -4 (iSP) "store quotient (already fixnum)")
    (STW t2 4 (iSP) "store remainder (already fixnum)")
    (ContinueToNextInstruction)
  (label divbignumsteplose1)
    (illegal-operand three-operand-fixnum-type-error)
  (label divbignumsteplose2)
    (illegal-operand %divide-bignum-step-not-fixnum-or-zero))

(define-instruction |DoLshcBignumStep| :operand-from-stack-signed-immediate ()
    (LWA arg2 4 (isp) "Get arg2")
    (LWA t2 0 (isp))
    (ADDI isp isp -8 "Pop Stack")
    (srdi t3 arg1 32)
    (clrldi arg1 arg1 32 "Strip type from arg3")
    (CheckDataType t3 |TypeFixnum| lshcbignumsteplose t4)
    (clrldi arg2 arg2 32)
    (LWA arg3 4 (isp) "Get arg1")
    (LWA t1 0 (isp))
    (CheckDataType t2 |TypeFixnum| lshcbignumsteplose t4)
    (sldi arg2 arg2 32 "arg2=(ash arg2 32)")
    (clrldi arg3 arg3 32)
    (CheckDataType t1 |TypeFixnum| lshcbignumsteplose t4)
    (OR arg4 arg3 arg2 "arg1+(ash arg2 32)")
    (SLD arg5 arg4 arg1)
    (SRADI arg6 arg5 32 "Extract the result")
    ;; T1 has |TypeFixnum| in it here
    (GetNextPCandCP)
    (stack-write2 iSP t1 arg6 "Store the result as a fixnum")
    (ContinueToNextInstruction-NoStall)
  (label lshcbignumsteplose)
    (illegal-operand three-operand-fixnum-type-error))


(comment "Fin.")
